
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model PackageCourse
 * 
 */
export type PackageCourse = $Result.DefaultSelection<Prisma.$PackageCoursePayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model Author
 * 
 */
export type Author = $Result.DefaultSelection<Prisma.$AuthorPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model SeoMeta
 * 
 */
export type SeoMeta = $Result.DefaultSelection<Prisma.$SeoMetaPayload>
/**
 * Model Revision
 * 
 */
export type Revision = $Result.DefaultSelection<Prisma.$RevisionPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Snippet
 * 
 */
export type Snippet = $Result.DefaultSelection<Prisma.$SnippetPayload>
/**
 * Model Redirect
 * 
 */
export type Redirect = $Result.DefaultSelection<Prisma.$RedirectPayload>
/**
 * Model ContentSection
 * 
 */
export type ContentSection = $Result.DefaultSelection<Prisma.$ContentSectionPayload>
/**
 * Model QuickEditItem
 * 
 */
export type QuickEditItem = $Result.DefaultSelection<Prisma.$QuickEditItemPayload>
/**
 * Model QuickEditRevision
 * 
 */
export type QuickEditRevision = $Result.DefaultSelection<Prisma.$QuickEditRevisionPayload>
/**
 * Model ThemeSetting
 * 
 */
export type ThemeSetting = $Result.DefaultSelection<Prisma.$ThemeSettingPayload>
/**
 * Model LivePreviewToken
 * 
 */
export type LivePreviewToken = $Result.DefaultSelection<Prisma.$LivePreviewTokenPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  CONTENT_EDITOR: 'CONTENT_EDITOR',
  PUBLISHER: 'PUBLISHER',
  INSTRUCTOR: 'INSTRUCTOR',
  SUPPORT_MODERATOR: 'SUPPORT_MODERATOR',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const RevisionStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  APPROVED: 'APPROVED',
  NEEDS_CHANGES: 'NEEDS_CHANGES',
  PUBLISHED: 'PUBLISHED'
};

export type RevisionStatus = (typeof RevisionStatus)[keyof typeof RevisionStatus]


export const ContentType: {
  COURSE: 'COURSE',
  LESSON: 'LESSON',
  PACKAGE: 'PACKAGE',
  BLOG_POST: 'BLOG_POST',
  PAGE: 'PAGE'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const CourseLevel: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type CourseLevel = (typeof CourseLevel)[keyof typeof CourseLevel]


export const PackageType: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM',
  PRO_MAX: 'PRO_MAX'
};

export type PackageType = (typeof PackageType)[keyof typeof PackageType]


export const QuickEditType: {
  TEXT: 'TEXT',
  COLOR: 'COLOR',
  BUTTON_LABEL: 'BUTTON_LABEL',
  BUTTON_COLOR: 'BUTTON_COLOR',
  BACKGROUND_COLOR: 'BACKGROUND_COLOR',
  FONT_SIZE: 'FONT_SIZE',
  FONT_WEIGHT: 'FONT_WEIGHT',
  SPACING: 'SPACING',
  BORDER_RADIUS: 'BORDER_RADIUS',
  SHADOW: 'SHADOW'
};

export type QuickEditType = (typeof QuickEditType)[keyof typeof QuickEditType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type RevisionStatus = $Enums.RevisionStatus

export const RevisionStatus: typeof $Enums.RevisionStatus

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type CourseLevel = $Enums.CourseLevel

export const CourseLevel: typeof $Enums.CourseLevel

export type PackageType = $Enums.PackageType

export const PackageType: typeof $Enums.PackageType

export type QuickEditType = $Enums.QuickEditType

export const QuickEditType: typeof $Enums.QuickEditType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packageCourse`: Exposes CRUD operations for the **PackageCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageCourses
    * const packageCourses = await prisma.packageCourse.findMany()
    * ```
    */
  get packageCourse(): Prisma.PackageCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seoMeta`: Exposes CRUD operations for the **SeoMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeoMetas
    * const seoMetas = await prisma.seoMeta.findMany()
    * ```
    */
  get seoMeta(): Prisma.SeoMetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.revision`: Exposes CRUD operations for the **Revision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Revisions
    * const revisions = await prisma.revision.findMany()
    * ```
    */
  get revision(): Prisma.RevisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.snippet`: Exposes CRUD operations for the **Snippet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snippets
    * const snippets = await prisma.snippet.findMany()
    * ```
    */
  get snippet(): Prisma.SnippetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redirect`: Exposes CRUD operations for the **Redirect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redirects
    * const redirects = await prisma.redirect.findMany()
    * ```
    */
  get redirect(): Prisma.RedirectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentSection`: Exposes CRUD operations for the **ContentSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentSections
    * const contentSections = await prisma.contentSection.findMany()
    * ```
    */
  get contentSection(): Prisma.ContentSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quickEditItem`: Exposes CRUD operations for the **QuickEditItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuickEditItems
    * const quickEditItems = await prisma.quickEditItem.findMany()
    * ```
    */
  get quickEditItem(): Prisma.QuickEditItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quickEditRevision`: Exposes CRUD operations for the **QuickEditRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuickEditRevisions
    * const quickEditRevisions = await prisma.quickEditRevision.findMany()
    * ```
    */
  get quickEditRevision(): Prisma.QuickEditRevisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.themeSetting`: Exposes CRUD operations for the **ThemeSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThemeSettings
    * const themeSettings = await prisma.themeSetting.findMany()
    * ```
    */
  get themeSetting(): Prisma.ThemeSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.livePreviewToken`: Exposes CRUD operations for the **LivePreviewToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LivePreviewTokens
    * const livePreviewTokens = await prisma.livePreviewToken.findMany()
    * ```
    */
  get livePreviewToken(): Prisma.LivePreviewTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    Course: 'Course',
    Lesson: 'Lesson',
    Package: 'Package',
    PackageCourse: 'PackageCourse',
    BlogPost: 'BlogPost',
    Page: 'Page',
    Author: 'Author',
    Media: 'Media',
    SeoMeta: 'SeoMeta',
    Revision: 'Revision',
    Settings: 'Settings',
    Snippet: 'Snippet',
    Redirect: 'Redirect',
    ContentSection: 'ContentSection',
    QuickEditItem: 'QuickEditItem',
    QuickEditRevision: 'QuickEditRevision',
    ThemeSetting: 'ThemeSetting',
    LivePreviewToken: 'LivePreviewToken',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "course" | "lesson" | "package" | "packageCourse" | "blogPost" | "page" | "author" | "media" | "seoMeta" | "revision" | "settings" | "snippet" | "redirect" | "contentSection" | "quickEditItem" | "quickEditRevision" | "themeSetting" | "livePreviewToken" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      PackageCourse: {
        payload: Prisma.$PackageCoursePayload<ExtArgs>
        fields: Prisma.PackageCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>
          }
          findFirst: {
            args: Prisma.PackageCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>
          }
          findMany: {
            args: Prisma.PackageCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>[]
          }
          create: {
            args: Prisma.PackageCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>
          }
          createMany: {
            args: Prisma.PackageCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>[]
          }
          delete: {
            args: Prisma.PackageCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>
          }
          update: {
            args: Prisma.PackageCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>
          }
          deleteMany: {
            args: Prisma.PackageCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>[]
          }
          upsert: {
            args: Prisma.PackageCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageCoursePayload>
          }
          aggregate: {
            args: Prisma.PackageCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageCourse>
          }
          groupBy: {
            args: Prisma.PackageCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCourseCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCourseCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      Author: {
        payload: Prisma.$AuthorPayload<ExtArgs>
        fields: Prisma.AuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findFirst: {
            args: Prisma.AuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findMany: {
            args: Prisma.AuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          create: {
            args: Prisma.AuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          createMany: {
            args: Prisma.AuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          delete: {
            args: Prisma.AuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          update: {
            args: Prisma.AuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          deleteMany: {
            args: Prisma.AuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          upsert: {
            args: Prisma.AuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          aggregate: {
            args: Prisma.AuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthor>
          }
          groupBy: {
            args: Prisma.AuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      SeoMeta: {
        payload: Prisma.$SeoMetaPayload<ExtArgs>
        fields: Prisma.SeoMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>
          }
          findFirst: {
            args: Prisma.SeoMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>
          }
          findMany: {
            args: Prisma.SeoMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>[]
          }
          create: {
            args: Prisma.SeoMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>
          }
          createMany: {
            args: Prisma.SeoMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeoMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>[]
          }
          delete: {
            args: Prisma.SeoMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>
          }
          update: {
            args: Prisma.SeoMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>
          }
          deleteMany: {
            args: Prisma.SeoMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeoMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>[]
          }
          upsert: {
            args: Prisma.SeoMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoMetaPayload>
          }
          aggregate: {
            args: Prisma.SeoMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeoMeta>
          }
          groupBy: {
            args: Prisma.SeoMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoMetaCountArgs<ExtArgs>
            result: $Utils.Optional<SeoMetaCountAggregateOutputType> | number
          }
        }
      }
      Revision: {
        payload: Prisma.$RevisionPayload<ExtArgs>
        fields: Prisma.RevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>
          }
          findFirst: {
            args: Prisma.RevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>
          }
          findMany: {
            args: Prisma.RevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>[]
          }
          create: {
            args: Prisma.RevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>
          }
          createMany: {
            args: Prisma.RevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>[]
          }
          delete: {
            args: Prisma.RevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>
          }
          update: {
            args: Prisma.RevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>
          }
          deleteMany: {
            args: Prisma.RevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RevisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>[]
          }
          upsert: {
            args: Prisma.RevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevisionPayload>
          }
          aggregate: {
            args: Prisma.RevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevision>
          }
          groupBy: {
            args: Prisma.RevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevisionCountArgs<ExtArgs>
            result: $Utils.Optional<RevisionCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Snippet: {
        payload: Prisma.$SnippetPayload<ExtArgs>
        fields: Prisma.SnippetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnippetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnippetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          findFirst: {
            args: Prisma.SnippetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnippetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          findMany: {
            args: Prisma.SnippetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          create: {
            args: Prisma.SnippetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          createMany: {
            args: Prisma.SnippetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnippetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          delete: {
            args: Prisma.SnippetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          update: {
            args: Prisma.SnippetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          deleteMany: {
            args: Prisma.SnippetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnippetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SnippetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          upsert: {
            args: Prisma.SnippetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          aggregate: {
            args: Prisma.SnippetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnippet>
          }
          groupBy: {
            args: Prisma.SnippetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnippetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnippetCountArgs<ExtArgs>
            result: $Utils.Optional<SnippetCountAggregateOutputType> | number
          }
        }
      }
      Redirect: {
        payload: Prisma.$RedirectPayload<ExtArgs>
        fields: Prisma.RedirectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedirectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedirectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          findFirst: {
            args: Prisma.RedirectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedirectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          findMany: {
            args: Prisma.RedirectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>[]
          }
          create: {
            args: Prisma.RedirectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          createMany: {
            args: Prisma.RedirectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedirectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>[]
          }
          delete: {
            args: Prisma.RedirectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          update: {
            args: Prisma.RedirectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          deleteMany: {
            args: Prisma.RedirectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedirectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RedirectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>[]
          }
          upsert: {
            args: Prisma.RedirectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          aggregate: {
            args: Prisma.RedirectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedirect>
          }
          groupBy: {
            args: Prisma.RedirectGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedirectGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedirectCountArgs<ExtArgs>
            result: $Utils.Optional<RedirectCountAggregateOutputType> | number
          }
        }
      }
      ContentSection: {
        payload: Prisma.$ContentSectionPayload<ExtArgs>
        fields: Prisma.ContentSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>
          }
          findFirst: {
            args: Prisma.ContentSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>
          }
          findMany: {
            args: Prisma.ContentSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>[]
          }
          create: {
            args: Prisma.ContentSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>
          }
          createMany: {
            args: Prisma.ContentSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>[]
          }
          delete: {
            args: Prisma.ContentSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>
          }
          update: {
            args: Prisma.ContentSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>
          }
          deleteMany: {
            args: Prisma.ContentSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>[]
          }
          upsert: {
            args: Prisma.ContentSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSectionPayload>
          }
          aggregate: {
            args: Prisma.ContentSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentSection>
          }
          groupBy: {
            args: Prisma.ContentSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentSectionCountArgs<ExtArgs>
            result: $Utils.Optional<ContentSectionCountAggregateOutputType> | number
          }
        }
      }
      QuickEditItem: {
        payload: Prisma.$QuickEditItemPayload<ExtArgs>
        fields: Prisma.QuickEditItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuickEditItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuickEditItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>
          }
          findFirst: {
            args: Prisma.QuickEditItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuickEditItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>
          }
          findMany: {
            args: Prisma.QuickEditItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>[]
          }
          create: {
            args: Prisma.QuickEditItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>
          }
          createMany: {
            args: Prisma.QuickEditItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuickEditItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>[]
          }
          delete: {
            args: Prisma.QuickEditItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>
          }
          update: {
            args: Prisma.QuickEditItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>
          }
          deleteMany: {
            args: Prisma.QuickEditItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuickEditItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuickEditItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>[]
          }
          upsert: {
            args: Prisma.QuickEditItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditItemPayload>
          }
          aggregate: {
            args: Prisma.QuickEditItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuickEditItem>
          }
          groupBy: {
            args: Prisma.QuickEditItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuickEditItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuickEditItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuickEditItemCountAggregateOutputType> | number
          }
        }
      }
      QuickEditRevision: {
        payload: Prisma.$QuickEditRevisionPayload<ExtArgs>
        fields: Prisma.QuickEditRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuickEditRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuickEditRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>
          }
          findFirst: {
            args: Prisma.QuickEditRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuickEditRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>
          }
          findMany: {
            args: Prisma.QuickEditRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>[]
          }
          create: {
            args: Prisma.QuickEditRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>
          }
          createMany: {
            args: Prisma.QuickEditRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuickEditRevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>[]
          }
          delete: {
            args: Prisma.QuickEditRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>
          }
          update: {
            args: Prisma.QuickEditRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>
          }
          deleteMany: {
            args: Prisma.QuickEditRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuickEditRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuickEditRevisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>[]
          }
          upsert: {
            args: Prisma.QuickEditRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickEditRevisionPayload>
          }
          aggregate: {
            args: Prisma.QuickEditRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuickEditRevision>
          }
          groupBy: {
            args: Prisma.QuickEditRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuickEditRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuickEditRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<QuickEditRevisionCountAggregateOutputType> | number
          }
        }
      }
      ThemeSetting: {
        payload: Prisma.$ThemeSettingPayload<ExtArgs>
        fields: Prisma.ThemeSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>
          }
          findFirst: {
            args: Prisma.ThemeSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>
          }
          findMany: {
            args: Prisma.ThemeSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>[]
          }
          create: {
            args: Prisma.ThemeSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>
          }
          createMany: {
            args: Prisma.ThemeSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThemeSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>[]
          }
          delete: {
            args: Prisma.ThemeSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>
          }
          update: {
            args: Prisma.ThemeSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>
          }
          deleteMany: {
            args: Prisma.ThemeSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThemeSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>[]
          }
          upsert: {
            args: Prisma.ThemeSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeSettingPayload>
          }
          aggregate: {
            args: Prisma.ThemeSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThemeSetting>
          }
          groupBy: {
            args: Prisma.ThemeSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemeSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeSettingCountArgs<ExtArgs>
            result: $Utils.Optional<ThemeSettingCountAggregateOutputType> | number
          }
        }
      }
      LivePreviewToken: {
        payload: Prisma.$LivePreviewTokenPayload<ExtArgs>
        fields: Prisma.LivePreviewTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivePreviewTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivePreviewTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>
          }
          findFirst: {
            args: Prisma.LivePreviewTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivePreviewTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>
          }
          findMany: {
            args: Prisma.LivePreviewTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>[]
          }
          create: {
            args: Prisma.LivePreviewTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>
          }
          createMany: {
            args: Prisma.LivePreviewTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LivePreviewTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>[]
          }
          delete: {
            args: Prisma.LivePreviewTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>
          }
          update: {
            args: Prisma.LivePreviewTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>
          }
          deleteMany: {
            args: Prisma.LivePreviewTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivePreviewTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LivePreviewTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>[]
          }
          upsert: {
            args: Prisma.LivePreviewTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePreviewTokenPayload>
          }
          aggregate: {
            args: Prisma.LivePreviewTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivePreviewToken>
          }
          groupBy: {
            args: Prisma.LivePreviewTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivePreviewTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivePreviewTokenCountArgs<ExtArgs>
            result: $Utils.Optional<LivePreviewTokenCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    course?: CourseOmit
    lesson?: LessonOmit
    package?: PackageOmit
    packageCourse?: PackageCourseOmit
    blogPost?: BlogPostOmit
    page?: PageOmit
    author?: AuthorOmit
    media?: MediaOmit
    seoMeta?: SeoMetaOmit
    revision?: RevisionOmit
    settings?: SettingsOmit
    snippet?: SnippetOmit
    redirect?: RedirectOmit
    contentSection?: ContentSectionOmit
    quickEditItem?: QuickEditItemOmit
    quickEditRevision?: QuickEditRevisionOmit
    themeSetting?: ThemeSettingOmit
    livePreviewToken?: LivePreviewTokenOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdCourses: number
    createdLessons: number
    createdPackages: number
    createdBlogPosts: number
    createdPages: number
    createdSections: number
    auditLogs: number
    createdRevisions: number
    reviewedRevisions: number
    publishedRevisions: number
    refreshTokens: number
    quickEditItems: number
    quickEditRevisions: number
    themeSettings: number
    livePreviewTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdCourses?: boolean | UserCountOutputTypeCountCreatedCoursesArgs
    createdLessons?: boolean | UserCountOutputTypeCountCreatedLessonsArgs
    createdPackages?: boolean | UserCountOutputTypeCountCreatedPackagesArgs
    createdBlogPosts?: boolean | UserCountOutputTypeCountCreatedBlogPostsArgs
    createdPages?: boolean | UserCountOutputTypeCountCreatedPagesArgs
    createdSections?: boolean | UserCountOutputTypeCountCreatedSectionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    createdRevisions?: boolean | UserCountOutputTypeCountCreatedRevisionsArgs
    reviewedRevisions?: boolean | UserCountOutputTypeCountReviewedRevisionsArgs
    publishedRevisions?: boolean | UserCountOutputTypeCountPublishedRevisionsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    quickEditItems?: boolean | UserCountOutputTypeCountQuickEditItemsArgs
    quickEditRevisions?: boolean | UserCountOutputTypeCountQuickEditRevisionsArgs
    themeSettings?: boolean | UserCountOutputTypeCountThemeSettingsArgs
    livePreviewTokens?: boolean | UserCountOutputTypeCountLivePreviewTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentSectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublishedRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuickEditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickEditItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuickEditRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickEditRevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountThemeSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLivePreviewTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivePreviewTokenWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    lessons: number
    packageCourses: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | CourseCountOutputTypeCountLessonsArgs
    packageCourses?: boolean | CourseCountOutputTypeCountPackageCoursesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPackageCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageCourseWhereInput
  }


  /**
   * Count Type PackageCountOutputType
   */

  export type PackageCountOutputType = {
    packageCourses: number
  }

  export type PackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    packageCourses?: boolean | PackageCountOutputTypeCountPackageCoursesArgs
  }

  // Custom InputTypes
  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCountOutputType
     */
    select?: PackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountPackageCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageCourseWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    blogPosts: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | AuthorCountOutputTypeCountBlogPostsArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type QuickEditItemCountOutputType
   */

  export type QuickEditItemCountOutputType = {
    revisions: number
  }

  export type QuickEditItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revisions?: boolean | QuickEditItemCountOutputTypeCountRevisionsArgs
  }

  // Custom InputTypes
  /**
   * QuickEditItemCountOutputType without action
   */
  export type QuickEditItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItemCountOutputType
     */
    select?: QuickEditItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuickEditItemCountOutputType without action
   */
  export type QuickEditItemCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickEditRevisionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    role: number
    isActive: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string | null
    passwordHash: string
    role: $Enums.UserRole
    isActive: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdCourses?: boolean | User$createdCoursesArgs<ExtArgs>
    createdLessons?: boolean | User$createdLessonsArgs<ExtArgs>
    createdPackages?: boolean | User$createdPackagesArgs<ExtArgs>
    createdBlogPosts?: boolean | User$createdBlogPostsArgs<ExtArgs>
    createdPages?: boolean | User$createdPagesArgs<ExtArgs>
    createdSections?: boolean | User$createdSectionsArgs<ExtArgs>
    authorProfile?: boolean | User$authorProfileArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdRevisions?: boolean | User$createdRevisionsArgs<ExtArgs>
    reviewedRevisions?: boolean | User$reviewedRevisionsArgs<ExtArgs>
    publishedRevisions?: boolean | User$publishedRevisionsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    quickEditItems?: boolean | User$quickEditItemsArgs<ExtArgs>
    quickEditRevisions?: boolean | User$quickEditRevisionsArgs<ExtArgs>
    themeSettings?: boolean | User$themeSettingsArgs<ExtArgs>
    livePreviewTokens?: boolean | User$livePreviewTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "role" | "isActive" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdCourses?: boolean | User$createdCoursesArgs<ExtArgs>
    createdLessons?: boolean | User$createdLessonsArgs<ExtArgs>
    createdPackages?: boolean | User$createdPackagesArgs<ExtArgs>
    createdBlogPosts?: boolean | User$createdBlogPostsArgs<ExtArgs>
    createdPages?: boolean | User$createdPagesArgs<ExtArgs>
    createdSections?: boolean | User$createdSectionsArgs<ExtArgs>
    authorProfile?: boolean | User$authorProfileArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdRevisions?: boolean | User$createdRevisionsArgs<ExtArgs>
    reviewedRevisions?: boolean | User$reviewedRevisionsArgs<ExtArgs>
    publishedRevisions?: boolean | User$publishedRevisionsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    quickEditItems?: boolean | User$quickEditItemsArgs<ExtArgs>
    quickEditRevisions?: boolean | User$quickEditRevisionsArgs<ExtArgs>
    themeSettings?: boolean | User$themeSettingsArgs<ExtArgs>
    livePreviewTokens?: boolean | User$livePreviewTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdCourses: Prisma.$CoursePayload<ExtArgs>[]
      createdLessons: Prisma.$LessonPayload<ExtArgs>[]
      createdPackages: Prisma.$PackagePayload<ExtArgs>[]
      createdBlogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      createdPages: Prisma.$PagePayload<ExtArgs>[]
      createdSections: Prisma.$ContentSectionPayload<ExtArgs>[]
      authorProfile: Prisma.$AuthorPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      createdRevisions: Prisma.$RevisionPayload<ExtArgs>[]
      reviewedRevisions: Prisma.$RevisionPayload<ExtArgs>[]
      publishedRevisions: Prisma.$RevisionPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      quickEditItems: Prisma.$QuickEditItemPayload<ExtArgs>[]
      quickEditRevisions: Prisma.$QuickEditRevisionPayload<ExtArgs>[]
      themeSettings: Prisma.$ThemeSettingPayload<ExtArgs>[]
      livePreviewTokens: Prisma.$LivePreviewTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string | null
      passwordHash: string
      role: $Enums.UserRole
      isActive: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdCourses<T extends User$createdCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdLessons<T extends User$createdLessonsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPackages<T extends User$createdPackagesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBlogPosts<T extends User$createdBlogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBlogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPages<T extends User$createdPagesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSections<T extends User$createdSectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authorProfile<T extends User$authorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$authorProfileArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdRevisions<T extends User$createdRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedRevisions<T extends User$reviewedRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publishedRevisions<T extends User$publishedRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$publishedRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quickEditItems<T extends User$quickEditItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$quickEditItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quickEditRevisions<T extends User$quickEditRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$quickEditRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    themeSettings<T extends User$themeSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$themeSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    livePreviewTokens<T extends User$livePreviewTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$livePreviewTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdCourses
   */
  export type User$createdCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.createdLessons
   */
  export type User$createdLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * User.createdPackages
   */
  export type User$createdPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    cursor?: PackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * User.createdBlogPosts
   */
  export type User$createdBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.createdPages
   */
  export type User$createdPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * User.createdSections
   */
  export type User$createdSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    where?: ContentSectionWhereInput
    orderBy?: ContentSectionOrderByWithRelationInput | ContentSectionOrderByWithRelationInput[]
    cursor?: ContentSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentSectionScalarFieldEnum | ContentSectionScalarFieldEnum[]
  }

  /**
   * User.authorProfile
   */
  export type User$authorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    where?: AuthorWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.createdRevisions
   */
  export type User$createdRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    where?: RevisionWhereInput
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    cursor?: RevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevisionScalarFieldEnum | RevisionScalarFieldEnum[]
  }

  /**
   * User.reviewedRevisions
   */
  export type User$reviewedRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    where?: RevisionWhereInput
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    cursor?: RevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevisionScalarFieldEnum | RevisionScalarFieldEnum[]
  }

  /**
   * User.publishedRevisions
   */
  export type User$publishedRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    where?: RevisionWhereInput
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    cursor?: RevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevisionScalarFieldEnum | RevisionScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.quickEditItems
   */
  export type User$quickEditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    where?: QuickEditItemWhereInput
    orderBy?: QuickEditItemOrderByWithRelationInput | QuickEditItemOrderByWithRelationInput[]
    cursor?: QuickEditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuickEditItemScalarFieldEnum | QuickEditItemScalarFieldEnum[]
  }

  /**
   * User.quickEditRevisions
   */
  export type User$quickEditRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    where?: QuickEditRevisionWhereInput
    orderBy?: QuickEditRevisionOrderByWithRelationInput | QuickEditRevisionOrderByWithRelationInput[]
    cursor?: QuickEditRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuickEditRevisionScalarFieldEnum | QuickEditRevisionScalarFieldEnum[]
  }

  /**
   * User.themeSettings
   */
  export type User$themeSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    where?: ThemeSettingWhereInput
    orderBy?: ThemeSettingOrderByWithRelationInput | ThemeSettingOrderByWithRelationInput[]
    cursor?: ThemeSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeSettingScalarFieldEnum | ThemeSettingScalarFieldEnum[]
  }

  /**
   * User.livePreviewTokens
   */
  export type User$livePreviewTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    where?: LivePreviewTokenWhereInput
    orderBy?: LivePreviewTokenOrderByWithRelationInput | LivePreviewTokenOrderByWithRelationInput[]
    cursor?: LivePreviewTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivePreviewTokenScalarFieldEnum | LivePreviewTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    duration: number | null
    price: Decimal | null
  }

  export type CourseSumAggregateOutputType = {
    duration: number | null
    price: Decimal | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    slug: string | null
    shortDescription: string | null
    longDescription: string | null
    coverImage: string | null
    duration: number | null
    level: $Enums.CourseLevel | null
    language: string | null
    price: Decimal | null
    currency: string | null
    status: $Enums.ContentStatus | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    slug: string | null
    shortDescription: string | null
    longDescription: string | null
    coverImage: string | null
    duration: number | null
    level: $Enums.CourseLevel | null
    language: string | null
    price: Decimal | null
    currency: string | null
    status: $Enums.ContentStatus | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    slug: number
    shortDescription: number
    longDescription: number
    coverImage: number
    gallery: number
    duration: number
    level: number
    language: number
    price: number
    currency: number
    tags: number
    categories: number
    status: number
    isFeatured: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    duration?: true
    price?: true
  }

  export type CourseSumAggregateInputType = {
    duration?: true
    price?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    shortDescription?: true
    longDescription?: true
    coverImage?: true
    duration?: true
    level?: true
    language?: true
    price?: true
    currency?: true
    status?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    shortDescription?: true
    longDescription?: true
    coverImage?: true
    duration?: true
    level?: true
    language?: true
    price?: true
    currency?: true
    status?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    shortDescription?: true
    longDescription?: true
    coverImage?: true
    gallery?: true
    duration?: true
    level?: true
    language?: true
    price?: true
    currency?: true
    tags?: true
    categories?: true
    status?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    subtitle: string | null
    slug: string
    shortDescription: string | null
    longDescription: string | null
    coverImage: string | null
    gallery: string[]
    duration: number | null
    level: $Enums.CourseLevel
    language: string
    price: Decimal | null
    currency: string
    tags: string[]
    categories: string[]
    status: $Enums.ContentStatus
    isFeatured: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    coverImage?: boolean
    gallery?: boolean
    duration?: boolean
    level?: boolean
    language?: boolean
    price?: boolean
    currency?: boolean
    tags?: boolean
    categories?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    packageCourses?: boolean | Course$packageCoursesArgs<ExtArgs>
    seoMeta?: boolean | Course$seoMetaArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    coverImage?: boolean
    gallery?: boolean
    duration?: boolean
    level?: boolean
    language?: boolean
    price?: boolean
    currency?: boolean
    tags?: boolean
    categories?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    coverImage?: boolean
    gallery?: boolean
    duration?: boolean
    level?: boolean
    language?: boolean
    price?: boolean
    currency?: boolean
    tags?: boolean
    categories?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    coverImage?: boolean
    gallery?: boolean
    duration?: boolean
    level?: boolean
    language?: boolean
    price?: boolean
    currency?: boolean
    tags?: boolean
    categories?: boolean
    status?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "slug" | "shortDescription" | "longDescription" | "coverImage" | "gallery" | "duration" | "level" | "language" | "price" | "currency" | "tags" | "categories" | "status" | "isFeatured" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    packageCourses?: boolean | Course$packageCoursesArgs<ExtArgs>
    seoMeta?: boolean | Course$seoMetaArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      packageCourses: Prisma.$PackageCoursePayload<ExtArgs>[]
      seoMeta: Prisma.$SeoMetaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string | null
      slug: string
      shortDescription: string | null
      longDescription: string | null
      coverImage: string | null
      gallery: string[]
      duration: number | null
      level: $Enums.CourseLevel
      language: string
      price: Prisma.Decimal | null
      currency: string
      tags: string[]
      categories: string[]
      status: $Enums.ContentStatus
      isFeatured: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends Course$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Course$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packageCourses<T extends Course$packageCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$packageCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seoMeta<T extends Course$seoMetaArgs<ExtArgs> = {}>(args?: Subset<T, Course$seoMetaArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly subtitle: FieldRef<"Course", 'String'>
    readonly slug: FieldRef<"Course", 'String'>
    readonly shortDescription: FieldRef<"Course", 'String'>
    readonly longDescription: FieldRef<"Course", 'String'>
    readonly coverImage: FieldRef<"Course", 'String'>
    readonly gallery: FieldRef<"Course", 'String[]'>
    readonly duration: FieldRef<"Course", 'Int'>
    readonly level: FieldRef<"Course", 'CourseLevel'>
    readonly language: FieldRef<"Course", 'String'>
    readonly price: FieldRef<"Course", 'Decimal'>
    readonly currency: FieldRef<"Course", 'String'>
    readonly tags: FieldRef<"Course", 'String[]'>
    readonly categories: FieldRef<"Course", 'String[]'>
    readonly status: FieldRef<"Course", 'ContentStatus'>
    readonly isFeatured: FieldRef<"Course", 'Boolean'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly createdById: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.lessons
   */
  export type Course$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Course.packageCourses
   */
  export type Course$packageCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    where?: PackageCourseWhereInput
    orderBy?: PackageCourseOrderByWithRelationInput | PackageCourseOrderByWithRelationInput[]
    cursor?: PackageCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageCourseScalarFieldEnum | PackageCourseScalarFieldEnum[]
  }

  /**
   * Course.seoMeta
   */
  export type Course$seoMetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    where?: SeoMetaWhereInput
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    order: number | null
    duration: number | null
  }

  export type LessonSumAggregateOutputType = {
    order: number | null
    duration: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    order: number | null
    duration: number | null
    isPreview: boolean | null
    courseId: string | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    order: number | null
    duration: number | null
    isPreview: boolean | null
    courseId: string | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    order: number
    duration: number
    resources: number
    isPreview: number
    courseId: number
    status: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    order?: true
    duration?: true
  }

  export type LessonSumAggregateInputType = {
    order?: true
    duration?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    order?: true
    duration?: true
    isPreview?: true
    courseId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    order?: true
    duration?: true
    isPreview?: true
    courseId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    order?: true
    duration?: true
    resources?: true
    isPreview?: true
    courseId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    order: number
    duration: number | null
    resources: string[]
    isPreview: boolean
    courseId: string
    status: $Enums.ContentStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    order?: boolean
    duration?: boolean
    resources?: boolean
    isPreview?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    order?: boolean
    duration?: boolean
    resources?: boolean
    isPreview?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    order?: boolean
    duration?: boolean
    resources?: boolean
    isPreview?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    order?: boolean
    duration?: boolean
    resources?: boolean
    isPreview?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "order" | "duration" | "resources" | "isPreview" | "courseId" | "status" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      order: number
      duration: number | null
      resources: string[]
      isPreview: boolean
      courseId: string
      status: $Enums.ContentStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly slug: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'String'>
    readonly order: FieldRef<"Lesson", 'Int'>
    readonly duration: FieldRef<"Lesson", 'Int'>
    readonly resources: FieldRef<"Lesson", 'String[]'>
    readonly isPreview: FieldRef<"Lesson", 'Boolean'>
    readonly courseId: FieldRef<"Lesson", 'String'>
    readonly status: FieldRef<"Lesson", 'ContentStatus'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
    readonly createdById: FieldRef<"Lesson", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    price: Decimal | null
    validityDays: number | null
  }

  export type PackageSumAggregateOutputType = {
    price: Decimal | null
    validityDays: number | null
  }

  export type PackageMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    type: $Enums.PackageType | null
    validityDays: number | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PackageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    type: $Enums.PackageType | null
    validityDays: number | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    price: number
    type: number
    features: number
    validityDays: number
    status: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    price?: true
    validityDays?: true
  }

  export type PackageSumAggregateInputType = {
    price?: true
    validityDays?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    price?: true
    type?: true
    validityDays?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    price?: true
    type?: true
    validityDays?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    price?: true
    type?: true
    features?: true
    validityDays?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    price: Decimal
    type: $Enums.PackageType
    features: string[]
    validityDays: number | null
    status: $Enums.ContentStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    type?: boolean
    features?: boolean
    validityDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    packageCourses?: boolean | Package$packageCoursesArgs<ExtArgs>
    seoMeta?: boolean | Package$seoMetaArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    type?: boolean
    features?: boolean
    validityDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    type?: boolean
    features?: boolean
    validityDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    type?: boolean
    features?: boolean
    validityDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type PackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "price" | "type" | "features" | "validityDays" | "status" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["package"]>
  export type PackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    packageCourses?: boolean | Package$packageCoursesArgs<ExtArgs>
    seoMeta?: boolean | Package$seoMetaArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      packageCourses: Prisma.$PackageCoursePayload<ExtArgs>[]
      seoMeta: Prisma.$SeoMetaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      price: Prisma.Decimal
      type: $Enums.PackageType
      features: string[]
      validityDays: number | null
      status: $Enums.ContentStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {PackageCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages and returns the data updated in the database.
     * @param {PackageUpdateManyAndReturnArgs} args - Arguments to update many Packages.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    packageCourses<T extends Package$packageCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Package$packageCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seoMeta<T extends Package$seoMetaArgs<ExtArgs> = {}>(args?: Subset<T, Package$seoMetaArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'String'>
    readonly title: FieldRef<"Package", 'String'>
    readonly slug: FieldRef<"Package", 'String'>
    readonly description: FieldRef<"Package", 'String'>
    readonly price: FieldRef<"Package", 'Decimal'>
    readonly type: FieldRef<"Package", 'PackageType'>
    readonly features: FieldRef<"Package", 'String[]'>
    readonly validityDays: FieldRef<"Package", 'Int'>
    readonly status: FieldRef<"Package", 'ContentStatus'>
    readonly createdAt: FieldRef<"Package", 'DateTime'>
    readonly updatedAt: FieldRef<"Package", 'DateTime'>
    readonly createdById: FieldRef<"Package", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package createManyAndReturn
   */
  export type PackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package updateManyAndReturn
   */
  export type PackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to delete.
     */
    limit?: number
  }

  /**
   * Package.packageCourses
   */
  export type Package$packageCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    where?: PackageCourseWhereInput
    orderBy?: PackageCourseOrderByWithRelationInput | PackageCourseOrderByWithRelationInput[]
    cursor?: PackageCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageCourseScalarFieldEnum | PackageCourseScalarFieldEnum[]
  }

  /**
   * Package.seoMeta
   */
  export type Package$seoMetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    where?: SeoMetaWhereInput
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
  }


  /**
   * Model PackageCourse
   */

  export type AggregatePackageCourse = {
    _count: PackageCourseCountAggregateOutputType | null
    _min: PackageCourseMinAggregateOutputType | null
    _max: PackageCourseMaxAggregateOutputType | null
  }

  export type PackageCourseMinAggregateOutputType = {
    id: string | null
    packageId: string | null
    courseId: string | null
  }

  export type PackageCourseMaxAggregateOutputType = {
    id: string | null
    packageId: string | null
    courseId: string | null
  }

  export type PackageCourseCountAggregateOutputType = {
    id: number
    packageId: number
    courseId: number
    _all: number
  }


  export type PackageCourseMinAggregateInputType = {
    id?: true
    packageId?: true
    courseId?: true
  }

  export type PackageCourseMaxAggregateInputType = {
    id?: true
    packageId?: true
    courseId?: true
  }

  export type PackageCourseCountAggregateInputType = {
    id?: true
    packageId?: true
    courseId?: true
    _all?: true
  }

  export type PackageCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageCourse to aggregate.
     */
    where?: PackageCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageCourses to fetch.
     */
    orderBy?: PackageCourseOrderByWithRelationInput | PackageCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageCourses
    **/
    _count?: true | PackageCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageCourseMaxAggregateInputType
  }

  export type GetPackageCourseAggregateType<T extends PackageCourseAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageCourse[P]>
      : GetScalarType<T[P], AggregatePackageCourse[P]>
  }




  export type PackageCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageCourseWhereInput
    orderBy?: PackageCourseOrderByWithAggregationInput | PackageCourseOrderByWithAggregationInput[]
    by: PackageCourseScalarFieldEnum[] | PackageCourseScalarFieldEnum
    having?: PackageCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCourseCountAggregateInputType | true
    _min?: PackageCourseMinAggregateInputType
    _max?: PackageCourseMaxAggregateInputType
  }

  export type PackageCourseGroupByOutputType = {
    id: string
    packageId: string
    courseId: string
    _count: PackageCourseCountAggregateOutputType | null
    _min: PackageCourseMinAggregateOutputType | null
    _max: PackageCourseMaxAggregateOutputType | null
  }

  type GetPackageCourseGroupByPayload<T extends PackageCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageCourseGroupByOutputType[P]>
            : GetScalarType<T[P], PackageCourseGroupByOutputType[P]>
        }
      >
    >


  export type PackageCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    courseId?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageCourse"]>

  export type PackageCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    courseId?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageCourse"]>

  export type PackageCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    courseId?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageCourse"]>

  export type PackageCourseSelectScalar = {
    id?: boolean
    packageId?: boolean
    courseId?: boolean
  }

  export type PackageCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "packageId" | "courseId", ExtArgs["result"]["packageCourse"]>
  export type PackageCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type PackageCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type PackageCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $PackageCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageCourse"
    objects: {
      package: Prisma.$PackagePayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      packageId: string
      courseId: string
    }, ExtArgs["result"]["packageCourse"]>
    composites: {}
  }

  type PackageCourseGetPayload<S extends boolean | null | undefined | PackageCourseDefaultArgs> = $Result.GetResult<Prisma.$PackageCoursePayload, S>

  type PackageCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCourseCountAggregateInputType | true
    }

  export interface PackageCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageCourse'], meta: { name: 'PackageCourse' } }
    /**
     * Find zero or one PackageCourse that matches the filter.
     * @param {PackageCourseFindUniqueArgs} args - Arguments to find a PackageCourse
     * @example
     * // Get one PackageCourse
     * const packageCourse = await prisma.packageCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageCourseFindUniqueArgs>(args: SelectSubset<T, PackageCourseFindUniqueArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackageCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageCourseFindUniqueOrThrowArgs} args - Arguments to find a PackageCourse
     * @example
     * // Get one PackageCourse
     * const packageCourse = await prisma.packageCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseFindFirstArgs} args - Arguments to find a PackageCourse
     * @example
     * // Get one PackageCourse
     * const packageCourse = await prisma.packageCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageCourseFindFirstArgs>(args?: SelectSubset<T, PackageCourseFindFirstArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseFindFirstOrThrowArgs} args - Arguments to find a PackageCourse
     * @example
     * // Get one PackageCourse
     * const packageCourse = await prisma.packageCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackageCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageCourses
     * const packageCourses = await prisma.packageCourse.findMany()
     * 
     * // Get first 10 PackageCourses
     * const packageCourses = await prisma.packageCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageCourseWithIdOnly = await prisma.packageCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageCourseFindManyArgs>(args?: SelectSubset<T, PackageCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackageCourse.
     * @param {PackageCourseCreateArgs} args - Arguments to create a PackageCourse.
     * @example
     * // Create one PackageCourse
     * const PackageCourse = await prisma.packageCourse.create({
     *   data: {
     *     // ... data to create a PackageCourse
     *   }
     * })
     * 
     */
    create<T extends PackageCourseCreateArgs>(args: SelectSubset<T, PackageCourseCreateArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackageCourses.
     * @param {PackageCourseCreateManyArgs} args - Arguments to create many PackageCourses.
     * @example
     * // Create many PackageCourses
     * const packageCourse = await prisma.packageCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCourseCreateManyArgs>(args?: SelectSubset<T, PackageCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageCourses and returns the data saved in the database.
     * @param {PackageCourseCreateManyAndReturnArgs} args - Arguments to create many PackageCourses.
     * @example
     * // Create many PackageCourses
     * const packageCourse = await prisma.packageCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageCourses and only return the `id`
     * const packageCourseWithIdOnly = await prisma.packageCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackageCourse.
     * @param {PackageCourseDeleteArgs} args - Arguments to delete one PackageCourse.
     * @example
     * // Delete one PackageCourse
     * const PackageCourse = await prisma.packageCourse.delete({
     *   where: {
     *     // ... filter to delete one PackageCourse
     *   }
     * })
     * 
     */
    delete<T extends PackageCourseDeleteArgs>(args: SelectSubset<T, PackageCourseDeleteArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackageCourse.
     * @param {PackageCourseUpdateArgs} args - Arguments to update one PackageCourse.
     * @example
     * // Update one PackageCourse
     * const packageCourse = await prisma.packageCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageCourseUpdateArgs>(args: SelectSubset<T, PackageCourseUpdateArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackageCourses.
     * @param {PackageCourseDeleteManyArgs} args - Arguments to filter PackageCourses to delete.
     * @example
     * // Delete a few PackageCourses
     * const { count } = await prisma.packageCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageCourseDeleteManyArgs>(args?: SelectSubset<T, PackageCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageCourses
     * const packageCourse = await prisma.packageCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageCourseUpdateManyArgs>(args: SelectSubset<T, PackageCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageCourses and returns the data updated in the database.
     * @param {PackageCourseUpdateManyAndReturnArgs} args - Arguments to update many PackageCourses.
     * @example
     * // Update many PackageCourses
     * const packageCourse = await prisma.packageCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackageCourses and only return the `id`
     * const packageCourseWithIdOnly = await prisma.packageCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackageCourse.
     * @param {PackageCourseUpsertArgs} args - Arguments to update or create a PackageCourse.
     * @example
     * // Update or create a PackageCourse
     * const packageCourse = await prisma.packageCourse.upsert({
     *   create: {
     *     // ... data to create a PackageCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageCourse we want to update
     *   }
     * })
     */
    upsert<T extends PackageCourseUpsertArgs>(args: SelectSubset<T, PackageCourseUpsertArgs<ExtArgs>>): Prisma__PackageCourseClient<$Result.GetResult<Prisma.$PackageCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackageCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseCountArgs} args - Arguments to filter PackageCourses to count.
     * @example
     * // Count the number of PackageCourses
     * const count = await prisma.packageCourse.count({
     *   where: {
     *     // ... the filter for the PackageCourses we want to count
     *   }
     * })
    **/
    count<T extends PackageCourseCountArgs>(
      args?: Subset<T, PackageCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageCourseAggregateArgs>(args: Subset<T, PackageCourseAggregateArgs>): Prisma.PrismaPromise<GetPackageCourseAggregateType<T>>

    /**
     * Group by PackageCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageCourseGroupByArgs['orderBy'] }
        : { orderBy?: PackageCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageCourse model
   */
  readonly fields: PackageCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    package<T extends PackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackageDefaultArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageCourse model
   */
  interface PackageCourseFieldRefs {
    readonly id: FieldRef<"PackageCourse", 'String'>
    readonly packageId: FieldRef<"PackageCourse", 'String'>
    readonly courseId: FieldRef<"PackageCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PackageCourse findUnique
   */
  export type PackageCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * Filter, which PackageCourse to fetch.
     */
    where: PackageCourseWhereUniqueInput
  }

  /**
   * PackageCourse findUniqueOrThrow
   */
  export type PackageCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * Filter, which PackageCourse to fetch.
     */
    where: PackageCourseWhereUniqueInput
  }

  /**
   * PackageCourse findFirst
   */
  export type PackageCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * Filter, which PackageCourse to fetch.
     */
    where?: PackageCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageCourses to fetch.
     */
    orderBy?: PackageCourseOrderByWithRelationInput | PackageCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageCourses.
     */
    cursor?: PackageCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageCourses.
     */
    distinct?: PackageCourseScalarFieldEnum | PackageCourseScalarFieldEnum[]
  }

  /**
   * PackageCourse findFirstOrThrow
   */
  export type PackageCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * Filter, which PackageCourse to fetch.
     */
    where?: PackageCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageCourses to fetch.
     */
    orderBy?: PackageCourseOrderByWithRelationInput | PackageCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageCourses.
     */
    cursor?: PackageCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageCourses.
     */
    distinct?: PackageCourseScalarFieldEnum | PackageCourseScalarFieldEnum[]
  }

  /**
   * PackageCourse findMany
   */
  export type PackageCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * Filter, which PackageCourses to fetch.
     */
    where?: PackageCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageCourses to fetch.
     */
    orderBy?: PackageCourseOrderByWithRelationInput | PackageCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageCourses.
     */
    cursor?: PackageCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageCourses.
     */
    skip?: number
    distinct?: PackageCourseScalarFieldEnum | PackageCourseScalarFieldEnum[]
  }

  /**
   * PackageCourse create
   */
  export type PackageCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a PackageCourse.
     */
    data: XOR<PackageCourseCreateInput, PackageCourseUncheckedCreateInput>
  }

  /**
   * PackageCourse createMany
   */
  export type PackageCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageCourses.
     */
    data: PackageCourseCreateManyInput | PackageCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageCourse createManyAndReturn
   */
  export type PackageCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * The data used to create many PackageCourses.
     */
    data: PackageCourseCreateManyInput | PackageCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageCourse update
   */
  export type PackageCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a PackageCourse.
     */
    data: XOR<PackageCourseUpdateInput, PackageCourseUncheckedUpdateInput>
    /**
     * Choose, which PackageCourse to update.
     */
    where: PackageCourseWhereUniqueInput
  }

  /**
   * PackageCourse updateMany
   */
  export type PackageCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageCourses.
     */
    data: XOR<PackageCourseUpdateManyMutationInput, PackageCourseUncheckedUpdateManyInput>
    /**
     * Filter which PackageCourses to update
     */
    where?: PackageCourseWhereInput
    /**
     * Limit how many PackageCourses to update.
     */
    limit?: number
  }

  /**
   * PackageCourse updateManyAndReturn
   */
  export type PackageCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * The data used to update PackageCourses.
     */
    data: XOR<PackageCourseUpdateManyMutationInput, PackageCourseUncheckedUpdateManyInput>
    /**
     * Filter which PackageCourses to update
     */
    where?: PackageCourseWhereInput
    /**
     * Limit how many PackageCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageCourse upsert
   */
  export type PackageCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the PackageCourse to update in case it exists.
     */
    where: PackageCourseWhereUniqueInput
    /**
     * In case the PackageCourse found by the `where` argument doesn't exist, create a new PackageCourse with this data.
     */
    create: XOR<PackageCourseCreateInput, PackageCourseUncheckedCreateInput>
    /**
     * In case the PackageCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageCourseUpdateInput, PackageCourseUncheckedUpdateInput>
  }

  /**
   * PackageCourse delete
   */
  export type PackageCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
    /**
     * Filter which PackageCourse to delete.
     */
    where: PackageCourseWhereUniqueInput
  }

  /**
   * PackageCourse deleteMany
   */
  export type PackageCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageCourses to delete
     */
    where?: PackageCourseWhereInput
    /**
     * Limit how many PackageCourses to delete.
     */
    limit?: number
  }

  /**
   * PackageCourse without action
   */
  export type PackageCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCourse
     */
    select?: PackageCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageCourse
     */
    omit?: PackageCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageCourseInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    featuredImage: string | null
    series: string | null
    publishDate: Date | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    authorId: string | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    featuredImage: string | null
    series: string | null
    publishDate: Date | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    authorId: string | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    excerpt: number
    content: number
    featuredImage: number
    tags: number
    series: number
    publishDate: number
    status: number
    createdAt: number
    updatedAt: number
    createdById: number
    authorId: number
    _all: number
  }


  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    featuredImage?: true
    series?: true
    publishDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    authorId?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    featuredImage?: true
    series?: true
    publishDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    authorId?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    featuredImage?: true
    tags?: true
    series?: true
    publishDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    authorId?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    slug: string
    excerpt: string | null
    content: string
    featuredImage: string | null
    tags: string[]
    series: string | null
    publishDate: Date | null
    status: $Enums.ContentStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    authorId: string | null
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    featuredImage?: boolean
    tags?: boolean
    series?: boolean
    publishDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    authorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    author?: boolean | BlogPost$authorArgs<ExtArgs>
    seoMeta?: boolean | BlogPost$seoMetaArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    featuredImage?: boolean
    tags?: boolean
    series?: boolean
    publishDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    authorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    featuredImage?: boolean
    tags?: boolean
    series?: boolean
    publishDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    authorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    featuredImage?: boolean
    tags?: boolean
    series?: boolean
    publishDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    authorId?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "excerpt" | "content" | "featuredImage" | "tags" | "series" | "publishDate" | "status" | "createdAt" | "updatedAt" | "createdById" | "authorId", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    author?: boolean | BlogPost$authorArgs<ExtArgs>
    seoMeta?: boolean | BlogPost$seoMetaArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      author: Prisma.$AuthorPayload<ExtArgs> | null
      seoMeta: Prisma.$SeoMetaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      excerpt: string | null
      content: string
      featuredImage: string | null
      tags: string[]
      series: string | null
      publishDate: Date | null
      status: $Enums.ContentStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
      authorId: string | null
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends BlogPost$authorArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$authorArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seoMeta<T extends BlogPost$seoMetaArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$seoMetaArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly featuredImage: FieldRef<"BlogPost", 'String'>
    readonly tags: FieldRef<"BlogPost", 'String[]'>
    readonly series: FieldRef<"BlogPost", 'String'>
    readonly publishDate: FieldRef<"BlogPost", 'DateTime'>
    readonly status: FieldRef<"BlogPost", 'ContentStatus'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdById: FieldRef<"BlogPost", 'String'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost.author
   */
  export type BlogPost$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    where?: AuthorWhereInput
  }

  /**
   * BlogPost.seoMeta
   */
  export type BlogPost$seoMetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    where?: SeoMetaWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    layout: string | null
    content: string | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    layout: string | null
    content: string | null
    status: $Enums.ContentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    layout: number
    content: number
    status: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type PageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    layout?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    layout?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    layout?: true
    content?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    title: string
    slug: string
    layout: string
    content: string
    status: $Enums.ContentStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    layout?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    seoMeta?: boolean | Page$seoMetaArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    layout?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    layout?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    layout?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "layout" | "content" | "status" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["page"]>
  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    seoMeta?: boolean | Page$seoMetaArgs<ExtArgs>
  }
  export type PageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      seoMeta: Prisma.$SeoMetaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      layout: string
      content: string
      status: $Enums.ContentStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seoMeta<T extends Page$seoMetaArgs<ExtArgs> = {}>(args?: Subset<T, Page$seoMetaArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly title: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly layout: FieldRef<"Page", 'String'>
    readonly content: FieldRef<"Page", 'String'>
    readonly status: FieldRef<"Page", 'ContentStatus'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
    readonly createdById: FieldRef<"Page", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page.seoMeta
   */
  export type Page$seoMetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    where?: SeoMetaWhereInput
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
  }


  /**
   * Model Author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorMinAggregateOutputType = {
    id: string | null
    name: string | null
    bio: string | null
    avatar: string | null
    profileUrl: string | null
    userId: string | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    bio: string | null
    avatar: string | null
    profileUrl: string | null
    userId: string | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    name: number
    bio: number
    avatar: number
    socialLinks: number
    profileUrl: number
    userId: number
    _all: number
  }


  export type AuthorMinAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    avatar?: true
    profileUrl?: true
    userId?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    avatar?: true
    profileUrl?: true
    userId?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    name?: true
    bio?: true
    avatar?: true
    socialLinks?: true
    profileUrl?: true
    userId?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Author to aggregate.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type AuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorWhereInput
    orderBy?: AuthorOrderByWithAggregationInput | AuthorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: AuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: string
    name: string
    bio: string | null
    avatar: string | null
    socialLinks: JsonValue | null
    profileUrl: string | null
    userId: string | null
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends AuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type AuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    avatar?: boolean
    socialLinks?: boolean
    profileUrl?: boolean
    userId?: boolean
    user?: boolean | Author$userArgs<ExtArgs>
    blogPosts?: boolean | Author$blogPostsArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    avatar?: boolean
    socialLinks?: boolean
    profileUrl?: boolean
    userId?: boolean
    user?: boolean | Author$userArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bio?: boolean
    avatar?: boolean
    socialLinks?: boolean
    profileUrl?: boolean
    userId?: boolean
    user?: boolean | Author$userArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectScalar = {
    id?: boolean
    name?: boolean
    bio?: boolean
    avatar?: boolean
    socialLinks?: boolean
    profileUrl?: boolean
    userId?: boolean
  }

  export type AuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "bio" | "avatar" | "socialLinks" | "profileUrl" | "userId", ExtArgs["result"]["author"]>
  export type AuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Author$userArgs<ExtArgs>
    blogPosts?: boolean | Author$blogPostsArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Author$userArgs<ExtArgs>
  }
  export type AuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Author$userArgs<ExtArgs>
  }

  export type $AuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Author"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      bio: string | null
      avatar: string | null
      socialLinks: Prisma.JsonValue | null
      profileUrl: string | null
      userId: string | null
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

  type AuthorGetPayload<S extends boolean | null | undefined | AuthorDefaultArgs> = $Result.GetResult<Prisma.$AuthorPayload, S>

  type AuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface AuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Author'], meta: { name: 'Author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorFindUniqueArgs>(args: SelectSubset<T, AuthorFindUniqueArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorFindFirstArgs>(args?: SelectSubset<T, AuthorFindFirstArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorFindManyArgs>(args?: SelectSubset<T, AuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends AuthorCreateArgs>(args: SelectSubset<T, AuthorCreateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {AuthorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorCreateManyArgs>(args?: SelectSubset<T, AuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {AuthorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends AuthorDeleteArgs>(args: SelectSubset<T, AuthorDeleteArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorUpdateArgs>(args: SelectSubset<T, AuthorUpdateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorDeleteManyArgs>(args?: SelectSubset<T, AuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorUpdateManyArgs>(args: SelectSubset<T, AuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {AuthorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends AuthorUpsertArgs>(args: SelectSubset<T, AuthorUpsertArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorGroupByArgs['orderBy'] }
        : { orderBy?: AuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Author model
   */
  readonly fields: AuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Author$userArgs<ExtArgs> = {}>(args?: Subset<T, Author$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    blogPosts<T extends Author$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, Author$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Author model
   */
  interface AuthorFieldRefs {
    readonly id: FieldRef<"Author", 'String'>
    readonly name: FieldRef<"Author", 'String'>
    readonly bio: FieldRef<"Author", 'String'>
    readonly avatar: FieldRef<"Author", 'String'>
    readonly socialLinks: FieldRef<"Author", 'Json'>
    readonly profileUrl: FieldRef<"Author", 'String'>
    readonly userId: FieldRef<"Author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Author findUnique
   */
  export type AuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findUniqueOrThrow
   */
  export type AuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findFirst
   */
  export type AuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findFirstOrThrow
   */
  export type AuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findMany
   */
  export type AuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author create
   */
  export type AuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a Author.
     */
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }

  /**
   * Author createMany
   */
  export type AuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author createManyAndReturn
   */
  export type AuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Author update
   */
  export type AuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a Author.
     */
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author updateManyAndReturn
   */
  export type AuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Author upsert
   */
  export type AuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the Author to update in case it exists.
     */
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
     */
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }

  /**
   * Author delete
   */
  export type AuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter which Author to delete.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Author.user
   */
  export type Author$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Author.blogPosts
   */
  export type Author$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * Author without action
   */
  export type AuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    size: number | null
  }

  export type MediaSumAggregateOutputType = {
    size: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    altText: string | null
    caption: string | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    altText: string | null
    caption: string | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    altText: number
    caption: number
    variants: number
    createdAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    size?: true
  }

  export type MediaSumAggregateInputType = {
    size?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    altText?: true
    caption?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    altText?: true
    caption?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    altText?: true
    caption?: true
    variants?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText: string | null
    caption: string | null
    variants: JsonValue | null
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    caption?: boolean
    variants?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    caption?: boolean
    variants?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    caption?: boolean
    variants?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    altText?: boolean
    caption?: boolean
    variants?: boolean
    createdAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "url" | "altText" | "caption" | "variants" | "createdAt", ExtArgs["result"]["media"]>

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: number
      url: string
      altText: string | null
      caption: string | null
      variants: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly filename: FieldRef<"Media", 'String'>
    readonly originalName: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly size: FieldRef<"Media", 'Int'>
    readonly url: FieldRef<"Media", 'String'>
    readonly altText: FieldRef<"Media", 'String'>
    readonly caption: FieldRef<"Media", 'String'>
    readonly variants: FieldRef<"Media", 'Json'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
  }


  /**
   * Model SeoMeta
   */

  export type AggregateSeoMeta = {
    _count: SeoMetaCountAggregateOutputType | null
    _min: SeoMetaMinAggregateOutputType | null
    _max: SeoMetaMaxAggregateOutputType | null
  }

  export type SeoMetaMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    keywords: string | null
    canonical: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    twitterCard: string | null
    noIndex: boolean | null
    noFollow: boolean | null
    courseId: string | null
    packageId: string | null
    blogPostId: string | null
    pageId: string | null
  }

  export type SeoMetaMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    keywords: string | null
    canonical: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    twitterCard: string | null
    noIndex: boolean | null
    noFollow: boolean | null
    courseId: string | null
    packageId: string | null
    blogPostId: string | null
    pageId: string | null
  }

  export type SeoMetaCountAggregateOutputType = {
    id: number
    title: number
    description: number
    keywords: number
    canonical: number
    ogTitle: number
    ogDescription: number
    ogImage: number
    twitterCard: number
    noIndex: number
    noFollow: number
    courseId: number
    packageId: number
    blogPostId: number
    pageId: number
    _all: number
  }


  export type SeoMetaMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    keywords?: true
    canonical?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    twitterCard?: true
    noIndex?: true
    noFollow?: true
    courseId?: true
    packageId?: true
    blogPostId?: true
    pageId?: true
  }

  export type SeoMetaMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    keywords?: true
    canonical?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    twitterCard?: true
    noIndex?: true
    noFollow?: true
    courseId?: true
    packageId?: true
    blogPostId?: true
    pageId?: true
  }

  export type SeoMetaCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    keywords?: true
    canonical?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    twitterCard?: true
    noIndex?: true
    noFollow?: true
    courseId?: true
    packageId?: true
    blogPostId?: true
    pageId?: true
    _all?: true
  }

  export type SeoMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoMeta to aggregate.
     */
    where?: SeoMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoMetas to fetch.
     */
    orderBy?: SeoMetaOrderByWithRelationInput | SeoMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeoMetas
    **/
    _count?: true | SeoMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoMetaMaxAggregateInputType
  }

  export type GetSeoMetaAggregateType<T extends SeoMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateSeoMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeoMeta[P]>
      : GetScalarType<T[P], AggregateSeoMeta[P]>
  }




  export type SeoMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoMetaWhereInput
    orderBy?: SeoMetaOrderByWithAggregationInput | SeoMetaOrderByWithAggregationInput[]
    by: SeoMetaScalarFieldEnum[] | SeoMetaScalarFieldEnum
    having?: SeoMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoMetaCountAggregateInputType | true
    _min?: SeoMetaMinAggregateInputType
    _max?: SeoMetaMaxAggregateInputType
  }

  export type SeoMetaGroupByOutputType = {
    id: string
    title: string | null
    description: string | null
    keywords: string | null
    canonical: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    twitterCard: string | null
    noIndex: boolean
    noFollow: boolean
    courseId: string | null
    packageId: string | null
    blogPostId: string | null
    pageId: string | null
    _count: SeoMetaCountAggregateOutputType | null
    _min: SeoMetaMinAggregateOutputType | null
    _max: SeoMetaMaxAggregateOutputType | null
  }

  type GetSeoMetaGroupByPayload<T extends SeoMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoMetaGroupByOutputType[P]>
            : GetScalarType<T[P], SeoMetaGroupByOutputType[P]>
        }
      >
    >


  export type SeoMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    canonical?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterCard?: boolean
    noIndex?: boolean
    noFollow?: boolean
    courseId?: boolean
    packageId?: boolean
    blogPostId?: boolean
    pageId?: boolean
    course?: boolean | SeoMeta$courseArgs<ExtArgs>
    package?: boolean | SeoMeta$packageArgs<ExtArgs>
    blogPost?: boolean | SeoMeta$blogPostArgs<ExtArgs>
    page?: boolean | SeoMeta$pageArgs<ExtArgs>
  }, ExtArgs["result"]["seoMeta"]>

  export type SeoMetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    canonical?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterCard?: boolean
    noIndex?: boolean
    noFollow?: boolean
    courseId?: boolean
    packageId?: boolean
    blogPostId?: boolean
    pageId?: boolean
    course?: boolean | SeoMeta$courseArgs<ExtArgs>
    package?: boolean | SeoMeta$packageArgs<ExtArgs>
    blogPost?: boolean | SeoMeta$blogPostArgs<ExtArgs>
    page?: boolean | SeoMeta$pageArgs<ExtArgs>
  }, ExtArgs["result"]["seoMeta"]>

  export type SeoMetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    canonical?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterCard?: boolean
    noIndex?: boolean
    noFollow?: boolean
    courseId?: boolean
    packageId?: boolean
    blogPostId?: boolean
    pageId?: boolean
    course?: boolean | SeoMeta$courseArgs<ExtArgs>
    package?: boolean | SeoMeta$packageArgs<ExtArgs>
    blogPost?: boolean | SeoMeta$blogPostArgs<ExtArgs>
    page?: boolean | SeoMeta$pageArgs<ExtArgs>
  }, ExtArgs["result"]["seoMeta"]>

  export type SeoMetaSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    canonical?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    twitterCard?: boolean
    noIndex?: boolean
    noFollow?: boolean
    courseId?: boolean
    packageId?: boolean
    blogPostId?: boolean
    pageId?: boolean
  }

  export type SeoMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "keywords" | "canonical" | "ogTitle" | "ogDescription" | "ogImage" | "twitterCard" | "noIndex" | "noFollow" | "courseId" | "packageId" | "blogPostId" | "pageId", ExtArgs["result"]["seoMeta"]>
  export type SeoMetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | SeoMeta$courseArgs<ExtArgs>
    package?: boolean | SeoMeta$packageArgs<ExtArgs>
    blogPost?: boolean | SeoMeta$blogPostArgs<ExtArgs>
    page?: boolean | SeoMeta$pageArgs<ExtArgs>
  }
  export type SeoMetaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | SeoMeta$courseArgs<ExtArgs>
    package?: boolean | SeoMeta$packageArgs<ExtArgs>
    blogPost?: boolean | SeoMeta$blogPostArgs<ExtArgs>
    page?: boolean | SeoMeta$pageArgs<ExtArgs>
  }
  export type SeoMetaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | SeoMeta$courseArgs<ExtArgs>
    package?: boolean | SeoMeta$packageArgs<ExtArgs>
    blogPost?: boolean | SeoMeta$blogPostArgs<ExtArgs>
    page?: boolean | SeoMeta$pageArgs<ExtArgs>
  }

  export type $SeoMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeoMeta"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      package: Prisma.$PackagePayload<ExtArgs> | null
      blogPost: Prisma.$BlogPostPayload<ExtArgs> | null
      page: Prisma.$PagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      description: string | null
      keywords: string | null
      canonical: string | null
      ogTitle: string | null
      ogDescription: string | null
      ogImage: string | null
      twitterCard: string | null
      noIndex: boolean
      noFollow: boolean
      courseId: string | null
      packageId: string | null
      blogPostId: string | null
      pageId: string | null
    }, ExtArgs["result"]["seoMeta"]>
    composites: {}
  }

  type SeoMetaGetPayload<S extends boolean | null | undefined | SeoMetaDefaultArgs> = $Result.GetResult<Prisma.$SeoMetaPayload, S>

  type SeoMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoMetaCountAggregateInputType | true
    }

  export interface SeoMetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeoMeta'], meta: { name: 'SeoMeta' } }
    /**
     * Find zero or one SeoMeta that matches the filter.
     * @param {SeoMetaFindUniqueArgs} args - Arguments to find a SeoMeta
     * @example
     * // Get one SeoMeta
     * const seoMeta = await prisma.seoMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoMetaFindUniqueArgs>(args: SelectSubset<T, SeoMetaFindUniqueArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeoMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoMetaFindUniqueOrThrowArgs} args - Arguments to find a SeoMeta
     * @example
     * // Get one SeoMeta
     * const seoMeta = await prisma.seoMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoMetaFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoMetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaFindFirstArgs} args - Arguments to find a SeoMeta
     * @example
     * // Get one SeoMeta
     * const seoMeta = await prisma.seoMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoMetaFindFirstArgs>(args?: SelectSubset<T, SeoMetaFindFirstArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaFindFirstOrThrowArgs} args - Arguments to find a SeoMeta
     * @example
     * // Get one SeoMeta
     * const seoMeta = await prisma.seoMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoMetaFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoMetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeoMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeoMetas
     * const seoMetas = await prisma.seoMeta.findMany()
     * 
     * // Get first 10 SeoMetas
     * const seoMetas = await prisma.seoMeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoMetaWithIdOnly = await prisma.seoMeta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoMetaFindManyArgs>(args?: SelectSubset<T, SeoMetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeoMeta.
     * @param {SeoMetaCreateArgs} args - Arguments to create a SeoMeta.
     * @example
     * // Create one SeoMeta
     * const SeoMeta = await prisma.seoMeta.create({
     *   data: {
     *     // ... data to create a SeoMeta
     *   }
     * })
     * 
     */
    create<T extends SeoMetaCreateArgs>(args: SelectSubset<T, SeoMetaCreateArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeoMetas.
     * @param {SeoMetaCreateManyArgs} args - Arguments to create many SeoMetas.
     * @example
     * // Create many SeoMetas
     * const seoMeta = await prisma.seoMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoMetaCreateManyArgs>(args?: SelectSubset<T, SeoMetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeoMetas and returns the data saved in the database.
     * @param {SeoMetaCreateManyAndReturnArgs} args - Arguments to create many SeoMetas.
     * @example
     * // Create many SeoMetas
     * const seoMeta = await prisma.seoMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeoMetas and only return the `id`
     * const seoMetaWithIdOnly = await prisma.seoMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeoMetaCreateManyAndReturnArgs>(args?: SelectSubset<T, SeoMetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeoMeta.
     * @param {SeoMetaDeleteArgs} args - Arguments to delete one SeoMeta.
     * @example
     * // Delete one SeoMeta
     * const SeoMeta = await prisma.seoMeta.delete({
     *   where: {
     *     // ... filter to delete one SeoMeta
     *   }
     * })
     * 
     */
    delete<T extends SeoMetaDeleteArgs>(args: SelectSubset<T, SeoMetaDeleteArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeoMeta.
     * @param {SeoMetaUpdateArgs} args - Arguments to update one SeoMeta.
     * @example
     * // Update one SeoMeta
     * const seoMeta = await prisma.seoMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoMetaUpdateArgs>(args: SelectSubset<T, SeoMetaUpdateArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeoMetas.
     * @param {SeoMetaDeleteManyArgs} args - Arguments to filter SeoMetas to delete.
     * @example
     * // Delete a few SeoMetas
     * const { count } = await prisma.seoMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoMetaDeleteManyArgs>(args?: SelectSubset<T, SeoMetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeoMetas
     * const seoMeta = await prisma.seoMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoMetaUpdateManyArgs>(args: SelectSubset<T, SeoMetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoMetas and returns the data updated in the database.
     * @param {SeoMetaUpdateManyAndReturnArgs} args - Arguments to update many SeoMetas.
     * @example
     * // Update many SeoMetas
     * const seoMeta = await prisma.seoMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeoMetas and only return the `id`
     * const seoMetaWithIdOnly = await prisma.seoMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeoMetaUpdateManyAndReturnArgs>(args: SelectSubset<T, SeoMetaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeoMeta.
     * @param {SeoMetaUpsertArgs} args - Arguments to update or create a SeoMeta.
     * @example
     * // Update or create a SeoMeta
     * const seoMeta = await prisma.seoMeta.upsert({
     *   create: {
     *     // ... data to create a SeoMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeoMeta we want to update
     *   }
     * })
     */
    upsert<T extends SeoMetaUpsertArgs>(args: SelectSubset<T, SeoMetaUpsertArgs<ExtArgs>>): Prisma__SeoMetaClient<$Result.GetResult<Prisma.$SeoMetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeoMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaCountArgs} args - Arguments to filter SeoMetas to count.
     * @example
     * // Count the number of SeoMetas
     * const count = await prisma.seoMeta.count({
     *   where: {
     *     // ... the filter for the SeoMetas we want to count
     *   }
     * })
    **/
    count<T extends SeoMetaCountArgs>(
      args?: Subset<T, SeoMetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeoMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoMetaAggregateArgs>(args: Subset<T, SeoMetaAggregateArgs>): Prisma.PrismaPromise<GetSeoMetaAggregateType<T>>

    /**
     * Group by SeoMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoMetaGroupByArgs['orderBy'] }
        : { orderBy?: SeoMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeoMeta model
   */
  readonly fields: SeoMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeoMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoMetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends SeoMeta$courseArgs<ExtArgs> = {}>(args?: Subset<T, SeoMeta$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    package<T extends SeoMeta$packageArgs<ExtArgs> = {}>(args?: Subset<T, SeoMeta$packageArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    blogPost<T extends SeoMeta$blogPostArgs<ExtArgs> = {}>(args?: Subset<T, SeoMeta$blogPostArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    page<T extends SeoMeta$pageArgs<ExtArgs> = {}>(args?: Subset<T, SeoMeta$pageArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeoMeta model
   */
  interface SeoMetaFieldRefs {
    readonly id: FieldRef<"SeoMeta", 'String'>
    readonly title: FieldRef<"SeoMeta", 'String'>
    readonly description: FieldRef<"SeoMeta", 'String'>
    readonly keywords: FieldRef<"SeoMeta", 'String'>
    readonly canonical: FieldRef<"SeoMeta", 'String'>
    readonly ogTitle: FieldRef<"SeoMeta", 'String'>
    readonly ogDescription: FieldRef<"SeoMeta", 'String'>
    readonly ogImage: FieldRef<"SeoMeta", 'String'>
    readonly twitterCard: FieldRef<"SeoMeta", 'String'>
    readonly noIndex: FieldRef<"SeoMeta", 'Boolean'>
    readonly noFollow: FieldRef<"SeoMeta", 'Boolean'>
    readonly courseId: FieldRef<"SeoMeta", 'String'>
    readonly packageId: FieldRef<"SeoMeta", 'String'>
    readonly blogPostId: FieldRef<"SeoMeta", 'String'>
    readonly pageId: FieldRef<"SeoMeta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeoMeta findUnique
   */
  export type SeoMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * Filter, which SeoMeta to fetch.
     */
    where: SeoMetaWhereUniqueInput
  }

  /**
   * SeoMeta findUniqueOrThrow
   */
  export type SeoMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * Filter, which SeoMeta to fetch.
     */
    where: SeoMetaWhereUniqueInput
  }

  /**
   * SeoMeta findFirst
   */
  export type SeoMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * Filter, which SeoMeta to fetch.
     */
    where?: SeoMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoMetas to fetch.
     */
    orderBy?: SeoMetaOrderByWithRelationInput | SeoMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoMetas.
     */
    cursor?: SeoMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoMetas.
     */
    distinct?: SeoMetaScalarFieldEnum | SeoMetaScalarFieldEnum[]
  }

  /**
   * SeoMeta findFirstOrThrow
   */
  export type SeoMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * Filter, which SeoMeta to fetch.
     */
    where?: SeoMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoMetas to fetch.
     */
    orderBy?: SeoMetaOrderByWithRelationInput | SeoMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoMetas.
     */
    cursor?: SeoMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoMetas.
     */
    distinct?: SeoMetaScalarFieldEnum | SeoMetaScalarFieldEnum[]
  }

  /**
   * SeoMeta findMany
   */
  export type SeoMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * Filter, which SeoMetas to fetch.
     */
    where?: SeoMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoMetas to fetch.
     */
    orderBy?: SeoMetaOrderByWithRelationInput | SeoMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeoMetas.
     */
    cursor?: SeoMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoMetas.
     */
    skip?: number
    distinct?: SeoMetaScalarFieldEnum | SeoMetaScalarFieldEnum[]
  }

  /**
   * SeoMeta create
   */
  export type SeoMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a SeoMeta.
     */
    data?: XOR<SeoMetaCreateInput, SeoMetaUncheckedCreateInput>
  }

  /**
   * SeoMeta createMany
   */
  export type SeoMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeoMetas.
     */
    data: SeoMetaCreateManyInput | SeoMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeoMeta createManyAndReturn
   */
  export type SeoMetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * The data used to create many SeoMetas.
     */
    data: SeoMetaCreateManyInput | SeoMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeoMeta update
   */
  export type SeoMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a SeoMeta.
     */
    data: XOR<SeoMetaUpdateInput, SeoMetaUncheckedUpdateInput>
    /**
     * Choose, which SeoMeta to update.
     */
    where: SeoMetaWhereUniqueInput
  }

  /**
   * SeoMeta updateMany
   */
  export type SeoMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeoMetas.
     */
    data: XOR<SeoMetaUpdateManyMutationInput, SeoMetaUncheckedUpdateManyInput>
    /**
     * Filter which SeoMetas to update
     */
    where?: SeoMetaWhereInput
    /**
     * Limit how many SeoMetas to update.
     */
    limit?: number
  }

  /**
   * SeoMeta updateManyAndReturn
   */
  export type SeoMetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * The data used to update SeoMetas.
     */
    data: XOR<SeoMetaUpdateManyMutationInput, SeoMetaUncheckedUpdateManyInput>
    /**
     * Filter which SeoMetas to update
     */
    where?: SeoMetaWhereInput
    /**
     * Limit how many SeoMetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeoMeta upsert
   */
  export type SeoMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the SeoMeta to update in case it exists.
     */
    where: SeoMetaWhereUniqueInput
    /**
     * In case the SeoMeta found by the `where` argument doesn't exist, create a new SeoMeta with this data.
     */
    create: XOR<SeoMetaCreateInput, SeoMetaUncheckedCreateInput>
    /**
     * In case the SeoMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoMetaUpdateInput, SeoMetaUncheckedUpdateInput>
  }

  /**
   * SeoMeta delete
   */
  export type SeoMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
    /**
     * Filter which SeoMeta to delete.
     */
    where: SeoMetaWhereUniqueInput
  }

  /**
   * SeoMeta deleteMany
   */
  export type SeoMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoMetas to delete
     */
    where?: SeoMetaWhereInput
    /**
     * Limit how many SeoMetas to delete.
     */
    limit?: number
  }

  /**
   * SeoMeta.course
   */
  export type SeoMeta$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * SeoMeta.package
   */
  export type SeoMeta$packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
  }

  /**
   * SeoMeta.blogPost
   */
  export type SeoMeta$blogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
  }

  /**
   * SeoMeta.page
   */
  export type SeoMeta$pageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }

  /**
   * SeoMeta without action
   */
  export type SeoMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoMeta
     */
    select?: SeoMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoMeta
     */
    omit?: SeoMetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoMetaInclude<ExtArgs> | null
  }


  /**
   * Model Revision
   */

  export type AggregateRevision = {
    _count: RevisionCountAggregateOutputType | null
    _avg: RevisionAvgAggregateOutputType | null
    _sum: RevisionSumAggregateOutputType | null
    _min: RevisionMinAggregateOutputType | null
    _max: RevisionMaxAggregateOutputType | null
  }

  export type RevisionAvgAggregateOutputType = {
    version: number | null
  }

  export type RevisionSumAggregateOutputType = {
    version: number | null
  }

  export type RevisionMinAggregateOutputType = {
    id: string | null
    contentType: $Enums.ContentType | null
    contentId: string | null
    version: number | null
    status: $Enums.RevisionStatus | null
    previewToken: string | null
    previewExpiresAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    createdById: string | null
    reviewedById: string | null
    publishedById: string | null
    reviewNotes: string | null
  }

  export type RevisionMaxAggregateOutputType = {
    id: string | null
    contentType: $Enums.ContentType | null
    contentId: string | null
    version: number | null
    status: $Enums.RevisionStatus | null
    previewToken: string | null
    previewExpiresAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    createdById: string | null
    reviewedById: string | null
    publishedById: string | null
    reviewNotes: string | null
  }

  export type RevisionCountAggregateOutputType = {
    id: number
    contentType: number
    contentId: number
    version: number
    data: number
    status: number
    previewToken: number
    previewExpiresAt: number
    publishedAt: number
    createdAt: number
    createdById: number
    reviewedById: number
    publishedById: number
    reviewNotes: number
    _all: number
  }


  export type RevisionAvgAggregateInputType = {
    version?: true
  }

  export type RevisionSumAggregateInputType = {
    version?: true
  }

  export type RevisionMinAggregateInputType = {
    id?: true
    contentType?: true
    contentId?: true
    version?: true
    status?: true
    previewToken?: true
    previewExpiresAt?: true
    publishedAt?: true
    createdAt?: true
    createdById?: true
    reviewedById?: true
    publishedById?: true
    reviewNotes?: true
  }

  export type RevisionMaxAggregateInputType = {
    id?: true
    contentType?: true
    contentId?: true
    version?: true
    status?: true
    previewToken?: true
    previewExpiresAt?: true
    publishedAt?: true
    createdAt?: true
    createdById?: true
    reviewedById?: true
    publishedById?: true
    reviewNotes?: true
  }

  export type RevisionCountAggregateInputType = {
    id?: true
    contentType?: true
    contentId?: true
    version?: true
    data?: true
    status?: true
    previewToken?: true
    previewExpiresAt?: true
    publishedAt?: true
    createdAt?: true
    createdById?: true
    reviewedById?: true
    publishedById?: true
    reviewNotes?: true
    _all?: true
  }

  export type RevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Revision to aggregate.
     */
    where?: RevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revisions to fetch.
     */
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Revisions
    **/
    _count?: true | RevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevisionMaxAggregateInputType
  }

  export type GetRevisionAggregateType<T extends RevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevision[P]>
      : GetScalarType<T[P], AggregateRevision[P]>
  }




  export type RevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevisionWhereInput
    orderBy?: RevisionOrderByWithAggregationInput | RevisionOrderByWithAggregationInput[]
    by: RevisionScalarFieldEnum[] | RevisionScalarFieldEnum
    having?: RevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevisionCountAggregateInputType | true
    _avg?: RevisionAvgAggregateInputType
    _sum?: RevisionSumAggregateInputType
    _min?: RevisionMinAggregateInputType
    _max?: RevisionMaxAggregateInputType
  }

  export type RevisionGroupByOutputType = {
    id: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonValue
    status: $Enums.RevisionStatus
    previewToken: string | null
    previewExpiresAt: Date | null
    publishedAt: Date | null
    createdAt: Date
    createdById: string
    reviewedById: string | null
    publishedById: string | null
    reviewNotes: string | null
    _count: RevisionCountAggregateOutputType | null
    _avg: RevisionAvgAggregateOutputType | null
    _sum: RevisionSumAggregateOutputType | null
    _min: RevisionMinAggregateOutputType | null
    _max: RevisionMaxAggregateOutputType | null
  }

  type GetRevisionGroupByPayload<T extends RevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevisionGroupByOutputType[P]>
            : GetScalarType<T[P], RevisionGroupByOutputType[P]>
        }
      >
    >


  export type RevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    status?: boolean
    previewToken?: boolean
    previewExpiresAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    reviewedById?: boolean
    publishedById?: boolean
    reviewNotes?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | Revision$reviewerArgs<ExtArgs>
    publisher?: boolean | Revision$publisherArgs<ExtArgs>
  }, ExtArgs["result"]["revision"]>

  export type RevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    status?: boolean
    previewToken?: boolean
    previewExpiresAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    reviewedById?: boolean
    publishedById?: boolean
    reviewNotes?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | Revision$reviewerArgs<ExtArgs>
    publisher?: boolean | Revision$publisherArgs<ExtArgs>
  }, ExtArgs["result"]["revision"]>

  export type RevisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    status?: boolean
    previewToken?: boolean
    previewExpiresAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    reviewedById?: boolean
    publishedById?: boolean
    reviewNotes?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | Revision$reviewerArgs<ExtArgs>
    publisher?: boolean | Revision$publisherArgs<ExtArgs>
  }, ExtArgs["result"]["revision"]>

  export type RevisionSelectScalar = {
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    version?: boolean
    data?: boolean
    status?: boolean
    previewToken?: boolean
    previewExpiresAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    reviewedById?: boolean
    publishedById?: boolean
    reviewNotes?: boolean
  }

  export type RevisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentType" | "contentId" | "version" | "data" | "status" | "previewToken" | "previewExpiresAt" | "publishedAt" | "createdAt" | "createdById" | "reviewedById" | "publishedById" | "reviewNotes", ExtArgs["result"]["revision"]>
  export type RevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | Revision$reviewerArgs<ExtArgs>
    publisher?: boolean | Revision$publisherArgs<ExtArgs>
  }
  export type RevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | Revision$reviewerArgs<ExtArgs>
    publisher?: boolean | Revision$publisherArgs<ExtArgs>
  }
  export type RevisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | Revision$reviewerArgs<ExtArgs>
    publisher?: boolean | Revision$publisherArgs<ExtArgs>
  }

  export type $RevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Revision"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
      publisher: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentType: $Enums.ContentType
      contentId: string
      version: number
      data: Prisma.JsonValue
      status: $Enums.RevisionStatus
      previewToken: string | null
      previewExpiresAt: Date | null
      publishedAt: Date | null
      createdAt: Date
      createdById: string
      reviewedById: string | null
      publishedById: string | null
      reviewNotes: string | null
    }, ExtArgs["result"]["revision"]>
    composites: {}
  }

  type RevisionGetPayload<S extends boolean | null | undefined | RevisionDefaultArgs> = $Result.GetResult<Prisma.$RevisionPayload, S>

  type RevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RevisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RevisionCountAggregateInputType | true
    }

  export interface RevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Revision'], meta: { name: 'Revision' } }
    /**
     * Find zero or one Revision that matches the filter.
     * @param {RevisionFindUniqueArgs} args - Arguments to find a Revision
     * @example
     * // Get one Revision
     * const revision = await prisma.revision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevisionFindUniqueArgs>(args: SelectSubset<T, RevisionFindUniqueArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Revision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RevisionFindUniqueOrThrowArgs} args - Arguments to find a Revision
     * @example
     * // Get one Revision
     * const revision = await prisma.revision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, RevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Revision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionFindFirstArgs} args - Arguments to find a Revision
     * @example
     * // Get one Revision
     * const revision = await prisma.revision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevisionFindFirstArgs>(args?: SelectSubset<T, RevisionFindFirstArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Revision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionFindFirstOrThrowArgs} args - Arguments to find a Revision
     * @example
     * // Get one Revision
     * const revision = await prisma.revision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, RevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Revisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Revisions
     * const revisions = await prisma.revision.findMany()
     * 
     * // Get first 10 Revisions
     * const revisions = await prisma.revision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revisionWithIdOnly = await prisma.revision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevisionFindManyArgs>(args?: SelectSubset<T, RevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Revision.
     * @param {RevisionCreateArgs} args - Arguments to create a Revision.
     * @example
     * // Create one Revision
     * const Revision = await prisma.revision.create({
     *   data: {
     *     // ... data to create a Revision
     *   }
     * })
     * 
     */
    create<T extends RevisionCreateArgs>(args: SelectSubset<T, RevisionCreateArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Revisions.
     * @param {RevisionCreateManyArgs} args - Arguments to create many Revisions.
     * @example
     * // Create many Revisions
     * const revision = await prisma.revision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevisionCreateManyArgs>(args?: SelectSubset<T, RevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Revisions and returns the data saved in the database.
     * @param {RevisionCreateManyAndReturnArgs} args - Arguments to create many Revisions.
     * @example
     * // Create many Revisions
     * const revision = await prisma.revision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Revisions and only return the `id`
     * const revisionWithIdOnly = await prisma.revision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, RevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Revision.
     * @param {RevisionDeleteArgs} args - Arguments to delete one Revision.
     * @example
     * // Delete one Revision
     * const Revision = await prisma.revision.delete({
     *   where: {
     *     // ... filter to delete one Revision
     *   }
     * })
     * 
     */
    delete<T extends RevisionDeleteArgs>(args: SelectSubset<T, RevisionDeleteArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Revision.
     * @param {RevisionUpdateArgs} args - Arguments to update one Revision.
     * @example
     * // Update one Revision
     * const revision = await prisma.revision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevisionUpdateArgs>(args: SelectSubset<T, RevisionUpdateArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Revisions.
     * @param {RevisionDeleteManyArgs} args - Arguments to filter Revisions to delete.
     * @example
     * // Delete a few Revisions
     * const { count } = await prisma.revision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevisionDeleteManyArgs>(args?: SelectSubset<T, RevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Revisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Revisions
     * const revision = await prisma.revision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevisionUpdateManyArgs>(args: SelectSubset<T, RevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Revisions and returns the data updated in the database.
     * @param {RevisionUpdateManyAndReturnArgs} args - Arguments to update many Revisions.
     * @example
     * // Update many Revisions
     * const revision = await prisma.revision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Revisions and only return the `id`
     * const revisionWithIdOnly = await prisma.revision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RevisionUpdateManyAndReturnArgs>(args: SelectSubset<T, RevisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Revision.
     * @param {RevisionUpsertArgs} args - Arguments to update or create a Revision.
     * @example
     * // Update or create a Revision
     * const revision = await prisma.revision.upsert({
     *   create: {
     *     // ... data to create a Revision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Revision we want to update
     *   }
     * })
     */
    upsert<T extends RevisionUpsertArgs>(args: SelectSubset<T, RevisionUpsertArgs<ExtArgs>>): Prisma__RevisionClient<$Result.GetResult<Prisma.$RevisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Revisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionCountArgs} args - Arguments to filter Revisions to count.
     * @example
     * // Count the number of Revisions
     * const count = await prisma.revision.count({
     *   where: {
     *     // ... the filter for the Revisions we want to count
     *   }
     * })
    **/
    count<T extends RevisionCountArgs>(
      args?: Subset<T, RevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Revision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevisionAggregateArgs>(args: Subset<T, RevisionAggregateArgs>): Prisma.PrismaPromise<GetRevisionAggregateType<T>>

    /**
     * Group by Revision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevisionGroupByArgs['orderBy'] }
        : { orderBy?: RevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Revision model
   */
  readonly fields: RevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Revision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends Revision$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, Revision$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    publisher<T extends Revision$publisherArgs<ExtArgs> = {}>(args?: Subset<T, Revision$publisherArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Revision model
   */
  interface RevisionFieldRefs {
    readonly id: FieldRef<"Revision", 'String'>
    readonly contentType: FieldRef<"Revision", 'ContentType'>
    readonly contentId: FieldRef<"Revision", 'String'>
    readonly version: FieldRef<"Revision", 'Int'>
    readonly data: FieldRef<"Revision", 'Json'>
    readonly status: FieldRef<"Revision", 'RevisionStatus'>
    readonly previewToken: FieldRef<"Revision", 'String'>
    readonly previewExpiresAt: FieldRef<"Revision", 'DateTime'>
    readonly publishedAt: FieldRef<"Revision", 'DateTime'>
    readonly createdAt: FieldRef<"Revision", 'DateTime'>
    readonly createdById: FieldRef<"Revision", 'String'>
    readonly reviewedById: FieldRef<"Revision", 'String'>
    readonly publishedById: FieldRef<"Revision", 'String'>
    readonly reviewNotes: FieldRef<"Revision", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Revision findUnique
   */
  export type RevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * Filter, which Revision to fetch.
     */
    where: RevisionWhereUniqueInput
  }

  /**
   * Revision findUniqueOrThrow
   */
  export type RevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * Filter, which Revision to fetch.
     */
    where: RevisionWhereUniqueInput
  }

  /**
   * Revision findFirst
   */
  export type RevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * Filter, which Revision to fetch.
     */
    where?: RevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revisions to fetch.
     */
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Revisions.
     */
    cursor?: RevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Revisions.
     */
    distinct?: RevisionScalarFieldEnum | RevisionScalarFieldEnum[]
  }

  /**
   * Revision findFirstOrThrow
   */
  export type RevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * Filter, which Revision to fetch.
     */
    where?: RevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revisions to fetch.
     */
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Revisions.
     */
    cursor?: RevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Revisions.
     */
    distinct?: RevisionScalarFieldEnum | RevisionScalarFieldEnum[]
  }

  /**
   * Revision findMany
   */
  export type RevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * Filter, which Revisions to fetch.
     */
    where?: RevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revisions to fetch.
     */
    orderBy?: RevisionOrderByWithRelationInput | RevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Revisions.
     */
    cursor?: RevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revisions.
     */
    skip?: number
    distinct?: RevisionScalarFieldEnum | RevisionScalarFieldEnum[]
  }

  /**
   * Revision create
   */
  export type RevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Revision.
     */
    data: XOR<RevisionCreateInput, RevisionUncheckedCreateInput>
  }

  /**
   * Revision createMany
   */
  export type RevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Revisions.
     */
    data: RevisionCreateManyInput | RevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Revision createManyAndReturn
   */
  export type RevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * The data used to create many Revisions.
     */
    data: RevisionCreateManyInput | RevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Revision update
   */
  export type RevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Revision.
     */
    data: XOR<RevisionUpdateInput, RevisionUncheckedUpdateInput>
    /**
     * Choose, which Revision to update.
     */
    where: RevisionWhereUniqueInput
  }

  /**
   * Revision updateMany
   */
  export type RevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Revisions.
     */
    data: XOR<RevisionUpdateManyMutationInput, RevisionUncheckedUpdateManyInput>
    /**
     * Filter which Revisions to update
     */
    where?: RevisionWhereInput
    /**
     * Limit how many Revisions to update.
     */
    limit?: number
  }

  /**
   * Revision updateManyAndReturn
   */
  export type RevisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * The data used to update Revisions.
     */
    data: XOR<RevisionUpdateManyMutationInput, RevisionUncheckedUpdateManyInput>
    /**
     * Filter which Revisions to update
     */
    where?: RevisionWhereInput
    /**
     * Limit how many Revisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Revision upsert
   */
  export type RevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Revision to update in case it exists.
     */
    where: RevisionWhereUniqueInput
    /**
     * In case the Revision found by the `where` argument doesn't exist, create a new Revision with this data.
     */
    create: XOR<RevisionCreateInput, RevisionUncheckedCreateInput>
    /**
     * In case the Revision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevisionUpdateInput, RevisionUncheckedUpdateInput>
  }

  /**
   * Revision delete
   */
  export type RevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
    /**
     * Filter which Revision to delete.
     */
    where: RevisionWhereUniqueInput
  }

  /**
   * Revision deleteMany
   */
  export type RevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Revisions to delete
     */
    where?: RevisionWhereInput
    /**
     * Limit how many Revisions to delete.
     */
    limit?: number
  }

  /**
   * Revision.reviewer
   */
  export type Revision$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Revision.publisher
   */
  export type Revision$publisherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Revision without action
   */
  export type RevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revision
     */
    select?: RevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revision
     */
    omit?: RevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevisionInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    data: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    data?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    data: JsonValue
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    data?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "data" | "updatedAt", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly data: FieldRef<"Settings", 'Json'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model Snippet
   */

  export type AggregateSnippet = {
    _count: SnippetCountAggregateOutputType | null
    _min: SnippetMinAggregateOutputType | null
    _max: SnippetMaxAggregateOutputType | null
  }

  export type SnippetMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SnippetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SnippetCountAggregateOutputType = {
    id: number
    name: number
    type: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SnippetMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SnippetMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SnippetCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SnippetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snippet to aggregate.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Snippets
    **/
    _count?: true | SnippetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnippetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnippetMaxAggregateInputType
  }

  export type GetSnippetAggregateType<T extends SnippetAggregateArgs> = {
        [P in keyof T & keyof AggregateSnippet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnippet[P]>
      : GetScalarType<T[P], AggregateSnippet[P]>
  }




  export type SnippetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnippetWhereInput
    orderBy?: SnippetOrderByWithAggregationInput | SnippetOrderByWithAggregationInput[]
    by: SnippetScalarFieldEnum[] | SnippetScalarFieldEnum
    having?: SnippetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnippetCountAggregateInputType | true
    _min?: SnippetMinAggregateInputType
    _max?: SnippetMaxAggregateInputType
  }

  export type SnippetGroupByOutputType = {
    id: string
    name: string
    type: string
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SnippetCountAggregateOutputType | null
    _min: SnippetMinAggregateOutputType | null
    _max: SnippetMaxAggregateOutputType | null
  }

  type GetSnippetGroupByPayload<T extends SnippetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnippetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnippetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnippetGroupByOutputType[P]>
            : GetScalarType<T[P], SnippetGroupByOutputType[P]>
        }
      >
    >


  export type SnippetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SnippetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["snippet"]>

  export type $SnippetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Snippet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["snippet"]>
    composites: {}
  }

  type SnippetGetPayload<S extends boolean | null | undefined | SnippetDefaultArgs> = $Result.GetResult<Prisma.$SnippetPayload, S>

  type SnippetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SnippetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SnippetCountAggregateInputType | true
    }

  export interface SnippetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Snippet'], meta: { name: 'Snippet' } }
    /**
     * Find zero or one Snippet that matches the filter.
     * @param {SnippetFindUniqueArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnippetFindUniqueArgs>(args: SelectSubset<T, SnippetFindUniqueArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Snippet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SnippetFindUniqueOrThrowArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnippetFindUniqueOrThrowArgs>(args: SelectSubset<T, SnippetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Snippet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindFirstArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnippetFindFirstArgs>(args?: SelectSubset<T, SnippetFindFirstArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Snippet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindFirstOrThrowArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnippetFindFirstOrThrowArgs>(args?: SelectSubset<T, SnippetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Snippets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snippets
     * const snippets = await prisma.snippet.findMany()
     * 
     * // Get first 10 Snippets
     * const snippets = await prisma.snippet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const snippetWithIdOnly = await prisma.snippet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SnippetFindManyArgs>(args?: SelectSubset<T, SnippetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Snippet.
     * @param {SnippetCreateArgs} args - Arguments to create a Snippet.
     * @example
     * // Create one Snippet
     * const Snippet = await prisma.snippet.create({
     *   data: {
     *     // ... data to create a Snippet
     *   }
     * })
     * 
     */
    create<T extends SnippetCreateArgs>(args: SelectSubset<T, SnippetCreateArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Snippets.
     * @param {SnippetCreateManyArgs} args - Arguments to create many Snippets.
     * @example
     * // Create many Snippets
     * const snippet = await prisma.snippet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnippetCreateManyArgs>(args?: SelectSubset<T, SnippetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Snippets and returns the data saved in the database.
     * @param {SnippetCreateManyAndReturnArgs} args - Arguments to create many Snippets.
     * @example
     * // Create many Snippets
     * const snippet = await prisma.snippet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Snippets and only return the `id`
     * const snippetWithIdOnly = await prisma.snippet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnippetCreateManyAndReturnArgs>(args?: SelectSubset<T, SnippetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Snippet.
     * @param {SnippetDeleteArgs} args - Arguments to delete one Snippet.
     * @example
     * // Delete one Snippet
     * const Snippet = await prisma.snippet.delete({
     *   where: {
     *     // ... filter to delete one Snippet
     *   }
     * })
     * 
     */
    delete<T extends SnippetDeleteArgs>(args: SelectSubset<T, SnippetDeleteArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Snippet.
     * @param {SnippetUpdateArgs} args - Arguments to update one Snippet.
     * @example
     * // Update one Snippet
     * const snippet = await prisma.snippet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnippetUpdateArgs>(args: SelectSubset<T, SnippetUpdateArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Snippets.
     * @param {SnippetDeleteManyArgs} args - Arguments to filter Snippets to delete.
     * @example
     * // Delete a few Snippets
     * const { count } = await prisma.snippet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnippetDeleteManyArgs>(args?: SelectSubset<T, SnippetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snippets
     * const snippet = await prisma.snippet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnippetUpdateManyArgs>(args: SelectSubset<T, SnippetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snippets and returns the data updated in the database.
     * @param {SnippetUpdateManyAndReturnArgs} args - Arguments to update many Snippets.
     * @example
     * // Update many Snippets
     * const snippet = await prisma.snippet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Snippets and only return the `id`
     * const snippetWithIdOnly = await prisma.snippet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SnippetUpdateManyAndReturnArgs>(args: SelectSubset<T, SnippetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Snippet.
     * @param {SnippetUpsertArgs} args - Arguments to update or create a Snippet.
     * @example
     * // Update or create a Snippet
     * const snippet = await prisma.snippet.upsert({
     *   create: {
     *     // ... data to create a Snippet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snippet we want to update
     *   }
     * })
     */
    upsert<T extends SnippetUpsertArgs>(args: SelectSubset<T, SnippetUpsertArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Snippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetCountArgs} args - Arguments to filter Snippets to count.
     * @example
     * // Count the number of Snippets
     * const count = await prisma.snippet.count({
     *   where: {
     *     // ... the filter for the Snippets we want to count
     *   }
     * })
    **/
    count<T extends SnippetCountArgs>(
      args?: Subset<T, SnippetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnippetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnippetAggregateArgs>(args: Subset<T, SnippetAggregateArgs>): Prisma.PrismaPromise<GetSnippetAggregateType<T>>

    /**
     * Group by Snippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnippetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnippetGroupByArgs['orderBy'] }
        : { orderBy?: SnippetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnippetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnippetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Snippet model
   */
  readonly fields: SnippetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Snippet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnippetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Snippet model
   */
  interface SnippetFieldRefs {
    readonly id: FieldRef<"Snippet", 'String'>
    readonly name: FieldRef<"Snippet", 'String'>
    readonly type: FieldRef<"Snippet", 'String'>
    readonly content: FieldRef<"Snippet", 'Json'>
    readonly createdAt: FieldRef<"Snippet", 'DateTime'>
    readonly updatedAt: FieldRef<"Snippet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Snippet findUnique
   */
  export type SnippetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet findUniqueOrThrow
   */
  export type SnippetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet findFirst
   */
  export type SnippetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snippets.
     */
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet findFirstOrThrow
   */
  export type SnippetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snippets.
     */
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet findMany
   */
  export type SnippetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Filter, which Snippets to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet create
   */
  export type SnippetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The data needed to create a Snippet.
     */
    data: XOR<SnippetCreateInput, SnippetUncheckedCreateInput>
  }

  /**
   * Snippet createMany
   */
  export type SnippetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Snippets.
     */
    data: SnippetCreateManyInput | SnippetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snippet createManyAndReturn
   */
  export type SnippetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The data used to create many Snippets.
     */
    data: SnippetCreateManyInput | SnippetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snippet update
   */
  export type SnippetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The data needed to update a Snippet.
     */
    data: XOR<SnippetUpdateInput, SnippetUncheckedUpdateInput>
    /**
     * Choose, which Snippet to update.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet updateMany
   */
  export type SnippetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Snippets.
     */
    data: XOR<SnippetUpdateManyMutationInput, SnippetUncheckedUpdateManyInput>
    /**
     * Filter which Snippets to update
     */
    where?: SnippetWhereInput
    /**
     * Limit how many Snippets to update.
     */
    limit?: number
  }

  /**
   * Snippet updateManyAndReturn
   */
  export type SnippetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The data used to update Snippets.
     */
    data: XOR<SnippetUpdateManyMutationInput, SnippetUncheckedUpdateManyInput>
    /**
     * Filter which Snippets to update
     */
    where?: SnippetWhereInput
    /**
     * Limit how many Snippets to update.
     */
    limit?: number
  }

  /**
   * Snippet upsert
   */
  export type SnippetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The filter to search for the Snippet to update in case it exists.
     */
    where: SnippetWhereUniqueInput
    /**
     * In case the Snippet found by the `where` argument doesn't exist, create a new Snippet with this data.
     */
    create: XOR<SnippetCreateInput, SnippetUncheckedCreateInput>
    /**
     * In case the Snippet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnippetUpdateInput, SnippetUncheckedUpdateInput>
  }

  /**
   * Snippet delete
   */
  export type SnippetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Filter which Snippet to delete.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet deleteMany
   */
  export type SnippetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snippets to delete
     */
    where?: SnippetWhereInput
    /**
     * Limit how many Snippets to delete.
     */
    limit?: number
  }

  /**
   * Snippet without action
   */
  export type SnippetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
  }


  /**
   * Model Redirect
   */

  export type AggregateRedirect = {
    _count: RedirectCountAggregateOutputType | null
    _avg: RedirectAvgAggregateOutputType | null
    _sum: RedirectSumAggregateOutputType | null
    _min: RedirectMinAggregateOutputType | null
    _max: RedirectMaxAggregateOutputType | null
  }

  export type RedirectAvgAggregateOutputType = {
    statusCode: number | null
  }

  export type RedirectSumAggregateOutputType = {
    statusCode: number | null
  }

  export type RedirectMinAggregateOutputType = {
    id: string | null
    sourcePath: string | null
    targetPath: string | null
    statusCode: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type RedirectMaxAggregateOutputType = {
    id: string | null
    sourcePath: string | null
    targetPath: string | null
    statusCode: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type RedirectCountAggregateOutputType = {
    id: number
    sourcePath: number
    targetPath: number
    statusCode: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type RedirectAvgAggregateInputType = {
    statusCode?: true
  }

  export type RedirectSumAggregateInputType = {
    statusCode?: true
  }

  export type RedirectMinAggregateInputType = {
    id?: true
    sourcePath?: true
    targetPath?: true
    statusCode?: true
    isActive?: true
    createdAt?: true
  }

  export type RedirectMaxAggregateInputType = {
    id?: true
    sourcePath?: true
    targetPath?: true
    statusCode?: true
    isActive?: true
    createdAt?: true
  }

  export type RedirectCountAggregateInputType = {
    id?: true
    sourcePath?: true
    targetPath?: true
    statusCode?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type RedirectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redirect to aggregate.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redirects
    **/
    _count?: true | RedirectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedirectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedirectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedirectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedirectMaxAggregateInputType
  }

  export type GetRedirectAggregateType<T extends RedirectAggregateArgs> = {
        [P in keyof T & keyof AggregateRedirect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedirect[P]>
      : GetScalarType<T[P], AggregateRedirect[P]>
  }




  export type RedirectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedirectWhereInput
    orderBy?: RedirectOrderByWithAggregationInput | RedirectOrderByWithAggregationInput[]
    by: RedirectScalarFieldEnum[] | RedirectScalarFieldEnum
    having?: RedirectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedirectCountAggregateInputType | true
    _avg?: RedirectAvgAggregateInputType
    _sum?: RedirectSumAggregateInputType
    _min?: RedirectMinAggregateInputType
    _max?: RedirectMaxAggregateInputType
  }

  export type RedirectGroupByOutputType = {
    id: string
    sourcePath: string
    targetPath: string
    statusCode: number
    isActive: boolean
    createdAt: Date
    _count: RedirectCountAggregateOutputType | null
    _avg: RedirectAvgAggregateOutputType | null
    _sum: RedirectSumAggregateOutputType | null
    _min: RedirectMinAggregateOutputType | null
    _max: RedirectMaxAggregateOutputType | null
  }

  type GetRedirectGroupByPayload<T extends RedirectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedirectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedirectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedirectGroupByOutputType[P]>
            : GetScalarType<T[P], RedirectGroupByOutputType[P]>
        }
      >
    >


  export type RedirectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourcePath?: boolean
    targetPath?: boolean
    statusCode?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["redirect"]>

  export type RedirectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourcePath?: boolean
    targetPath?: boolean
    statusCode?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["redirect"]>

  export type RedirectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourcePath?: boolean
    targetPath?: boolean
    statusCode?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["redirect"]>

  export type RedirectSelectScalar = {
    id?: boolean
    sourcePath?: boolean
    targetPath?: boolean
    statusCode?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type RedirectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourcePath" | "targetPath" | "statusCode" | "isActive" | "createdAt", ExtArgs["result"]["redirect"]>

  export type $RedirectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redirect"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourcePath: string
      targetPath: string
      statusCode: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["redirect"]>
    composites: {}
  }

  type RedirectGetPayload<S extends boolean | null | undefined | RedirectDefaultArgs> = $Result.GetResult<Prisma.$RedirectPayload, S>

  type RedirectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedirectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedirectCountAggregateInputType | true
    }

  export interface RedirectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redirect'], meta: { name: 'Redirect' } }
    /**
     * Find zero or one Redirect that matches the filter.
     * @param {RedirectFindUniqueArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedirectFindUniqueArgs>(args: SelectSubset<T, RedirectFindUniqueArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Redirect that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedirectFindUniqueOrThrowArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedirectFindUniqueOrThrowArgs>(args: SelectSubset<T, RedirectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Redirect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectFindFirstArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedirectFindFirstArgs>(args?: SelectSubset<T, RedirectFindFirstArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Redirect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectFindFirstOrThrowArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedirectFindFirstOrThrowArgs>(args?: SelectSubset<T, RedirectFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Redirects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redirects
     * const redirects = await prisma.redirect.findMany()
     * 
     * // Get first 10 Redirects
     * const redirects = await prisma.redirect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redirectWithIdOnly = await prisma.redirect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedirectFindManyArgs>(args?: SelectSubset<T, RedirectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Redirect.
     * @param {RedirectCreateArgs} args - Arguments to create a Redirect.
     * @example
     * // Create one Redirect
     * const Redirect = await prisma.redirect.create({
     *   data: {
     *     // ... data to create a Redirect
     *   }
     * })
     * 
     */
    create<T extends RedirectCreateArgs>(args: SelectSubset<T, RedirectCreateArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Redirects.
     * @param {RedirectCreateManyArgs} args - Arguments to create many Redirects.
     * @example
     * // Create many Redirects
     * const redirect = await prisma.redirect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedirectCreateManyArgs>(args?: SelectSubset<T, RedirectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Redirects and returns the data saved in the database.
     * @param {RedirectCreateManyAndReturnArgs} args - Arguments to create many Redirects.
     * @example
     * // Create many Redirects
     * const redirect = await prisma.redirect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Redirects and only return the `id`
     * const redirectWithIdOnly = await prisma.redirect.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedirectCreateManyAndReturnArgs>(args?: SelectSubset<T, RedirectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Redirect.
     * @param {RedirectDeleteArgs} args - Arguments to delete one Redirect.
     * @example
     * // Delete one Redirect
     * const Redirect = await prisma.redirect.delete({
     *   where: {
     *     // ... filter to delete one Redirect
     *   }
     * })
     * 
     */
    delete<T extends RedirectDeleteArgs>(args: SelectSubset<T, RedirectDeleteArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Redirect.
     * @param {RedirectUpdateArgs} args - Arguments to update one Redirect.
     * @example
     * // Update one Redirect
     * const redirect = await prisma.redirect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedirectUpdateArgs>(args: SelectSubset<T, RedirectUpdateArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Redirects.
     * @param {RedirectDeleteManyArgs} args - Arguments to filter Redirects to delete.
     * @example
     * // Delete a few Redirects
     * const { count } = await prisma.redirect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedirectDeleteManyArgs>(args?: SelectSubset<T, RedirectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redirects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redirects
     * const redirect = await prisma.redirect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedirectUpdateManyArgs>(args: SelectSubset<T, RedirectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redirects and returns the data updated in the database.
     * @param {RedirectUpdateManyAndReturnArgs} args - Arguments to update many Redirects.
     * @example
     * // Update many Redirects
     * const redirect = await prisma.redirect.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Redirects and only return the `id`
     * const redirectWithIdOnly = await prisma.redirect.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RedirectUpdateManyAndReturnArgs>(args: SelectSubset<T, RedirectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Redirect.
     * @param {RedirectUpsertArgs} args - Arguments to update or create a Redirect.
     * @example
     * // Update or create a Redirect
     * const redirect = await prisma.redirect.upsert({
     *   create: {
     *     // ... data to create a Redirect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redirect we want to update
     *   }
     * })
     */
    upsert<T extends RedirectUpsertArgs>(args: SelectSubset<T, RedirectUpsertArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Redirects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectCountArgs} args - Arguments to filter Redirects to count.
     * @example
     * // Count the number of Redirects
     * const count = await prisma.redirect.count({
     *   where: {
     *     // ... the filter for the Redirects we want to count
     *   }
     * })
    **/
    count<T extends RedirectCountArgs>(
      args?: Subset<T, RedirectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedirectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redirect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedirectAggregateArgs>(args: Subset<T, RedirectAggregateArgs>): Prisma.PrismaPromise<GetRedirectAggregateType<T>>

    /**
     * Group by Redirect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedirectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedirectGroupByArgs['orderBy'] }
        : { orderBy?: RedirectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedirectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedirectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redirect model
   */
  readonly fields: RedirectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redirect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedirectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Redirect model
   */
  interface RedirectFieldRefs {
    readonly id: FieldRef<"Redirect", 'String'>
    readonly sourcePath: FieldRef<"Redirect", 'String'>
    readonly targetPath: FieldRef<"Redirect", 'String'>
    readonly statusCode: FieldRef<"Redirect", 'Int'>
    readonly isActive: FieldRef<"Redirect", 'Boolean'>
    readonly createdAt: FieldRef<"Redirect", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Redirect findUnique
   */
  export type RedirectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect findUniqueOrThrow
   */
  export type RedirectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect findFirst
   */
  export type RedirectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redirects.
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redirects.
     */
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * Redirect findFirstOrThrow
   */
  export type RedirectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redirects.
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redirects.
     */
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * Redirect findMany
   */
  export type RedirectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Filter, which Redirects to fetch.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redirects.
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * Redirect create
   */
  export type RedirectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The data needed to create a Redirect.
     */
    data: XOR<RedirectCreateInput, RedirectUncheckedCreateInput>
  }

  /**
   * Redirect createMany
   */
  export type RedirectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redirects.
     */
    data: RedirectCreateManyInput | RedirectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Redirect createManyAndReturn
   */
  export type RedirectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The data used to create many Redirects.
     */
    data: RedirectCreateManyInput | RedirectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Redirect update
   */
  export type RedirectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The data needed to update a Redirect.
     */
    data: XOR<RedirectUpdateInput, RedirectUncheckedUpdateInput>
    /**
     * Choose, which Redirect to update.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect updateMany
   */
  export type RedirectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redirects.
     */
    data: XOR<RedirectUpdateManyMutationInput, RedirectUncheckedUpdateManyInput>
    /**
     * Filter which Redirects to update
     */
    where?: RedirectWhereInput
    /**
     * Limit how many Redirects to update.
     */
    limit?: number
  }

  /**
   * Redirect updateManyAndReturn
   */
  export type RedirectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The data used to update Redirects.
     */
    data: XOR<RedirectUpdateManyMutationInput, RedirectUncheckedUpdateManyInput>
    /**
     * Filter which Redirects to update
     */
    where?: RedirectWhereInput
    /**
     * Limit how many Redirects to update.
     */
    limit?: number
  }

  /**
   * Redirect upsert
   */
  export type RedirectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The filter to search for the Redirect to update in case it exists.
     */
    where: RedirectWhereUniqueInput
    /**
     * In case the Redirect found by the `where` argument doesn't exist, create a new Redirect with this data.
     */
    create: XOR<RedirectCreateInput, RedirectUncheckedCreateInput>
    /**
     * In case the Redirect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedirectUpdateInput, RedirectUncheckedUpdateInput>
  }

  /**
   * Redirect delete
   */
  export type RedirectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Filter which Redirect to delete.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect deleteMany
   */
  export type RedirectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redirects to delete
     */
    where?: RedirectWhereInput
    /**
     * Limit how many Redirects to delete.
     */
    limit?: number
  }

  /**
   * Redirect without action
   */
  export type RedirectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
  }


  /**
   * Model ContentSection
   */

  export type AggregateContentSection = {
    _count: ContentSectionCountAggregateOutputType | null
    _avg: ContentSectionAvgAggregateOutputType | null
    _sum: ContentSectionSumAggregateOutputType | null
    _min: ContentSectionMinAggregateOutputType | null
    _max: ContentSectionMaxAggregateOutputType | null
  }

  export type ContentSectionAvgAggregateOutputType = {
    order: number | null
  }

  export type ContentSectionSumAggregateOutputType = {
    order: number | null
  }

  export type ContentSectionMinAggregateOutputType = {
    id: string | null
    type: string | null
    order: number | null
    isVisible: boolean | null
    contentType: $Enums.ContentType | null
    contentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ContentSectionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    order: number | null
    isVisible: boolean | null
    contentType: $Enums.ContentType | null
    contentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ContentSectionCountAggregateOutputType = {
    id: number
    type: number
    content: number
    order: number
    metadata: number
    isVisible: number
    contentType: number
    contentId: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type ContentSectionAvgAggregateInputType = {
    order?: true
  }

  export type ContentSectionSumAggregateInputType = {
    order?: true
  }

  export type ContentSectionMinAggregateInputType = {
    id?: true
    type?: true
    order?: true
    isVisible?: true
    contentType?: true
    contentId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ContentSectionMaxAggregateInputType = {
    id?: true
    type?: true
    order?: true
    isVisible?: true
    contentType?: true
    contentId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ContentSectionCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    order?: true
    metadata?: true
    isVisible?: true
    contentType?: true
    contentId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type ContentSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSection to aggregate.
     */
    where?: ContentSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSections to fetch.
     */
    orderBy?: ContentSectionOrderByWithRelationInput | ContentSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentSections
    **/
    _count?: true | ContentSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentSectionMaxAggregateInputType
  }

  export type GetContentSectionAggregateType<T extends ContentSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateContentSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentSection[P]>
      : GetScalarType<T[P], AggregateContentSection[P]>
  }




  export type ContentSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentSectionWhereInput
    orderBy?: ContentSectionOrderByWithAggregationInput | ContentSectionOrderByWithAggregationInput[]
    by: ContentSectionScalarFieldEnum[] | ContentSectionScalarFieldEnum
    having?: ContentSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentSectionCountAggregateInputType | true
    _avg?: ContentSectionAvgAggregateInputType
    _sum?: ContentSectionSumAggregateInputType
    _min?: ContentSectionMinAggregateInputType
    _max?: ContentSectionMaxAggregateInputType
  }

  export type ContentSectionGroupByOutputType = {
    id: string
    type: string
    content: JsonValue
    order: number
    metadata: JsonValue | null
    isVisible: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: ContentSectionCountAggregateOutputType | null
    _avg: ContentSectionAvgAggregateOutputType | null
    _sum: ContentSectionSumAggregateOutputType | null
    _min: ContentSectionMinAggregateOutputType | null
    _max: ContentSectionMaxAggregateOutputType | null
  }

  type GetContentSectionGroupByPayload<T extends ContentSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentSectionGroupByOutputType[P]>
            : GetScalarType<T[P], ContentSectionGroupByOutputType[P]>
        }
      >
    >


  export type ContentSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    metadata?: boolean
    isVisible?: boolean
    contentType?: boolean
    contentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSection"]>

  export type ContentSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    metadata?: boolean
    isVisible?: boolean
    contentType?: boolean
    contentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSection"]>

  export type ContentSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    metadata?: boolean
    isVisible?: boolean
    contentType?: boolean
    contentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSection"]>

  export type ContentSectionSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    metadata?: boolean
    isVisible?: boolean
    contentType?: boolean
    contentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type ContentSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "order" | "metadata" | "isVisible" | "contentType" | "contentId" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["contentSection"]>
  export type ContentSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContentSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContentSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContentSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentSection"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      content: Prisma.JsonValue
      order: number
      metadata: Prisma.JsonValue | null
      isVisible: boolean
      contentType: $Enums.ContentType
      contentId: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["contentSection"]>
    composites: {}
  }

  type ContentSectionGetPayload<S extends boolean | null | undefined | ContentSectionDefaultArgs> = $Result.GetResult<Prisma.$ContentSectionPayload, S>

  type ContentSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentSectionCountAggregateInputType | true
    }

  export interface ContentSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentSection'], meta: { name: 'ContentSection' } }
    /**
     * Find zero or one ContentSection that matches the filter.
     * @param {ContentSectionFindUniqueArgs} args - Arguments to find a ContentSection
     * @example
     * // Get one ContentSection
     * const contentSection = await prisma.contentSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentSectionFindUniqueArgs>(args: SelectSubset<T, ContentSectionFindUniqueArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentSectionFindUniqueOrThrowArgs} args - Arguments to find a ContentSection
     * @example
     * // Get one ContentSection
     * const contentSection = await prisma.contentSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionFindFirstArgs} args - Arguments to find a ContentSection
     * @example
     * // Get one ContentSection
     * const contentSection = await prisma.contentSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentSectionFindFirstArgs>(args?: SelectSubset<T, ContentSectionFindFirstArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionFindFirstOrThrowArgs} args - Arguments to find a ContentSection
     * @example
     * // Get one ContentSection
     * const contentSection = await prisma.contentSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentSections
     * const contentSections = await prisma.contentSection.findMany()
     * 
     * // Get first 10 ContentSections
     * const contentSections = await prisma.contentSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentSectionWithIdOnly = await prisma.contentSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentSectionFindManyArgs>(args?: SelectSubset<T, ContentSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentSection.
     * @param {ContentSectionCreateArgs} args - Arguments to create a ContentSection.
     * @example
     * // Create one ContentSection
     * const ContentSection = await prisma.contentSection.create({
     *   data: {
     *     // ... data to create a ContentSection
     *   }
     * })
     * 
     */
    create<T extends ContentSectionCreateArgs>(args: SelectSubset<T, ContentSectionCreateArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentSections.
     * @param {ContentSectionCreateManyArgs} args - Arguments to create many ContentSections.
     * @example
     * // Create many ContentSections
     * const contentSection = await prisma.contentSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentSectionCreateManyArgs>(args?: SelectSubset<T, ContentSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentSections and returns the data saved in the database.
     * @param {ContentSectionCreateManyAndReturnArgs} args - Arguments to create many ContentSections.
     * @example
     * // Create many ContentSections
     * const contentSection = await prisma.contentSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentSections and only return the `id`
     * const contentSectionWithIdOnly = await prisma.contentSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentSection.
     * @param {ContentSectionDeleteArgs} args - Arguments to delete one ContentSection.
     * @example
     * // Delete one ContentSection
     * const ContentSection = await prisma.contentSection.delete({
     *   where: {
     *     // ... filter to delete one ContentSection
     *   }
     * })
     * 
     */
    delete<T extends ContentSectionDeleteArgs>(args: SelectSubset<T, ContentSectionDeleteArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentSection.
     * @param {ContentSectionUpdateArgs} args - Arguments to update one ContentSection.
     * @example
     * // Update one ContentSection
     * const contentSection = await prisma.contentSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentSectionUpdateArgs>(args: SelectSubset<T, ContentSectionUpdateArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentSections.
     * @param {ContentSectionDeleteManyArgs} args - Arguments to filter ContentSections to delete.
     * @example
     * // Delete a few ContentSections
     * const { count } = await prisma.contentSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentSectionDeleteManyArgs>(args?: SelectSubset<T, ContentSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentSections
     * const contentSection = await prisma.contentSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentSectionUpdateManyArgs>(args: SelectSubset<T, ContentSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSections and returns the data updated in the database.
     * @param {ContentSectionUpdateManyAndReturnArgs} args - Arguments to update many ContentSections.
     * @example
     * // Update many ContentSections
     * const contentSection = await prisma.contentSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentSections and only return the `id`
     * const contentSectionWithIdOnly = await prisma.contentSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentSection.
     * @param {ContentSectionUpsertArgs} args - Arguments to update or create a ContentSection.
     * @example
     * // Update or create a ContentSection
     * const contentSection = await prisma.contentSection.upsert({
     *   create: {
     *     // ... data to create a ContentSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentSection we want to update
     *   }
     * })
     */
    upsert<T extends ContentSectionUpsertArgs>(args: SelectSubset<T, ContentSectionUpsertArgs<ExtArgs>>): Prisma__ContentSectionClient<$Result.GetResult<Prisma.$ContentSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionCountArgs} args - Arguments to filter ContentSections to count.
     * @example
     * // Count the number of ContentSections
     * const count = await prisma.contentSection.count({
     *   where: {
     *     // ... the filter for the ContentSections we want to count
     *   }
     * })
    **/
    count<T extends ContentSectionCountArgs>(
      args?: Subset<T, ContentSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentSectionAggregateArgs>(args: Subset<T, ContentSectionAggregateArgs>): Prisma.PrismaPromise<GetContentSectionAggregateType<T>>

    /**
     * Group by ContentSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentSectionGroupByArgs['orderBy'] }
        : { orderBy?: ContentSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentSection model
   */
  readonly fields: ContentSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentSection model
   */
  interface ContentSectionFieldRefs {
    readonly id: FieldRef<"ContentSection", 'String'>
    readonly type: FieldRef<"ContentSection", 'String'>
    readonly content: FieldRef<"ContentSection", 'Json'>
    readonly order: FieldRef<"ContentSection", 'Int'>
    readonly metadata: FieldRef<"ContentSection", 'Json'>
    readonly isVisible: FieldRef<"ContentSection", 'Boolean'>
    readonly contentType: FieldRef<"ContentSection", 'ContentType'>
    readonly contentId: FieldRef<"ContentSection", 'String'>
    readonly createdAt: FieldRef<"ContentSection", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentSection", 'DateTime'>
    readonly createdById: FieldRef<"ContentSection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentSection findUnique
   */
  export type ContentSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * Filter, which ContentSection to fetch.
     */
    where: ContentSectionWhereUniqueInput
  }

  /**
   * ContentSection findUniqueOrThrow
   */
  export type ContentSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * Filter, which ContentSection to fetch.
     */
    where: ContentSectionWhereUniqueInput
  }

  /**
   * ContentSection findFirst
   */
  export type ContentSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * Filter, which ContentSection to fetch.
     */
    where?: ContentSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSections to fetch.
     */
    orderBy?: ContentSectionOrderByWithRelationInput | ContentSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSections.
     */
    cursor?: ContentSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSections.
     */
    distinct?: ContentSectionScalarFieldEnum | ContentSectionScalarFieldEnum[]
  }

  /**
   * ContentSection findFirstOrThrow
   */
  export type ContentSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * Filter, which ContentSection to fetch.
     */
    where?: ContentSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSections to fetch.
     */
    orderBy?: ContentSectionOrderByWithRelationInput | ContentSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSections.
     */
    cursor?: ContentSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSections.
     */
    distinct?: ContentSectionScalarFieldEnum | ContentSectionScalarFieldEnum[]
  }

  /**
   * ContentSection findMany
   */
  export type ContentSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * Filter, which ContentSections to fetch.
     */
    where?: ContentSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSections to fetch.
     */
    orderBy?: ContentSectionOrderByWithRelationInput | ContentSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentSections.
     */
    cursor?: ContentSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSections.
     */
    skip?: number
    distinct?: ContentSectionScalarFieldEnum | ContentSectionScalarFieldEnum[]
  }

  /**
   * ContentSection create
   */
  export type ContentSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentSection.
     */
    data: XOR<ContentSectionCreateInput, ContentSectionUncheckedCreateInput>
  }

  /**
   * ContentSection createMany
   */
  export type ContentSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentSections.
     */
    data: ContentSectionCreateManyInput | ContentSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentSection createManyAndReturn
   */
  export type ContentSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * The data used to create many ContentSections.
     */
    data: ContentSectionCreateManyInput | ContentSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentSection update
   */
  export type ContentSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentSection.
     */
    data: XOR<ContentSectionUpdateInput, ContentSectionUncheckedUpdateInput>
    /**
     * Choose, which ContentSection to update.
     */
    where: ContentSectionWhereUniqueInput
  }

  /**
   * ContentSection updateMany
   */
  export type ContentSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentSections.
     */
    data: XOR<ContentSectionUpdateManyMutationInput, ContentSectionUncheckedUpdateManyInput>
    /**
     * Filter which ContentSections to update
     */
    where?: ContentSectionWhereInput
    /**
     * Limit how many ContentSections to update.
     */
    limit?: number
  }

  /**
   * ContentSection updateManyAndReturn
   */
  export type ContentSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * The data used to update ContentSections.
     */
    data: XOR<ContentSectionUpdateManyMutationInput, ContentSectionUncheckedUpdateManyInput>
    /**
     * Filter which ContentSections to update
     */
    where?: ContentSectionWhereInput
    /**
     * Limit how many ContentSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentSection upsert
   */
  export type ContentSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentSection to update in case it exists.
     */
    where: ContentSectionWhereUniqueInput
    /**
     * In case the ContentSection found by the `where` argument doesn't exist, create a new ContentSection with this data.
     */
    create: XOR<ContentSectionCreateInput, ContentSectionUncheckedCreateInput>
    /**
     * In case the ContentSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentSectionUpdateInput, ContentSectionUncheckedUpdateInput>
  }

  /**
   * ContentSection delete
   */
  export type ContentSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
    /**
     * Filter which ContentSection to delete.
     */
    where: ContentSectionWhereUniqueInput
  }

  /**
   * ContentSection deleteMany
   */
  export type ContentSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSections to delete
     */
    where?: ContentSectionWhereInput
    /**
     * Limit how many ContentSections to delete.
     */
    limit?: number
  }

  /**
   * ContentSection without action
   */
  export type ContentSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSection
     */
    select?: ContentSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSection
     */
    omit?: ContentSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSectionInclude<ExtArgs> | null
  }


  /**
   * Model QuickEditItem
   */

  export type AggregateQuickEditItem = {
    _count: QuickEditItemCountAggregateOutputType | null
    _min: QuickEditItemMinAggregateOutputType | null
    _max: QuickEditItemMaxAggregateOutputType | null
  }

  export type QuickEditItemMinAggregateOutputType = {
    id: string | null
    key: string | null
    type: $Enums.QuickEditType | null
    page: string | null
    component: string | null
    element: string | null
    value: string | null
    defaultValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type QuickEditItemMaxAggregateOutputType = {
    id: string | null
    key: string | null
    type: $Enums.QuickEditType | null
    page: string | null
    component: string | null
    element: string | null
    value: string | null
    defaultValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type QuickEditItemCountAggregateOutputType = {
    id: number
    key: number
    type: number
    page: number
    component: number
    element: number
    value: number
    defaultValue: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type QuickEditItemMinAggregateInputType = {
    id?: true
    key?: true
    type?: true
    page?: true
    component?: true
    element?: true
    value?: true
    defaultValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type QuickEditItemMaxAggregateInputType = {
    id?: true
    key?: true
    type?: true
    page?: true
    component?: true
    element?: true
    value?: true
    defaultValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type QuickEditItemCountAggregateInputType = {
    id?: true
    key?: true
    type?: true
    page?: true
    component?: true
    element?: true
    value?: true
    defaultValue?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type QuickEditItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickEditItem to aggregate.
     */
    where?: QuickEditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditItems to fetch.
     */
    orderBy?: QuickEditItemOrderByWithRelationInput | QuickEditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuickEditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuickEditItems
    **/
    _count?: true | QuickEditItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuickEditItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuickEditItemMaxAggregateInputType
  }

  export type GetQuickEditItemAggregateType<T extends QuickEditItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuickEditItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuickEditItem[P]>
      : GetScalarType<T[P], AggregateQuickEditItem[P]>
  }




  export type QuickEditItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickEditItemWhereInput
    orderBy?: QuickEditItemOrderByWithAggregationInput | QuickEditItemOrderByWithAggregationInput[]
    by: QuickEditItemScalarFieldEnum[] | QuickEditItemScalarFieldEnum
    having?: QuickEditItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuickEditItemCountAggregateInputType | true
    _min?: QuickEditItemMinAggregateInputType
    _max?: QuickEditItemMaxAggregateInputType
  }

  export type QuickEditItemGroupByOutputType = {
    id: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: QuickEditItemCountAggregateOutputType | null
    _min: QuickEditItemMinAggregateOutputType | null
    _max: QuickEditItemMaxAggregateOutputType | null
  }

  type GetQuickEditItemGroupByPayload<T extends QuickEditItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuickEditItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuickEditItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuickEditItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuickEditItemGroupByOutputType[P]>
        }
      >
    >


  export type QuickEditItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    type?: boolean
    page?: boolean
    component?: boolean
    element?: boolean
    value?: boolean
    defaultValue?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    revisions?: boolean | QuickEditItem$revisionsArgs<ExtArgs>
    _count?: boolean | QuickEditItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickEditItem"]>

  export type QuickEditItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    type?: boolean
    page?: boolean
    component?: boolean
    element?: boolean
    value?: boolean
    defaultValue?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickEditItem"]>

  export type QuickEditItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    type?: boolean
    page?: boolean
    component?: boolean
    element?: boolean
    value?: boolean
    defaultValue?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickEditItem"]>

  export type QuickEditItemSelectScalar = {
    id?: boolean
    key?: boolean
    type?: boolean
    page?: boolean
    component?: boolean
    element?: boolean
    value?: boolean
    defaultValue?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type QuickEditItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "type" | "page" | "component" | "element" | "value" | "defaultValue" | "isActive" | "metadata" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["quickEditItem"]>
  export type QuickEditItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    revisions?: boolean | QuickEditItem$revisionsArgs<ExtArgs>
    _count?: boolean | QuickEditItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuickEditItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuickEditItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuickEditItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuickEditItem"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      revisions: Prisma.$QuickEditRevisionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      type: $Enums.QuickEditType
      page: string
      component: string
      element: string
      value: string
      defaultValue: string
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["quickEditItem"]>
    composites: {}
  }

  type QuickEditItemGetPayload<S extends boolean | null | undefined | QuickEditItemDefaultArgs> = $Result.GetResult<Prisma.$QuickEditItemPayload, S>

  type QuickEditItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuickEditItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuickEditItemCountAggregateInputType | true
    }

  export interface QuickEditItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuickEditItem'], meta: { name: 'QuickEditItem' } }
    /**
     * Find zero or one QuickEditItem that matches the filter.
     * @param {QuickEditItemFindUniqueArgs} args - Arguments to find a QuickEditItem
     * @example
     * // Get one QuickEditItem
     * const quickEditItem = await prisma.quickEditItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuickEditItemFindUniqueArgs>(args: SelectSubset<T, QuickEditItemFindUniqueArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuickEditItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuickEditItemFindUniqueOrThrowArgs} args - Arguments to find a QuickEditItem
     * @example
     * // Get one QuickEditItem
     * const quickEditItem = await prisma.quickEditItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuickEditItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuickEditItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuickEditItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemFindFirstArgs} args - Arguments to find a QuickEditItem
     * @example
     * // Get one QuickEditItem
     * const quickEditItem = await prisma.quickEditItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuickEditItemFindFirstArgs>(args?: SelectSubset<T, QuickEditItemFindFirstArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuickEditItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemFindFirstOrThrowArgs} args - Arguments to find a QuickEditItem
     * @example
     * // Get one QuickEditItem
     * const quickEditItem = await prisma.quickEditItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuickEditItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuickEditItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuickEditItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuickEditItems
     * const quickEditItems = await prisma.quickEditItem.findMany()
     * 
     * // Get first 10 QuickEditItems
     * const quickEditItems = await prisma.quickEditItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quickEditItemWithIdOnly = await prisma.quickEditItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuickEditItemFindManyArgs>(args?: SelectSubset<T, QuickEditItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuickEditItem.
     * @param {QuickEditItemCreateArgs} args - Arguments to create a QuickEditItem.
     * @example
     * // Create one QuickEditItem
     * const QuickEditItem = await prisma.quickEditItem.create({
     *   data: {
     *     // ... data to create a QuickEditItem
     *   }
     * })
     * 
     */
    create<T extends QuickEditItemCreateArgs>(args: SelectSubset<T, QuickEditItemCreateArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuickEditItems.
     * @param {QuickEditItemCreateManyArgs} args - Arguments to create many QuickEditItems.
     * @example
     * // Create many QuickEditItems
     * const quickEditItem = await prisma.quickEditItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuickEditItemCreateManyArgs>(args?: SelectSubset<T, QuickEditItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuickEditItems and returns the data saved in the database.
     * @param {QuickEditItemCreateManyAndReturnArgs} args - Arguments to create many QuickEditItems.
     * @example
     * // Create many QuickEditItems
     * const quickEditItem = await prisma.quickEditItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuickEditItems and only return the `id`
     * const quickEditItemWithIdOnly = await prisma.quickEditItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuickEditItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuickEditItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuickEditItem.
     * @param {QuickEditItemDeleteArgs} args - Arguments to delete one QuickEditItem.
     * @example
     * // Delete one QuickEditItem
     * const QuickEditItem = await prisma.quickEditItem.delete({
     *   where: {
     *     // ... filter to delete one QuickEditItem
     *   }
     * })
     * 
     */
    delete<T extends QuickEditItemDeleteArgs>(args: SelectSubset<T, QuickEditItemDeleteArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuickEditItem.
     * @param {QuickEditItemUpdateArgs} args - Arguments to update one QuickEditItem.
     * @example
     * // Update one QuickEditItem
     * const quickEditItem = await prisma.quickEditItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuickEditItemUpdateArgs>(args: SelectSubset<T, QuickEditItemUpdateArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuickEditItems.
     * @param {QuickEditItemDeleteManyArgs} args - Arguments to filter QuickEditItems to delete.
     * @example
     * // Delete a few QuickEditItems
     * const { count } = await prisma.quickEditItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuickEditItemDeleteManyArgs>(args?: SelectSubset<T, QuickEditItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickEditItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuickEditItems
     * const quickEditItem = await prisma.quickEditItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuickEditItemUpdateManyArgs>(args: SelectSubset<T, QuickEditItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickEditItems and returns the data updated in the database.
     * @param {QuickEditItemUpdateManyAndReturnArgs} args - Arguments to update many QuickEditItems.
     * @example
     * // Update many QuickEditItems
     * const quickEditItem = await prisma.quickEditItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuickEditItems and only return the `id`
     * const quickEditItemWithIdOnly = await prisma.quickEditItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuickEditItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuickEditItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuickEditItem.
     * @param {QuickEditItemUpsertArgs} args - Arguments to update or create a QuickEditItem.
     * @example
     * // Update or create a QuickEditItem
     * const quickEditItem = await prisma.quickEditItem.upsert({
     *   create: {
     *     // ... data to create a QuickEditItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuickEditItem we want to update
     *   }
     * })
     */
    upsert<T extends QuickEditItemUpsertArgs>(args: SelectSubset<T, QuickEditItemUpsertArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuickEditItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemCountArgs} args - Arguments to filter QuickEditItems to count.
     * @example
     * // Count the number of QuickEditItems
     * const count = await prisma.quickEditItem.count({
     *   where: {
     *     // ... the filter for the QuickEditItems we want to count
     *   }
     * })
    **/
    count<T extends QuickEditItemCountArgs>(
      args?: Subset<T, QuickEditItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuickEditItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuickEditItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuickEditItemAggregateArgs>(args: Subset<T, QuickEditItemAggregateArgs>): Prisma.PrismaPromise<GetQuickEditItemAggregateType<T>>

    /**
     * Group by QuickEditItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuickEditItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuickEditItemGroupByArgs['orderBy'] }
        : { orderBy?: QuickEditItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuickEditItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuickEditItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuickEditItem model
   */
  readonly fields: QuickEditItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuickEditItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuickEditItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    revisions<T extends QuickEditItem$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, QuickEditItem$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuickEditItem model
   */
  interface QuickEditItemFieldRefs {
    readonly id: FieldRef<"QuickEditItem", 'String'>
    readonly key: FieldRef<"QuickEditItem", 'String'>
    readonly type: FieldRef<"QuickEditItem", 'QuickEditType'>
    readonly page: FieldRef<"QuickEditItem", 'String'>
    readonly component: FieldRef<"QuickEditItem", 'String'>
    readonly element: FieldRef<"QuickEditItem", 'String'>
    readonly value: FieldRef<"QuickEditItem", 'String'>
    readonly defaultValue: FieldRef<"QuickEditItem", 'String'>
    readonly isActive: FieldRef<"QuickEditItem", 'Boolean'>
    readonly metadata: FieldRef<"QuickEditItem", 'Json'>
    readonly createdAt: FieldRef<"QuickEditItem", 'DateTime'>
    readonly updatedAt: FieldRef<"QuickEditItem", 'DateTime'>
    readonly createdById: FieldRef<"QuickEditItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuickEditItem findUnique
   */
  export type QuickEditItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditItem to fetch.
     */
    where: QuickEditItemWhereUniqueInput
  }

  /**
   * QuickEditItem findUniqueOrThrow
   */
  export type QuickEditItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditItem to fetch.
     */
    where: QuickEditItemWhereUniqueInput
  }

  /**
   * QuickEditItem findFirst
   */
  export type QuickEditItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditItem to fetch.
     */
    where?: QuickEditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditItems to fetch.
     */
    orderBy?: QuickEditItemOrderByWithRelationInput | QuickEditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickEditItems.
     */
    cursor?: QuickEditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickEditItems.
     */
    distinct?: QuickEditItemScalarFieldEnum | QuickEditItemScalarFieldEnum[]
  }

  /**
   * QuickEditItem findFirstOrThrow
   */
  export type QuickEditItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditItem to fetch.
     */
    where?: QuickEditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditItems to fetch.
     */
    orderBy?: QuickEditItemOrderByWithRelationInput | QuickEditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickEditItems.
     */
    cursor?: QuickEditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickEditItems.
     */
    distinct?: QuickEditItemScalarFieldEnum | QuickEditItemScalarFieldEnum[]
  }

  /**
   * QuickEditItem findMany
   */
  export type QuickEditItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditItems to fetch.
     */
    where?: QuickEditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditItems to fetch.
     */
    orderBy?: QuickEditItemOrderByWithRelationInput | QuickEditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuickEditItems.
     */
    cursor?: QuickEditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditItems.
     */
    skip?: number
    distinct?: QuickEditItemScalarFieldEnum | QuickEditItemScalarFieldEnum[]
  }

  /**
   * QuickEditItem create
   */
  export type QuickEditItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuickEditItem.
     */
    data: XOR<QuickEditItemCreateInput, QuickEditItemUncheckedCreateInput>
  }

  /**
   * QuickEditItem createMany
   */
  export type QuickEditItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuickEditItems.
     */
    data: QuickEditItemCreateManyInput | QuickEditItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuickEditItem createManyAndReturn
   */
  export type QuickEditItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuickEditItems.
     */
    data: QuickEditItemCreateManyInput | QuickEditItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuickEditItem update
   */
  export type QuickEditItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuickEditItem.
     */
    data: XOR<QuickEditItemUpdateInput, QuickEditItemUncheckedUpdateInput>
    /**
     * Choose, which QuickEditItem to update.
     */
    where: QuickEditItemWhereUniqueInput
  }

  /**
   * QuickEditItem updateMany
   */
  export type QuickEditItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuickEditItems.
     */
    data: XOR<QuickEditItemUpdateManyMutationInput, QuickEditItemUncheckedUpdateManyInput>
    /**
     * Filter which QuickEditItems to update
     */
    where?: QuickEditItemWhereInput
    /**
     * Limit how many QuickEditItems to update.
     */
    limit?: number
  }

  /**
   * QuickEditItem updateManyAndReturn
   */
  export type QuickEditItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * The data used to update QuickEditItems.
     */
    data: XOR<QuickEditItemUpdateManyMutationInput, QuickEditItemUncheckedUpdateManyInput>
    /**
     * Filter which QuickEditItems to update
     */
    where?: QuickEditItemWhereInput
    /**
     * Limit how many QuickEditItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuickEditItem upsert
   */
  export type QuickEditItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuickEditItem to update in case it exists.
     */
    where: QuickEditItemWhereUniqueInput
    /**
     * In case the QuickEditItem found by the `where` argument doesn't exist, create a new QuickEditItem with this data.
     */
    create: XOR<QuickEditItemCreateInput, QuickEditItemUncheckedCreateInput>
    /**
     * In case the QuickEditItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuickEditItemUpdateInput, QuickEditItemUncheckedUpdateInput>
  }

  /**
   * QuickEditItem delete
   */
  export type QuickEditItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
    /**
     * Filter which QuickEditItem to delete.
     */
    where: QuickEditItemWhereUniqueInput
  }

  /**
   * QuickEditItem deleteMany
   */
  export type QuickEditItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickEditItems to delete
     */
    where?: QuickEditItemWhereInput
    /**
     * Limit how many QuickEditItems to delete.
     */
    limit?: number
  }

  /**
   * QuickEditItem.revisions
   */
  export type QuickEditItem$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    where?: QuickEditRevisionWhereInput
    orderBy?: QuickEditRevisionOrderByWithRelationInput | QuickEditRevisionOrderByWithRelationInput[]
    cursor?: QuickEditRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuickEditRevisionScalarFieldEnum | QuickEditRevisionScalarFieldEnum[]
  }

  /**
   * QuickEditItem without action
   */
  export type QuickEditItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditItem
     */
    select?: QuickEditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditItem
     */
    omit?: QuickEditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditItemInclude<ExtArgs> | null
  }


  /**
   * Model QuickEditRevision
   */

  export type AggregateQuickEditRevision = {
    _count: QuickEditRevisionCountAggregateOutputType | null
    _min: QuickEditRevisionMinAggregateOutputType | null
    _max: QuickEditRevisionMaxAggregateOutputType | null
  }

  export type QuickEditRevisionMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    value: string | null
    changeType: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type QuickEditRevisionMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    value: string | null
    changeType: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type QuickEditRevisionCountAggregateOutputType = {
    id: number
    itemId: number
    value: number
    changeType: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type QuickEditRevisionMinAggregateInputType = {
    id?: true
    itemId?: true
    value?: true
    changeType?: true
    createdAt?: true
    createdById?: true
  }

  export type QuickEditRevisionMaxAggregateInputType = {
    id?: true
    itemId?: true
    value?: true
    changeType?: true
    createdAt?: true
    createdById?: true
  }

  export type QuickEditRevisionCountAggregateInputType = {
    id?: true
    itemId?: true
    value?: true
    changeType?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type QuickEditRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickEditRevision to aggregate.
     */
    where?: QuickEditRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditRevisions to fetch.
     */
    orderBy?: QuickEditRevisionOrderByWithRelationInput | QuickEditRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuickEditRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuickEditRevisions
    **/
    _count?: true | QuickEditRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuickEditRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuickEditRevisionMaxAggregateInputType
  }

  export type GetQuickEditRevisionAggregateType<T extends QuickEditRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuickEditRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuickEditRevision[P]>
      : GetScalarType<T[P], AggregateQuickEditRevision[P]>
  }




  export type QuickEditRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickEditRevisionWhereInput
    orderBy?: QuickEditRevisionOrderByWithAggregationInput | QuickEditRevisionOrderByWithAggregationInput[]
    by: QuickEditRevisionScalarFieldEnum[] | QuickEditRevisionScalarFieldEnum
    having?: QuickEditRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuickEditRevisionCountAggregateInputType | true
    _min?: QuickEditRevisionMinAggregateInputType
    _max?: QuickEditRevisionMaxAggregateInputType
  }

  export type QuickEditRevisionGroupByOutputType = {
    id: string
    itemId: string
    value: string
    changeType: string
    createdAt: Date
    createdById: string
    _count: QuickEditRevisionCountAggregateOutputType | null
    _min: QuickEditRevisionMinAggregateOutputType | null
    _max: QuickEditRevisionMaxAggregateOutputType | null
  }

  type GetQuickEditRevisionGroupByPayload<T extends QuickEditRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuickEditRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuickEditRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuickEditRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], QuickEditRevisionGroupByOutputType[P]>
        }
      >
    >


  export type QuickEditRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    value?: boolean
    changeType?: boolean
    createdAt?: boolean
    createdById?: boolean
    item?: boolean | QuickEditItemDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickEditRevision"]>

  export type QuickEditRevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    value?: boolean
    changeType?: boolean
    createdAt?: boolean
    createdById?: boolean
    item?: boolean | QuickEditItemDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickEditRevision"]>

  export type QuickEditRevisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    value?: boolean
    changeType?: boolean
    createdAt?: boolean
    createdById?: boolean
    item?: boolean | QuickEditItemDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickEditRevision"]>

  export type QuickEditRevisionSelectScalar = {
    id?: boolean
    itemId?: boolean
    value?: boolean
    changeType?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type QuickEditRevisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "value" | "changeType" | "createdAt" | "createdById", ExtArgs["result"]["quickEditRevision"]>
  export type QuickEditRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | QuickEditItemDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuickEditRevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | QuickEditItemDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuickEditRevisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | QuickEditItemDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuickEditRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuickEditRevision"
    objects: {
      item: Prisma.$QuickEditItemPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      value: string
      changeType: string
      createdAt: Date
      createdById: string
    }, ExtArgs["result"]["quickEditRevision"]>
    composites: {}
  }

  type QuickEditRevisionGetPayload<S extends boolean | null | undefined | QuickEditRevisionDefaultArgs> = $Result.GetResult<Prisma.$QuickEditRevisionPayload, S>

  type QuickEditRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuickEditRevisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuickEditRevisionCountAggregateInputType | true
    }

  export interface QuickEditRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuickEditRevision'], meta: { name: 'QuickEditRevision' } }
    /**
     * Find zero or one QuickEditRevision that matches the filter.
     * @param {QuickEditRevisionFindUniqueArgs} args - Arguments to find a QuickEditRevision
     * @example
     * // Get one QuickEditRevision
     * const quickEditRevision = await prisma.quickEditRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuickEditRevisionFindUniqueArgs>(args: SelectSubset<T, QuickEditRevisionFindUniqueArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuickEditRevision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuickEditRevisionFindUniqueOrThrowArgs} args - Arguments to find a QuickEditRevision
     * @example
     * // Get one QuickEditRevision
     * const quickEditRevision = await prisma.quickEditRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuickEditRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuickEditRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuickEditRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionFindFirstArgs} args - Arguments to find a QuickEditRevision
     * @example
     * // Get one QuickEditRevision
     * const quickEditRevision = await prisma.quickEditRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuickEditRevisionFindFirstArgs>(args?: SelectSubset<T, QuickEditRevisionFindFirstArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuickEditRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionFindFirstOrThrowArgs} args - Arguments to find a QuickEditRevision
     * @example
     * // Get one QuickEditRevision
     * const quickEditRevision = await prisma.quickEditRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuickEditRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuickEditRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuickEditRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuickEditRevisions
     * const quickEditRevisions = await prisma.quickEditRevision.findMany()
     * 
     * // Get first 10 QuickEditRevisions
     * const quickEditRevisions = await prisma.quickEditRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quickEditRevisionWithIdOnly = await prisma.quickEditRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuickEditRevisionFindManyArgs>(args?: SelectSubset<T, QuickEditRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuickEditRevision.
     * @param {QuickEditRevisionCreateArgs} args - Arguments to create a QuickEditRevision.
     * @example
     * // Create one QuickEditRevision
     * const QuickEditRevision = await prisma.quickEditRevision.create({
     *   data: {
     *     // ... data to create a QuickEditRevision
     *   }
     * })
     * 
     */
    create<T extends QuickEditRevisionCreateArgs>(args: SelectSubset<T, QuickEditRevisionCreateArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuickEditRevisions.
     * @param {QuickEditRevisionCreateManyArgs} args - Arguments to create many QuickEditRevisions.
     * @example
     * // Create many QuickEditRevisions
     * const quickEditRevision = await prisma.quickEditRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuickEditRevisionCreateManyArgs>(args?: SelectSubset<T, QuickEditRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuickEditRevisions and returns the data saved in the database.
     * @param {QuickEditRevisionCreateManyAndReturnArgs} args - Arguments to create many QuickEditRevisions.
     * @example
     * // Create many QuickEditRevisions
     * const quickEditRevision = await prisma.quickEditRevision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuickEditRevisions and only return the `id`
     * const quickEditRevisionWithIdOnly = await prisma.quickEditRevision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuickEditRevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuickEditRevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuickEditRevision.
     * @param {QuickEditRevisionDeleteArgs} args - Arguments to delete one QuickEditRevision.
     * @example
     * // Delete one QuickEditRevision
     * const QuickEditRevision = await prisma.quickEditRevision.delete({
     *   where: {
     *     // ... filter to delete one QuickEditRevision
     *   }
     * })
     * 
     */
    delete<T extends QuickEditRevisionDeleteArgs>(args: SelectSubset<T, QuickEditRevisionDeleteArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuickEditRevision.
     * @param {QuickEditRevisionUpdateArgs} args - Arguments to update one QuickEditRevision.
     * @example
     * // Update one QuickEditRevision
     * const quickEditRevision = await prisma.quickEditRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuickEditRevisionUpdateArgs>(args: SelectSubset<T, QuickEditRevisionUpdateArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuickEditRevisions.
     * @param {QuickEditRevisionDeleteManyArgs} args - Arguments to filter QuickEditRevisions to delete.
     * @example
     * // Delete a few QuickEditRevisions
     * const { count } = await prisma.quickEditRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuickEditRevisionDeleteManyArgs>(args?: SelectSubset<T, QuickEditRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickEditRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuickEditRevisions
     * const quickEditRevision = await prisma.quickEditRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuickEditRevisionUpdateManyArgs>(args: SelectSubset<T, QuickEditRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickEditRevisions and returns the data updated in the database.
     * @param {QuickEditRevisionUpdateManyAndReturnArgs} args - Arguments to update many QuickEditRevisions.
     * @example
     * // Update many QuickEditRevisions
     * const quickEditRevision = await prisma.quickEditRevision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuickEditRevisions and only return the `id`
     * const quickEditRevisionWithIdOnly = await prisma.quickEditRevision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuickEditRevisionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuickEditRevisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuickEditRevision.
     * @param {QuickEditRevisionUpsertArgs} args - Arguments to update or create a QuickEditRevision.
     * @example
     * // Update or create a QuickEditRevision
     * const quickEditRevision = await prisma.quickEditRevision.upsert({
     *   create: {
     *     // ... data to create a QuickEditRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuickEditRevision we want to update
     *   }
     * })
     */
    upsert<T extends QuickEditRevisionUpsertArgs>(args: SelectSubset<T, QuickEditRevisionUpsertArgs<ExtArgs>>): Prisma__QuickEditRevisionClient<$Result.GetResult<Prisma.$QuickEditRevisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuickEditRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionCountArgs} args - Arguments to filter QuickEditRevisions to count.
     * @example
     * // Count the number of QuickEditRevisions
     * const count = await prisma.quickEditRevision.count({
     *   where: {
     *     // ... the filter for the QuickEditRevisions we want to count
     *   }
     * })
    **/
    count<T extends QuickEditRevisionCountArgs>(
      args?: Subset<T, QuickEditRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuickEditRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuickEditRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuickEditRevisionAggregateArgs>(args: Subset<T, QuickEditRevisionAggregateArgs>): Prisma.PrismaPromise<GetQuickEditRevisionAggregateType<T>>

    /**
     * Group by QuickEditRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickEditRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuickEditRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuickEditRevisionGroupByArgs['orderBy'] }
        : { orderBy?: QuickEditRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuickEditRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuickEditRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuickEditRevision model
   */
  readonly fields: QuickEditRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuickEditRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuickEditRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends QuickEditItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuickEditItemDefaultArgs<ExtArgs>>): Prisma__QuickEditItemClient<$Result.GetResult<Prisma.$QuickEditItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuickEditRevision model
   */
  interface QuickEditRevisionFieldRefs {
    readonly id: FieldRef<"QuickEditRevision", 'String'>
    readonly itemId: FieldRef<"QuickEditRevision", 'String'>
    readonly value: FieldRef<"QuickEditRevision", 'String'>
    readonly changeType: FieldRef<"QuickEditRevision", 'String'>
    readonly createdAt: FieldRef<"QuickEditRevision", 'DateTime'>
    readonly createdById: FieldRef<"QuickEditRevision", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuickEditRevision findUnique
   */
  export type QuickEditRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditRevision to fetch.
     */
    where: QuickEditRevisionWhereUniqueInput
  }

  /**
   * QuickEditRevision findUniqueOrThrow
   */
  export type QuickEditRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditRevision to fetch.
     */
    where: QuickEditRevisionWhereUniqueInput
  }

  /**
   * QuickEditRevision findFirst
   */
  export type QuickEditRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditRevision to fetch.
     */
    where?: QuickEditRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditRevisions to fetch.
     */
    orderBy?: QuickEditRevisionOrderByWithRelationInput | QuickEditRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickEditRevisions.
     */
    cursor?: QuickEditRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickEditRevisions.
     */
    distinct?: QuickEditRevisionScalarFieldEnum | QuickEditRevisionScalarFieldEnum[]
  }

  /**
   * QuickEditRevision findFirstOrThrow
   */
  export type QuickEditRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditRevision to fetch.
     */
    where?: QuickEditRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditRevisions to fetch.
     */
    orderBy?: QuickEditRevisionOrderByWithRelationInput | QuickEditRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickEditRevisions.
     */
    cursor?: QuickEditRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickEditRevisions.
     */
    distinct?: QuickEditRevisionScalarFieldEnum | QuickEditRevisionScalarFieldEnum[]
  }

  /**
   * QuickEditRevision findMany
   */
  export type QuickEditRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * Filter, which QuickEditRevisions to fetch.
     */
    where?: QuickEditRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickEditRevisions to fetch.
     */
    orderBy?: QuickEditRevisionOrderByWithRelationInput | QuickEditRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuickEditRevisions.
     */
    cursor?: QuickEditRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickEditRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickEditRevisions.
     */
    skip?: number
    distinct?: QuickEditRevisionScalarFieldEnum | QuickEditRevisionScalarFieldEnum[]
  }

  /**
   * QuickEditRevision create
   */
  export type QuickEditRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuickEditRevision.
     */
    data: XOR<QuickEditRevisionCreateInput, QuickEditRevisionUncheckedCreateInput>
  }

  /**
   * QuickEditRevision createMany
   */
  export type QuickEditRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuickEditRevisions.
     */
    data: QuickEditRevisionCreateManyInput | QuickEditRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuickEditRevision createManyAndReturn
   */
  export type QuickEditRevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * The data used to create many QuickEditRevisions.
     */
    data: QuickEditRevisionCreateManyInput | QuickEditRevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuickEditRevision update
   */
  export type QuickEditRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuickEditRevision.
     */
    data: XOR<QuickEditRevisionUpdateInput, QuickEditRevisionUncheckedUpdateInput>
    /**
     * Choose, which QuickEditRevision to update.
     */
    where: QuickEditRevisionWhereUniqueInput
  }

  /**
   * QuickEditRevision updateMany
   */
  export type QuickEditRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuickEditRevisions.
     */
    data: XOR<QuickEditRevisionUpdateManyMutationInput, QuickEditRevisionUncheckedUpdateManyInput>
    /**
     * Filter which QuickEditRevisions to update
     */
    where?: QuickEditRevisionWhereInput
    /**
     * Limit how many QuickEditRevisions to update.
     */
    limit?: number
  }

  /**
   * QuickEditRevision updateManyAndReturn
   */
  export type QuickEditRevisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * The data used to update QuickEditRevisions.
     */
    data: XOR<QuickEditRevisionUpdateManyMutationInput, QuickEditRevisionUncheckedUpdateManyInput>
    /**
     * Filter which QuickEditRevisions to update
     */
    where?: QuickEditRevisionWhereInput
    /**
     * Limit how many QuickEditRevisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuickEditRevision upsert
   */
  export type QuickEditRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuickEditRevision to update in case it exists.
     */
    where: QuickEditRevisionWhereUniqueInput
    /**
     * In case the QuickEditRevision found by the `where` argument doesn't exist, create a new QuickEditRevision with this data.
     */
    create: XOR<QuickEditRevisionCreateInput, QuickEditRevisionUncheckedCreateInput>
    /**
     * In case the QuickEditRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuickEditRevisionUpdateInput, QuickEditRevisionUncheckedUpdateInput>
  }

  /**
   * QuickEditRevision delete
   */
  export type QuickEditRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
    /**
     * Filter which QuickEditRevision to delete.
     */
    where: QuickEditRevisionWhereUniqueInput
  }

  /**
   * QuickEditRevision deleteMany
   */
  export type QuickEditRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickEditRevisions to delete
     */
    where?: QuickEditRevisionWhereInput
    /**
     * Limit how many QuickEditRevisions to delete.
     */
    limit?: number
  }

  /**
   * QuickEditRevision without action
   */
  export type QuickEditRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickEditRevision
     */
    select?: QuickEditRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuickEditRevision
     */
    omit?: QuickEditRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickEditRevisionInclude<ExtArgs> | null
  }


  /**
   * Model ThemeSetting
   */

  export type AggregateThemeSetting = {
    _count: ThemeSettingCountAggregateOutputType | null
    _min: ThemeSettingMinAggregateOutputType | null
    _max: ThemeSettingMaxAggregateOutputType | null
  }

  export type ThemeSettingMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    value: string | null
    cssVariable: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ThemeSettingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    value: string | null
    cssVariable: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ThemeSettingCountAggregateOutputType = {
    id: number
    name: number
    category: number
    value: number
    cssVariable: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type ThemeSettingMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    value?: true
    cssVariable?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ThemeSettingMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    value?: true
    cssVariable?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ThemeSettingCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    value?: true
    cssVariable?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type ThemeSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThemeSetting to aggregate.
     */
    where?: ThemeSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeSettings to fetch.
     */
    orderBy?: ThemeSettingOrderByWithRelationInput | ThemeSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThemeSettings
    **/
    _count?: true | ThemeSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeSettingMaxAggregateInputType
  }

  export type GetThemeSettingAggregateType<T extends ThemeSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateThemeSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThemeSetting[P]>
      : GetScalarType<T[P], AggregateThemeSetting[P]>
  }




  export type ThemeSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeSettingWhereInput
    orderBy?: ThemeSettingOrderByWithAggregationInput | ThemeSettingOrderByWithAggregationInput[]
    by: ThemeSettingScalarFieldEnum[] | ThemeSettingScalarFieldEnum
    having?: ThemeSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeSettingCountAggregateInputType | true
    _min?: ThemeSettingMinAggregateInputType
    _max?: ThemeSettingMaxAggregateInputType
  }

  export type ThemeSettingGroupByOutputType = {
    id: string
    name: string
    category: string
    value: string
    cssVariable: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: ThemeSettingCountAggregateOutputType | null
    _min: ThemeSettingMinAggregateOutputType | null
    _max: ThemeSettingMaxAggregateOutputType | null
  }

  type GetThemeSettingGroupByPayload<T extends ThemeSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeSettingGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeSettingGroupByOutputType[P]>
        }
      >
    >


  export type ThemeSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    value?: boolean
    cssVariable?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeSetting"]>

  export type ThemeSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    value?: boolean
    cssVariable?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeSetting"]>

  export type ThemeSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    value?: boolean
    cssVariable?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeSetting"]>

  export type ThemeSettingSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    value?: boolean
    cssVariable?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type ThemeSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "value" | "cssVariable" | "description" | "isActive" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["themeSetting"]>
  export type ThemeSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ThemeSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ThemeSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ThemeSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThemeSetting"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      value: string
      cssVariable: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["themeSetting"]>
    composites: {}
  }

  type ThemeSettingGetPayload<S extends boolean | null | undefined | ThemeSettingDefaultArgs> = $Result.GetResult<Prisma.$ThemeSettingPayload, S>

  type ThemeSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemeSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemeSettingCountAggregateInputType | true
    }

  export interface ThemeSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThemeSetting'], meta: { name: 'ThemeSetting' } }
    /**
     * Find zero or one ThemeSetting that matches the filter.
     * @param {ThemeSettingFindUniqueArgs} args - Arguments to find a ThemeSetting
     * @example
     * // Get one ThemeSetting
     * const themeSetting = await prisma.themeSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemeSettingFindUniqueArgs>(args: SelectSubset<T, ThemeSettingFindUniqueArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThemeSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemeSettingFindUniqueOrThrowArgs} args - Arguments to find a ThemeSetting
     * @example
     * // Get one ThemeSetting
     * const themeSetting = await prisma.themeSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemeSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemeSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThemeSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingFindFirstArgs} args - Arguments to find a ThemeSetting
     * @example
     * // Get one ThemeSetting
     * const themeSetting = await prisma.themeSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemeSettingFindFirstArgs>(args?: SelectSubset<T, ThemeSettingFindFirstArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThemeSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingFindFirstOrThrowArgs} args - Arguments to find a ThemeSetting
     * @example
     * // Get one ThemeSetting
     * const themeSetting = await prisma.themeSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemeSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemeSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThemeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThemeSettings
     * const themeSettings = await prisma.themeSetting.findMany()
     * 
     * // Get first 10 ThemeSettings
     * const themeSettings = await prisma.themeSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themeSettingWithIdOnly = await prisma.themeSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThemeSettingFindManyArgs>(args?: SelectSubset<T, ThemeSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThemeSetting.
     * @param {ThemeSettingCreateArgs} args - Arguments to create a ThemeSetting.
     * @example
     * // Create one ThemeSetting
     * const ThemeSetting = await prisma.themeSetting.create({
     *   data: {
     *     // ... data to create a ThemeSetting
     *   }
     * })
     * 
     */
    create<T extends ThemeSettingCreateArgs>(args: SelectSubset<T, ThemeSettingCreateArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThemeSettings.
     * @param {ThemeSettingCreateManyArgs} args - Arguments to create many ThemeSettings.
     * @example
     * // Create many ThemeSettings
     * const themeSetting = await prisma.themeSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemeSettingCreateManyArgs>(args?: SelectSubset<T, ThemeSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThemeSettings and returns the data saved in the database.
     * @param {ThemeSettingCreateManyAndReturnArgs} args - Arguments to create many ThemeSettings.
     * @example
     * // Create many ThemeSettings
     * const themeSetting = await prisma.themeSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThemeSettings and only return the `id`
     * const themeSettingWithIdOnly = await prisma.themeSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThemeSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, ThemeSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThemeSetting.
     * @param {ThemeSettingDeleteArgs} args - Arguments to delete one ThemeSetting.
     * @example
     * // Delete one ThemeSetting
     * const ThemeSetting = await prisma.themeSetting.delete({
     *   where: {
     *     // ... filter to delete one ThemeSetting
     *   }
     * })
     * 
     */
    delete<T extends ThemeSettingDeleteArgs>(args: SelectSubset<T, ThemeSettingDeleteArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThemeSetting.
     * @param {ThemeSettingUpdateArgs} args - Arguments to update one ThemeSetting.
     * @example
     * // Update one ThemeSetting
     * const themeSetting = await prisma.themeSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemeSettingUpdateArgs>(args: SelectSubset<T, ThemeSettingUpdateArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThemeSettings.
     * @param {ThemeSettingDeleteManyArgs} args - Arguments to filter ThemeSettings to delete.
     * @example
     * // Delete a few ThemeSettings
     * const { count } = await prisma.themeSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemeSettingDeleteManyArgs>(args?: SelectSubset<T, ThemeSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThemeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThemeSettings
     * const themeSetting = await prisma.themeSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemeSettingUpdateManyArgs>(args: SelectSubset<T, ThemeSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThemeSettings and returns the data updated in the database.
     * @param {ThemeSettingUpdateManyAndReturnArgs} args - Arguments to update many ThemeSettings.
     * @example
     * // Update many ThemeSettings
     * const themeSetting = await prisma.themeSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThemeSettings and only return the `id`
     * const themeSettingWithIdOnly = await prisma.themeSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThemeSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, ThemeSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThemeSetting.
     * @param {ThemeSettingUpsertArgs} args - Arguments to update or create a ThemeSetting.
     * @example
     * // Update or create a ThemeSetting
     * const themeSetting = await prisma.themeSetting.upsert({
     *   create: {
     *     // ... data to create a ThemeSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThemeSetting we want to update
     *   }
     * })
     */
    upsert<T extends ThemeSettingUpsertArgs>(args: SelectSubset<T, ThemeSettingUpsertArgs<ExtArgs>>): Prisma__ThemeSettingClient<$Result.GetResult<Prisma.$ThemeSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThemeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingCountArgs} args - Arguments to filter ThemeSettings to count.
     * @example
     * // Count the number of ThemeSettings
     * const count = await prisma.themeSetting.count({
     *   where: {
     *     // ... the filter for the ThemeSettings we want to count
     *   }
     * })
    **/
    count<T extends ThemeSettingCountArgs>(
      args?: Subset<T, ThemeSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThemeSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeSettingAggregateArgs>(args: Subset<T, ThemeSettingAggregateArgs>): Prisma.PrismaPromise<GetThemeSettingAggregateType<T>>

    /**
     * Group by ThemeSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeSettingGroupByArgs['orderBy'] }
        : { orderBy?: ThemeSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThemeSetting model
   */
  readonly fields: ThemeSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThemeSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThemeSetting model
   */
  interface ThemeSettingFieldRefs {
    readonly id: FieldRef<"ThemeSetting", 'String'>
    readonly name: FieldRef<"ThemeSetting", 'String'>
    readonly category: FieldRef<"ThemeSetting", 'String'>
    readonly value: FieldRef<"ThemeSetting", 'String'>
    readonly cssVariable: FieldRef<"ThemeSetting", 'String'>
    readonly description: FieldRef<"ThemeSetting", 'String'>
    readonly isActive: FieldRef<"ThemeSetting", 'Boolean'>
    readonly createdAt: FieldRef<"ThemeSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"ThemeSetting", 'DateTime'>
    readonly createdById: FieldRef<"ThemeSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ThemeSetting findUnique
   */
  export type ThemeSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * Filter, which ThemeSetting to fetch.
     */
    where: ThemeSettingWhereUniqueInput
  }

  /**
   * ThemeSetting findUniqueOrThrow
   */
  export type ThemeSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * Filter, which ThemeSetting to fetch.
     */
    where: ThemeSettingWhereUniqueInput
  }

  /**
   * ThemeSetting findFirst
   */
  export type ThemeSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * Filter, which ThemeSetting to fetch.
     */
    where?: ThemeSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeSettings to fetch.
     */
    orderBy?: ThemeSettingOrderByWithRelationInput | ThemeSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThemeSettings.
     */
    cursor?: ThemeSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThemeSettings.
     */
    distinct?: ThemeSettingScalarFieldEnum | ThemeSettingScalarFieldEnum[]
  }

  /**
   * ThemeSetting findFirstOrThrow
   */
  export type ThemeSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * Filter, which ThemeSetting to fetch.
     */
    where?: ThemeSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeSettings to fetch.
     */
    orderBy?: ThemeSettingOrderByWithRelationInput | ThemeSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThemeSettings.
     */
    cursor?: ThemeSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThemeSettings.
     */
    distinct?: ThemeSettingScalarFieldEnum | ThemeSettingScalarFieldEnum[]
  }

  /**
   * ThemeSetting findMany
   */
  export type ThemeSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * Filter, which ThemeSettings to fetch.
     */
    where?: ThemeSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeSettings to fetch.
     */
    orderBy?: ThemeSettingOrderByWithRelationInput | ThemeSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThemeSettings.
     */
    cursor?: ThemeSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeSettings.
     */
    skip?: number
    distinct?: ThemeSettingScalarFieldEnum | ThemeSettingScalarFieldEnum[]
  }

  /**
   * ThemeSetting create
   */
  export type ThemeSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a ThemeSetting.
     */
    data: XOR<ThemeSettingCreateInput, ThemeSettingUncheckedCreateInput>
  }

  /**
   * ThemeSetting createMany
   */
  export type ThemeSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThemeSettings.
     */
    data: ThemeSettingCreateManyInput | ThemeSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThemeSetting createManyAndReturn
   */
  export type ThemeSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * The data used to create many ThemeSettings.
     */
    data: ThemeSettingCreateManyInput | ThemeSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThemeSetting update
   */
  export type ThemeSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a ThemeSetting.
     */
    data: XOR<ThemeSettingUpdateInput, ThemeSettingUncheckedUpdateInput>
    /**
     * Choose, which ThemeSetting to update.
     */
    where: ThemeSettingWhereUniqueInput
  }

  /**
   * ThemeSetting updateMany
   */
  export type ThemeSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThemeSettings.
     */
    data: XOR<ThemeSettingUpdateManyMutationInput, ThemeSettingUncheckedUpdateManyInput>
    /**
     * Filter which ThemeSettings to update
     */
    where?: ThemeSettingWhereInput
    /**
     * Limit how many ThemeSettings to update.
     */
    limit?: number
  }

  /**
   * ThemeSetting updateManyAndReturn
   */
  export type ThemeSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * The data used to update ThemeSettings.
     */
    data: XOR<ThemeSettingUpdateManyMutationInput, ThemeSettingUncheckedUpdateManyInput>
    /**
     * Filter which ThemeSettings to update
     */
    where?: ThemeSettingWhereInput
    /**
     * Limit how many ThemeSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThemeSetting upsert
   */
  export type ThemeSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the ThemeSetting to update in case it exists.
     */
    where: ThemeSettingWhereUniqueInput
    /**
     * In case the ThemeSetting found by the `where` argument doesn't exist, create a new ThemeSetting with this data.
     */
    create: XOR<ThemeSettingCreateInput, ThemeSettingUncheckedCreateInput>
    /**
     * In case the ThemeSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeSettingUpdateInput, ThemeSettingUncheckedUpdateInput>
  }

  /**
   * ThemeSetting delete
   */
  export type ThemeSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
    /**
     * Filter which ThemeSetting to delete.
     */
    where: ThemeSettingWhereUniqueInput
  }

  /**
   * ThemeSetting deleteMany
   */
  export type ThemeSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThemeSettings to delete
     */
    where?: ThemeSettingWhereInput
    /**
     * Limit how many ThemeSettings to delete.
     */
    limit?: number
  }

  /**
   * ThemeSetting without action
   */
  export type ThemeSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeSetting
     */
    select?: ThemeSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeSetting
     */
    omit?: ThemeSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeSettingInclude<ExtArgs> | null
  }


  /**
   * Model LivePreviewToken
   */

  export type AggregateLivePreviewToken = {
    _count: LivePreviewTokenCountAggregateOutputType | null
    _min: LivePreviewTokenMinAggregateOutputType | null
    _max: LivePreviewTokenMaxAggregateOutputType | null
  }

  export type LivePreviewTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    page: string | null
    expiresAt: Date | null
    createdAt: Date | null
    createdById: string | null
  }

  export type LivePreviewTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    page: string | null
    expiresAt: Date | null
    createdAt: Date | null
    createdById: string | null
  }

  export type LivePreviewTokenCountAggregateOutputType = {
    id: number
    token: number
    page: number
    changes: number
    expiresAt: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type LivePreviewTokenMinAggregateInputType = {
    id?: true
    token?: true
    page?: true
    expiresAt?: true
    createdAt?: true
    createdById?: true
  }

  export type LivePreviewTokenMaxAggregateInputType = {
    id?: true
    token?: true
    page?: true
    expiresAt?: true
    createdAt?: true
    createdById?: true
  }

  export type LivePreviewTokenCountAggregateInputType = {
    id?: true
    token?: true
    page?: true
    changes?: true
    expiresAt?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type LivePreviewTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LivePreviewToken to aggregate.
     */
    where?: LivePreviewTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePreviewTokens to fetch.
     */
    orderBy?: LivePreviewTokenOrderByWithRelationInput | LivePreviewTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivePreviewTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePreviewTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePreviewTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LivePreviewTokens
    **/
    _count?: true | LivePreviewTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivePreviewTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivePreviewTokenMaxAggregateInputType
  }

  export type GetLivePreviewTokenAggregateType<T extends LivePreviewTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateLivePreviewToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivePreviewToken[P]>
      : GetScalarType<T[P], AggregateLivePreviewToken[P]>
  }




  export type LivePreviewTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivePreviewTokenWhereInput
    orderBy?: LivePreviewTokenOrderByWithAggregationInput | LivePreviewTokenOrderByWithAggregationInput[]
    by: LivePreviewTokenScalarFieldEnum[] | LivePreviewTokenScalarFieldEnum
    having?: LivePreviewTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivePreviewTokenCountAggregateInputType | true
    _min?: LivePreviewTokenMinAggregateInputType
    _max?: LivePreviewTokenMaxAggregateInputType
  }

  export type LivePreviewTokenGroupByOutputType = {
    id: string
    token: string
    page: string
    changes: JsonValue
    expiresAt: Date
    createdAt: Date
    createdById: string
    _count: LivePreviewTokenCountAggregateOutputType | null
    _min: LivePreviewTokenMinAggregateOutputType | null
    _max: LivePreviewTokenMaxAggregateOutputType | null
  }

  type GetLivePreviewTokenGroupByPayload<T extends LivePreviewTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivePreviewTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivePreviewTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivePreviewTokenGroupByOutputType[P]>
            : GetScalarType<T[P], LivePreviewTokenGroupByOutputType[P]>
        }
      >
    >


  export type LivePreviewTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    page?: boolean
    changes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livePreviewToken"]>

  export type LivePreviewTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    page?: boolean
    changes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livePreviewToken"]>

  export type LivePreviewTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    page?: boolean
    changes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdById?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livePreviewToken"]>

  export type LivePreviewTokenSelectScalar = {
    id?: boolean
    token?: boolean
    page?: boolean
    changes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type LivePreviewTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "page" | "changes" | "expiresAt" | "createdAt" | "createdById", ExtArgs["result"]["livePreviewToken"]>
  export type LivePreviewTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LivePreviewTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LivePreviewTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LivePreviewTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LivePreviewToken"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      page: string
      changes: Prisma.JsonValue
      expiresAt: Date
      createdAt: Date
      createdById: string
    }, ExtArgs["result"]["livePreviewToken"]>
    composites: {}
  }

  type LivePreviewTokenGetPayload<S extends boolean | null | undefined | LivePreviewTokenDefaultArgs> = $Result.GetResult<Prisma.$LivePreviewTokenPayload, S>

  type LivePreviewTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivePreviewTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivePreviewTokenCountAggregateInputType | true
    }

  export interface LivePreviewTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LivePreviewToken'], meta: { name: 'LivePreviewToken' } }
    /**
     * Find zero or one LivePreviewToken that matches the filter.
     * @param {LivePreviewTokenFindUniqueArgs} args - Arguments to find a LivePreviewToken
     * @example
     * // Get one LivePreviewToken
     * const livePreviewToken = await prisma.livePreviewToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivePreviewTokenFindUniqueArgs>(args: SelectSubset<T, LivePreviewTokenFindUniqueArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LivePreviewToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivePreviewTokenFindUniqueOrThrowArgs} args - Arguments to find a LivePreviewToken
     * @example
     * // Get one LivePreviewToken
     * const livePreviewToken = await prisma.livePreviewToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivePreviewTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, LivePreviewTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LivePreviewToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenFindFirstArgs} args - Arguments to find a LivePreviewToken
     * @example
     * // Get one LivePreviewToken
     * const livePreviewToken = await prisma.livePreviewToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivePreviewTokenFindFirstArgs>(args?: SelectSubset<T, LivePreviewTokenFindFirstArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LivePreviewToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenFindFirstOrThrowArgs} args - Arguments to find a LivePreviewToken
     * @example
     * // Get one LivePreviewToken
     * const livePreviewToken = await prisma.livePreviewToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivePreviewTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, LivePreviewTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LivePreviewTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LivePreviewTokens
     * const livePreviewTokens = await prisma.livePreviewToken.findMany()
     * 
     * // Get first 10 LivePreviewTokens
     * const livePreviewTokens = await prisma.livePreviewToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const livePreviewTokenWithIdOnly = await prisma.livePreviewToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LivePreviewTokenFindManyArgs>(args?: SelectSubset<T, LivePreviewTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LivePreviewToken.
     * @param {LivePreviewTokenCreateArgs} args - Arguments to create a LivePreviewToken.
     * @example
     * // Create one LivePreviewToken
     * const LivePreviewToken = await prisma.livePreviewToken.create({
     *   data: {
     *     // ... data to create a LivePreviewToken
     *   }
     * })
     * 
     */
    create<T extends LivePreviewTokenCreateArgs>(args: SelectSubset<T, LivePreviewTokenCreateArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LivePreviewTokens.
     * @param {LivePreviewTokenCreateManyArgs} args - Arguments to create many LivePreviewTokens.
     * @example
     * // Create many LivePreviewTokens
     * const livePreviewToken = await prisma.livePreviewToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivePreviewTokenCreateManyArgs>(args?: SelectSubset<T, LivePreviewTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LivePreviewTokens and returns the data saved in the database.
     * @param {LivePreviewTokenCreateManyAndReturnArgs} args - Arguments to create many LivePreviewTokens.
     * @example
     * // Create many LivePreviewTokens
     * const livePreviewToken = await prisma.livePreviewToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LivePreviewTokens and only return the `id`
     * const livePreviewTokenWithIdOnly = await prisma.livePreviewToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LivePreviewTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, LivePreviewTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LivePreviewToken.
     * @param {LivePreviewTokenDeleteArgs} args - Arguments to delete one LivePreviewToken.
     * @example
     * // Delete one LivePreviewToken
     * const LivePreviewToken = await prisma.livePreviewToken.delete({
     *   where: {
     *     // ... filter to delete one LivePreviewToken
     *   }
     * })
     * 
     */
    delete<T extends LivePreviewTokenDeleteArgs>(args: SelectSubset<T, LivePreviewTokenDeleteArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LivePreviewToken.
     * @param {LivePreviewTokenUpdateArgs} args - Arguments to update one LivePreviewToken.
     * @example
     * // Update one LivePreviewToken
     * const livePreviewToken = await prisma.livePreviewToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivePreviewTokenUpdateArgs>(args: SelectSubset<T, LivePreviewTokenUpdateArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LivePreviewTokens.
     * @param {LivePreviewTokenDeleteManyArgs} args - Arguments to filter LivePreviewTokens to delete.
     * @example
     * // Delete a few LivePreviewTokens
     * const { count } = await prisma.livePreviewToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivePreviewTokenDeleteManyArgs>(args?: SelectSubset<T, LivePreviewTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LivePreviewTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LivePreviewTokens
     * const livePreviewToken = await prisma.livePreviewToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivePreviewTokenUpdateManyArgs>(args: SelectSubset<T, LivePreviewTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LivePreviewTokens and returns the data updated in the database.
     * @param {LivePreviewTokenUpdateManyAndReturnArgs} args - Arguments to update many LivePreviewTokens.
     * @example
     * // Update many LivePreviewTokens
     * const livePreviewToken = await prisma.livePreviewToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LivePreviewTokens and only return the `id`
     * const livePreviewTokenWithIdOnly = await prisma.livePreviewToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LivePreviewTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, LivePreviewTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LivePreviewToken.
     * @param {LivePreviewTokenUpsertArgs} args - Arguments to update or create a LivePreviewToken.
     * @example
     * // Update or create a LivePreviewToken
     * const livePreviewToken = await prisma.livePreviewToken.upsert({
     *   create: {
     *     // ... data to create a LivePreviewToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LivePreviewToken we want to update
     *   }
     * })
     */
    upsert<T extends LivePreviewTokenUpsertArgs>(args: SelectSubset<T, LivePreviewTokenUpsertArgs<ExtArgs>>): Prisma__LivePreviewTokenClient<$Result.GetResult<Prisma.$LivePreviewTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LivePreviewTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenCountArgs} args - Arguments to filter LivePreviewTokens to count.
     * @example
     * // Count the number of LivePreviewTokens
     * const count = await prisma.livePreviewToken.count({
     *   where: {
     *     // ... the filter for the LivePreviewTokens we want to count
     *   }
     * })
    **/
    count<T extends LivePreviewTokenCountArgs>(
      args?: Subset<T, LivePreviewTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivePreviewTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LivePreviewToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivePreviewTokenAggregateArgs>(args: Subset<T, LivePreviewTokenAggregateArgs>): Prisma.PrismaPromise<GetLivePreviewTokenAggregateType<T>>

    /**
     * Group by LivePreviewToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePreviewTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivePreviewTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivePreviewTokenGroupByArgs['orderBy'] }
        : { orderBy?: LivePreviewTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivePreviewTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivePreviewTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LivePreviewToken model
   */
  readonly fields: LivePreviewTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LivePreviewToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivePreviewTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LivePreviewToken model
   */
  interface LivePreviewTokenFieldRefs {
    readonly id: FieldRef<"LivePreviewToken", 'String'>
    readonly token: FieldRef<"LivePreviewToken", 'String'>
    readonly page: FieldRef<"LivePreviewToken", 'String'>
    readonly changes: FieldRef<"LivePreviewToken", 'Json'>
    readonly expiresAt: FieldRef<"LivePreviewToken", 'DateTime'>
    readonly createdAt: FieldRef<"LivePreviewToken", 'DateTime'>
    readonly createdById: FieldRef<"LivePreviewToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LivePreviewToken findUnique
   */
  export type LivePreviewTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * Filter, which LivePreviewToken to fetch.
     */
    where: LivePreviewTokenWhereUniqueInput
  }

  /**
   * LivePreviewToken findUniqueOrThrow
   */
  export type LivePreviewTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * Filter, which LivePreviewToken to fetch.
     */
    where: LivePreviewTokenWhereUniqueInput
  }

  /**
   * LivePreviewToken findFirst
   */
  export type LivePreviewTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * Filter, which LivePreviewToken to fetch.
     */
    where?: LivePreviewTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePreviewTokens to fetch.
     */
    orderBy?: LivePreviewTokenOrderByWithRelationInput | LivePreviewTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LivePreviewTokens.
     */
    cursor?: LivePreviewTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePreviewTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePreviewTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LivePreviewTokens.
     */
    distinct?: LivePreviewTokenScalarFieldEnum | LivePreviewTokenScalarFieldEnum[]
  }

  /**
   * LivePreviewToken findFirstOrThrow
   */
  export type LivePreviewTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * Filter, which LivePreviewToken to fetch.
     */
    where?: LivePreviewTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePreviewTokens to fetch.
     */
    orderBy?: LivePreviewTokenOrderByWithRelationInput | LivePreviewTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LivePreviewTokens.
     */
    cursor?: LivePreviewTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePreviewTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePreviewTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LivePreviewTokens.
     */
    distinct?: LivePreviewTokenScalarFieldEnum | LivePreviewTokenScalarFieldEnum[]
  }

  /**
   * LivePreviewToken findMany
   */
  export type LivePreviewTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * Filter, which LivePreviewTokens to fetch.
     */
    where?: LivePreviewTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePreviewTokens to fetch.
     */
    orderBy?: LivePreviewTokenOrderByWithRelationInput | LivePreviewTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LivePreviewTokens.
     */
    cursor?: LivePreviewTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePreviewTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePreviewTokens.
     */
    skip?: number
    distinct?: LivePreviewTokenScalarFieldEnum | LivePreviewTokenScalarFieldEnum[]
  }

  /**
   * LivePreviewToken create
   */
  export type LivePreviewTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a LivePreviewToken.
     */
    data: XOR<LivePreviewTokenCreateInput, LivePreviewTokenUncheckedCreateInput>
  }

  /**
   * LivePreviewToken createMany
   */
  export type LivePreviewTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LivePreviewTokens.
     */
    data: LivePreviewTokenCreateManyInput | LivePreviewTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LivePreviewToken createManyAndReturn
   */
  export type LivePreviewTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * The data used to create many LivePreviewTokens.
     */
    data: LivePreviewTokenCreateManyInput | LivePreviewTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LivePreviewToken update
   */
  export type LivePreviewTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a LivePreviewToken.
     */
    data: XOR<LivePreviewTokenUpdateInput, LivePreviewTokenUncheckedUpdateInput>
    /**
     * Choose, which LivePreviewToken to update.
     */
    where: LivePreviewTokenWhereUniqueInput
  }

  /**
   * LivePreviewToken updateMany
   */
  export type LivePreviewTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LivePreviewTokens.
     */
    data: XOR<LivePreviewTokenUpdateManyMutationInput, LivePreviewTokenUncheckedUpdateManyInput>
    /**
     * Filter which LivePreviewTokens to update
     */
    where?: LivePreviewTokenWhereInput
    /**
     * Limit how many LivePreviewTokens to update.
     */
    limit?: number
  }

  /**
   * LivePreviewToken updateManyAndReturn
   */
  export type LivePreviewTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * The data used to update LivePreviewTokens.
     */
    data: XOR<LivePreviewTokenUpdateManyMutationInput, LivePreviewTokenUncheckedUpdateManyInput>
    /**
     * Filter which LivePreviewTokens to update
     */
    where?: LivePreviewTokenWhereInput
    /**
     * Limit how many LivePreviewTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LivePreviewToken upsert
   */
  export type LivePreviewTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the LivePreviewToken to update in case it exists.
     */
    where: LivePreviewTokenWhereUniqueInput
    /**
     * In case the LivePreviewToken found by the `where` argument doesn't exist, create a new LivePreviewToken with this data.
     */
    create: XOR<LivePreviewTokenCreateInput, LivePreviewTokenUncheckedCreateInput>
    /**
     * In case the LivePreviewToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivePreviewTokenUpdateInput, LivePreviewTokenUncheckedUpdateInput>
  }

  /**
   * LivePreviewToken delete
   */
  export type LivePreviewTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
    /**
     * Filter which LivePreviewToken to delete.
     */
    where: LivePreviewTokenWhereUniqueInput
  }

  /**
   * LivePreviewToken deleteMany
   */
  export type LivePreviewTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LivePreviewTokens to delete
     */
    where?: LivePreviewTokenWhereInput
    /**
     * Limit how many LivePreviewTokens to delete.
     */
    limit?: number
  }

  /**
   * LivePreviewToken without action
   */
  export type LivePreviewTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePreviewToken
     */
    select?: LivePreviewTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePreviewToken
     */
    omit?: LivePreviewTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePreviewTokenInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    resource: string
    resourceId: string | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resource: string
      resourceId: string | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    slug: 'slug',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    coverImage: 'coverImage',
    gallery: 'gallery',
    duration: 'duration',
    level: 'level',
    language: 'language',
    price: 'price',
    currency: 'currency',
    tags: 'tags',
    categories: 'categories',
    status: 'status',
    isFeatured: 'isFeatured',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    order: 'order',
    duration: 'duration',
    resources: 'resources',
    isPreview: 'isPreview',
    courseId: 'courseId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    price: 'price',
    type: 'type',
    features: 'features',
    validityDays: 'validityDays',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const PackageCourseScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    courseId: 'courseId'
  };

  export type PackageCourseScalarFieldEnum = (typeof PackageCourseScalarFieldEnum)[keyof typeof PackageCourseScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    content: 'content',
    featuredImage: 'featuredImage',
    tags: 'tags',
    series: 'series',
    publishDate: 'publishDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    authorId: 'authorId'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    layout: 'layout',
    content: 'content',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    bio: 'bio',
    avatar: 'avatar',
    socialLinks: 'socialLinks',
    profileUrl: 'profileUrl',
    userId: 'userId'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    altText: 'altText',
    caption: 'caption',
    variants: 'variants',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const SeoMetaScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    keywords: 'keywords',
    canonical: 'canonical',
    ogTitle: 'ogTitle',
    ogDescription: 'ogDescription',
    ogImage: 'ogImage',
    twitterCard: 'twitterCard',
    noIndex: 'noIndex',
    noFollow: 'noFollow',
    courseId: 'courseId',
    packageId: 'packageId',
    blogPostId: 'blogPostId',
    pageId: 'pageId'
  };

  export type SeoMetaScalarFieldEnum = (typeof SeoMetaScalarFieldEnum)[keyof typeof SeoMetaScalarFieldEnum]


  export const RevisionScalarFieldEnum: {
    id: 'id',
    contentType: 'contentType',
    contentId: 'contentId',
    version: 'version',
    data: 'data',
    status: 'status',
    previewToken: 'previewToken',
    previewExpiresAt: 'previewExpiresAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    createdById: 'createdById',
    reviewedById: 'reviewedById',
    publishedById: 'publishedById',
    reviewNotes: 'reviewNotes'
  };

  export type RevisionScalarFieldEnum = (typeof RevisionScalarFieldEnum)[keyof typeof RevisionScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    data: 'data',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const SnippetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SnippetScalarFieldEnum = (typeof SnippetScalarFieldEnum)[keyof typeof SnippetScalarFieldEnum]


  export const RedirectScalarFieldEnum: {
    id: 'id',
    sourcePath: 'sourcePath',
    targetPath: 'targetPath',
    statusCode: 'statusCode',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type RedirectScalarFieldEnum = (typeof RedirectScalarFieldEnum)[keyof typeof RedirectScalarFieldEnum]


  export const ContentSectionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    order: 'order',
    metadata: 'metadata',
    isVisible: 'isVisible',
    contentType: 'contentType',
    contentId: 'contentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type ContentSectionScalarFieldEnum = (typeof ContentSectionScalarFieldEnum)[keyof typeof ContentSectionScalarFieldEnum]


  export const QuickEditItemScalarFieldEnum: {
    id: 'id',
    key: 'key',
    type: 'type',
    page: 'page',
    component: 'component',
    element: 'element',
    value: 'value',
    defaultValue: 'defaultValue',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type QuickEditItemScalarFieldEnum = (typeof QuickEditItemScalarFieldEnum)[keyof typeof QuickEditItemScalarFieldEnum]


  export const QuickEditRevisionScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    value: 'value',
    changeType: 'changeType',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type QuickEditRevisionScalarFieldEnum = (typeof QuickEditRevisionScalarFieldEnum)[keyof typeof QuickEditRevisionScalarFieldEnum]


  export const ThemeSettingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    value: 'value',
    cssVariable: 'cssVariable',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type ThemeSettingScalarFieldEnum = (typeof ThemeSettingScalarFieldEnum)[keyof typeof ThemeSettingScalarFieldEnum]


  export const LivePreviewTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    page: 'page',
    changes: 'changes',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type LivePreviewTokenScalarFieldEnum = (typeof LivePreviewTokenScalarFieldEnum)[keyof typeof LivePreviewTokenScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CourseLevel'
   */
  export type EnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel'>
    


  /**
   * Reference to a field of type 'CourseLevel[]'
   */
  export type ListEnumCourseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevel[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'ContentStatus[]'
   */
  export type ListEnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus[]'>
    


  /**
   * Reference to a field of type 'PackageType'
   */
  export type EnumPackageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageType'>
    


  /**
   * Reference to a field of type 'PackageType[]'
   */
  export type ListEnumPackageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'RevisionStatus'
   */
  export type EnumRevisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionStatus'>
    


  /**
   * Reference to a field of type 'RevisionStatus[]'
   */
  export type ListEnumRevisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionStatus[]'>
    


  /**
   * Reference to a field of type 'QuickEditType'
   */
  export type EnumQuickEditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuickEditType'>
    


  /**
   * Reference to a field of type 'QuickEditType[]'
   */
  export type ListEnumQuickEditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuickEditType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdCourses?: CourseListRelationFilter
    createdLessons?: LessonListRelationFilter
    createdPackages?: PackageListRelationFilter
    createdBlogPosts?: BlogPostListRelationFilter
    createdPages?: PageListRelationFilter
    createdSections?: ContentSectionListRelationFilter
    authorProfile?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    createdRevisions?: RevisionListRelationFilter
    reviewedRevisions?: RevisionListRelationFilter
    publishedRevisions?: RevisionListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    quickEditItems?: QuickEditItemListRelationFilter
    quickEditRevisions?: QuickEditRevisionListRelationFilter
    themeSettings?: ThemeSettingListRelationFilter
    livePreviewTokens?: LivePreviewTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdCourses?: CourseOrderByRelationAggregateInput
    createdLessons?: LessonOrderByRelationAggregateInput
    createdPackages?: PackageOrderByRelationAggregateInput
    createdBlogPosts?: BlogPostOrderByRelationAggregateInput
    createdPages?: PageOrderByRelationAggregateInput
    createdSections?: ContentSectionOrderByRelationAggregateInput
    authorProfile?: AuthorOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    createdRevisions?: RevisionOrderByRelationAggregateInput
    reviewedRevisions?: RevisionOrderByRelationAggregateInput
    publishedRevisions?: RevisionOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    quickEditItems?: QuickEditItemOrderByRelationAggregateInput
    quickEditRevisions?: QuickEditRevisionOrderByRelationAggregateInput
    themeSettings?: ThemeSettingOrderByRelationAggregateInput
    livePreviewTokens?: LivePreviewTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdCourses?: CourseListRelationFilter
    createdLessons?: LessonListRelationFilter
    createdPackages?: PackageListRelationFilter
    createdBlogPosts?: BlogPostListRelationFilter
    createdPages?: PageListRelationFilter
    createdSections?: ContentSectionListRelationFilter
    authorProfile?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    createdRevisions?: RevisionListRelationFilter
    reviewedRevisions?: RevisionListRelationFilter
    publishedRevisions?: RevisionListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    quickEditItems?: QuickEditItemListRelationFilter
    quickEditRevisions?: QuickEditRevisionListRelationFilter
    themeSettings?: ThemeSettingListRelationFilter
    livePreviewTokens?: LivePreviewTokenListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    subtitle?: StringNullableFilter<"Course"> | string | null
    slug?: StringFilter<"Course"> | string
    shortDescription?: StringNullableFilter<"Course"> | string | null
    longDescription?: StringNullableFilter<"Course"> | string | null
    coverImage?: StringNullableFilter<"Course"> | string | null
    gallery?: StringNullableListFilter<"Course">
    duration?: IntNullableFilter<"Course"> | number | null
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    language?: StringFilter<"Course"> | string
    price?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Course"> | string
    tags?: StringNullableListFilter<"Course">
    categories?: StringNullableListFilter<"Course">
    status?: EnumContentStatusFilter<"Course"> | $Enums.ContentStatus
    isFeatured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdById?: StringFilter<"Course"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    lessons?: LessonListRelationFilter
    packageCourses?: PackageCourseListRelationFilter
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    slug?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    gallery?: SortOrder
    duration?: SortOrderInput | SortOrder
    level?: SortOrder
    language?: SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    tags?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
    packageCourses?: PackageCourseOrderByRelationAggregateInput
    seoMeta?: SeoMetaOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    subtitle?: StringNullableFilter<"Course"> | string | null
    shortDescription?: StringNullableFilter<"Course"> | string | null
    longDescription?: StringNullableFilter<"Course"> | string | null
    coverImage?: StringNullableFilter<"Course"> | string | null
    gallery?: StringNullableListFilter<"Course">
    duration?: IntNullableFilter<"Course"> | number | null
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    language?: StringFilter<"Course"> | string
    price?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Course"> | string
    tags?: StringNullableListFilter<"Course">
    categories?: StringNullableListFilter<"Course">
    status?: EnumContentStatusFilter<"Course"> | $Enums.ContentStatus
    isFeatured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdById?: StringFilter<"Course"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    lessons?: LessonListRelationFilter
    packageCourses?: PackageCourseListRelationFilter
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }, "id" | "slug">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    slug?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    gallery?: SortOrder
    duration?: SortOrderInput | SortOrder
    level?: SortOrder
    language?: SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    tags?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Course"> | string | null
    slug?: StringWithAggregatesFilter<"Course"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Course"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"Course"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Course"> | string | null
    gallery?: StringNullableListFilter<"Course">
    duration?: IntNullableWithAggregatesFilter<"Course"> | number | null
    level?: EnumCourseLevelWithAggregatesFilter<"Course"> | $Enums.CourseLevel
    language?: StringWithAggregatesFilter<"Course"> | string
    price?: DecimalNullableWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Course"> | string
    tags?: StringNullableListFilter<"Course">
    categories?: StringNullableListFilter<"Course">
    status?: EnumContentStatusWithAggregatesFilter<"Course"> | $Enums.ContentStatus
    isFeatured?: BoolWithAggregatesFilter<"Course"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    createdById?: StringWithAggregatesFilter<"Course"> | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    slug?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    order?: IntFilter<"Lesson"> | number
    duration?: IntNullableFilter<"Lesson"> | number | null
    resources?: StringNullableListFilter<"Lesson">
    isPreview?: BoolFilter<"Lesson"> | boolean
    courseId?: StringFilter<"Lesson"> | string
    status?: EnumContentStatusFilter<"Lesson"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    createdById?: StringFilter<"Lesson"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    order?: SortOrder
    duration?: SortOrderInput | SortOrder
    resources?: SortOrder
    isPreview?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_slug?: LessonCourseIdSlugCompoundUniqueInput
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    title?: StringFilter<"Lesson"> | string
    slug?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    order?: IntFilter<"Lesson"> | number
    duration?: IntNullableFilter<"Lesson"> | number | null
    resources?: StringNullableListFilter<"Lesson">
    isPreview?: BoolFilter<"Lesson"> | boolean
    courseId?: StringFilter<"Lesson"> | string
    status?: EnumContentStatusFilter<"Lesson"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    createdById?: StringFilter<"Lesson"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "courseId_slug">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    order?: SortOrder
    duration?: SortOrderInput | SortOrder
    resources?: SortOrder
    isPreview?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    slug?: StringWithAggregatesFilter<"Lesson"> | string
    content?: StringWithAggregatesFilter<"Lesson"> | string
    order?: IntWithAggregatesFilter<"Lesson"> | number
    duration?: IntNullableWithAggregatesFilter<"Lesson"> | number | null
    resources?: StringNullableListFilter<"Lesson">
    isPreview?: BoolWithAggregatesFilter<"Lesson"> | boolean
    courseId?: StringWithAggregatesFilter<"Lesson"> | string
    status?: EnumContentStatusWithAggregatesFilter<"Lesson"> | $Enums.ContentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    createdById?: StringWithAggregatesFilter<"Lesson"> | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: StringFilter<"Package"> | string
    title?: StringFilter<"Package"> | string
    slug?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFilter<"Package"> | $Enums.PackageType
    features?: StringNullableListFilter<"Package">
    validityDays?: IntNullableFilter<"Package"> | number | null
    status?: EnumContentStatusFilter<"Package"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    createdById?: StringFilter<"Package"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    packageCourses?: PackageCourseListRelationFilter
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    type?: SortOrder
    features?: SortOrder
    validityDays?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
    packageCourses?: PackageCourseOrderByRelationAggregateInput
    seoMeta?: SeoMetaOrderByWithRelationInput
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    title?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFilter<"Package"> | $Enums.PackageType
    features?: StringNullableListFilter<"Package">
    validityDays?: IntNullableFilter<"Package"> | number | null
    status?: EnumContentStatusFilter<"Package"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    createdById?: StringFilter<"Package"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    packageCourses?: PackageCourseListRelationFilter
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }, "id" | "slug">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    type?: SortOrder
    features?: SortOrder
    validityDays?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Package"> | string
    title?: StringWithAggregatesFilter<"Package"> | string
    slug?: StringWithAggregatesFilter<"Package"> | string
    description?: StringNullableWithAggregatesFilter<"Package"> | string | null
    price?: DecimalWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeWithAggregatesFilter<"Package"> | $Enums.PackageType
    features?: StringNullableListFilter<"Package">
    validityDays?: IntNullableWithAggregatesFilter<"Package"> | number | null
    status?: EnumContentStatusWithAggregatesFilter<"Package"> | $Enums.ContentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
    createdById?: StringWithAggregatesFilter<"Package"> | string
  }

  export type PackageCourseWhereInput = {
    AND?: PackageCourseWhereInput | PackageCourseWhereInput[]
    OR?: PackageCourseWhereInput[]
    NOT?: PackageCourseWhereInput | PackageCourseWhereInput[]
    id?: StringFilter<"PackageCourse"> | string
    packageId?: StringFilter<"PackageCourse"> | string
    courseId?: StringFilter<"PackageCourse"> | string
    package?: XOR<PackageScalarRelationFilter, PackageWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type PackageCourseOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    courseId?: SortOrder
    package?: PackageOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type PackageCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    packageId_courseId?: PackageCoursePackageIdCourseIdCompoundUniqueInput
    AND?: PackageCourseWhereInput | PackageCourseWhereInput[]
    OR?: PackageCourseWhereInput[]
    NOT?: PackageCourseWhereInput | PackageCourseWhereInput[]
    packageId?: StringFilter<"PackageCourse"> | string
    courseId?: StringFilter<"PackageCourse"> | string
    package?: XOR<PackageScalarRelationFilter, PackageWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "packageId_courseId">

  export type PackageCourseOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    courseId?: SortOrder
    _count?: PackageCourseCountOrderByAggregateInput
    _max?: PackageCourseMaxOrderByAggregateInput
    _min?: PackageCourseMinOrderByAggregateInput
  }

  export type PackageCourseScalarWhereWithAggregatesInput = {
    AND?: PackageCourseScalarWhereWithAggregatesInput | PackageCourseScalarWhereWithAggregatesInput[]
    OR?: PackageCourseScalarWhereWithAggregatesInput[]
    NOT?: PackageCourseScalarWhereWithAggregatesInput | PackageCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackageCourse"> | string
    packageId?: StringWithAggregatesFilter<"PackageCourse"> | string
    courseId?: StringWithAggregatesFilter<"PackageCourse"> | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    featuredImage?: StringNullableFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    series?: StringNullableFilter<"BlogPost"> | string | null
    publishDate?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    status?: EnumContentStatusFilter<"BlogPost"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    createdById?: StringFilter<"BlogPost"> | string
    authorId?: StringNullableFilter<"BlogPost"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    author?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    featuredImage?: SortOrderInput | SortOrder
    tags?: SortOrder
    series?: SortOrderInput | SortOrder
    publishDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    authorId?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    author?: AuthorOrderByWithRelationInput
    seoMeta?: SeoMetaOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    featuredImage?: StringNullableFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    series?: StringNullableFilter<"BlogPost"> | string | null
    publishDate?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    status?: EnumContentStatusFilter<"BlogPost"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    createdById?: StringFilter<"BlogPost"> | string
    authorId?: StringNullableFilter<"BlogPost"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    author?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrder
    featuredImage?: SortOrderInput | SortOrder
    tags?: SortOrder
    series?: SortOrderInput | SortOrder
    publishDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    authorId?: SortOrderInput | SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    featuredImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    series?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    publishDate?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    status?: EnumContentStatusWithAggregatesFilter<"BlogPost"> | $Enums.ContentStatus
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    createdById?: StringWithAggregatesFilter<"BlogPost"> | string
    authorId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    layout?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    status?: EnumContentStatusFilter<"Page"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    createdById?: StringFilter<"Page"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    layout?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
    seoMeta?: SeoMetaOrderByWithRelationInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    title?: StringFilter<"Page"> | string
    layout?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    status?: EnumContentStatusFilter<"Page"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    createdById?: StringFilter<"Page"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    seoMeta?: XOR<SeoMetaNullableScalarRelationFilter, SeoMetaWhereInput> | null
  }, "id" | "slug">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    layout?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Page"> | string
    title?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    layout?: StringWithAggregatesFilter<"Page"> | string
    content?: StringWithAggregatesFilter<"Page"> | string
    status?: EnumContentStatusWithAggregatesFilter<"Page"> | $Enums.ContentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    createdById?: StringWithAggregatesFilter<"Page"> | string
  }

  export type AuthorWhereInput = {
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    id?: StringFilter<"Author"> | string
    name?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    avatar?: StringNullableFilter<"Author"> | string | null
    socialLinks?: JsonNullableFilter<"Author">
    profileUrl?: StringNullableFilter<"Author"> | string | null
    userId?: StringNullableFilter<"Author"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    blogPosts?: BlogPostListRelationFilter
  }

  export type AuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    profileUrl?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
  }

  export type AuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    name?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    avatar?: StringNullableFilter<"Author"> | string | null
    socialLinks?: JsonNullableFilter<"Author">
    profileUrl?: StringNullableFilter<"Author"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    blogPosts?: BlogPostListRelationFilter
  }, "id" | "userId">

  export type AuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    profileUrl?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: AuthorCountOrderByAggregateInput
    _max?: AuthorMaxOrderByAggregateInput
    _min?: AuthorMinOrderByAggregateInput
  }

  export type AuthorScalarWhereWithAggregatesInput = {
    AND?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    OR?: AuthorScalarWhereWithAggregatesInput[]
    NOT?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Author"> | string
    name?: StringWithAggregatesFilter<"Author"> | string
    bio?: StringNullableWithAggregatesFilter<"Author"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Author"> | string | null
    socialLinks?: JsonNullableWithAggregatesFilter<"Author">
    profileUrl?: StringNullableWithAggregatesFilter<"Author"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Author"> | string | null
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    filename?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    url?: StringFilter<"Media"> | string
    altText?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    variants?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    variants?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    filename?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    url?: StringFilter<"Media"> | string
    altText?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    variants?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    variants?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    filename?: StringWithAggregatesFilter<"Media"> | string
    originalName?: StringWithAggregatesFilter<"Media"> | string
    mimeType?: StringWithAggregatesFilter<"Media"> | string
    size?: IntWithAggregatesFilter<"Media"> | number
    url?: StringWithAggregatesFilter<"Media"> | string
    altText?: StringNullableWithAggregatesFilter<"Media"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Media"> | string | null
    variants?: JsonNullableWithAggregatesFilter<"Media">
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type SeoMetaWhereInput = {
    AND?: SeoMetaWhereInput | SeoMetaWhereInput[]
    OR?: SeoMetaWhereInput[]
    NOT?: SeoMetaWhereInput | SeoMetaWhereInput[]
    id?: StringFilter<"SeoMeta"> | string
    title?: StringNullableFilter<"SeoMeta"> | string | null
    description?: StringNullableFilter<"SeoMeta"> | string | null
    keywords?: StringNullableFilter<"SeoMeta"> | string | null
    canonical?: StringNullableFilter<"SeoMeta"> | string | null
    ogTitle?: StringNullableFilter<"SeoMeta"> | string | null
    ogDescription?: StringNullableFilter<"SeoMeta"> | string | null
    ogImage?: StringNullableFilter<"SeoMeta"> | string | null
    twitterCard?: StringNullableFilter<"SeoMeta"> | string | null
    noIndex?: BoolFilter<"SeoMeta"> | boolean
    noFollow?: BoolFilter<"SeoMeta"> | boolean
    courseId?: StringNullableFilter<"SeoMeta"> | string | null
    packageId?: StringNullableFilter<"SeoMeta"> | string | null
    blogPostId?: StringNullableFilter<"SeoMeta"> | string | null
    pageId?: StringNullableFilter<"SeoMeta"> | string | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
    blogPost?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
  }

  export type SeoMetaOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    canonical?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    twitterCard?: SortOrderInput | SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    courseId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    blogPostId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    package?: PackageOrderByWithRelationInput
    blogPost?: BlogPostOrderByWithRelationInput
    page?: PageOrderByWithRelationInput
  }

  export type SeoMetaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId?: string
    packageId?: string
    blogPostId?: string
    pageId?: string
    AND?: SeoMetaWhereInput | SeoMetaWhereInput[]
    OR?: SeoMetaWhereInput[]
    NOT?: SeoMetaWhereInput | SeoMetaWhereInput[]
    title?: StringNullableFilter<"SeoMeta"> | string | null
    description?: StringNullableFilter<"SeoMeta"> | string | null
    keywords?: StringNullableFilter<"SeoMeta"> | string | null
    canonical?: StringNullableFilter<"SeoMeta"> | string | null
    ogTitle?: StringNullableFilter<"SeoMeta"> | string | null
    ogDescription?: StringNullableFilter<"SeoMeta"> | string | null
    ogImage?: StringNullableFilter<"SeoMeta"> | string | null
    twitterCard?: StringNullableFilter<"SeoMeta"> | string | null
    noIndex?: BoolFilter<"SeoMeta"> | boolean
    noFollow?: BoolFilter<"SeoMeta"> | boolean
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
    blogPost?: XOR<BlogPostNullableScalarRelationFilter, BlogPostWhereInput> | null
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
  }, "id" | "courseId" | "packageId" | "blogPostId" | "pageId">

  export type SeoMetaOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    canonical?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    twitterCard?: SortOrderInput | SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    courseId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    blogPostId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    _count?: SeoMetaCountOrderByAggregateInput
    _max?: SeoMetaMaxOrderByAggregateInput
    _min?: SeoMetaMinOrderByAggregateInput
  }

  export type SeoMetaScalarWhereWithAggregatesInput = {
    AND?: SeoMetaScalarWhereWithAggregatesInput | SeoMetaScalarWhereWithAggregatesInput[]
    OR?: SeoMetaScalarWhereWithAggregatesInput[]
    NOT?: SeoMetaScalarWhereWithAggregatesInput | SeoMetaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeoMeta"> | string
    title?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    description?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    canonical?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    ogTitle?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    ogDescription?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    ogImage?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    twitterCard?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    noIndex?: BoolWithAggregatesFilter<"SeoMeta"> | boolean
    noFollow?: BoolWithAggregatesFilter<"SeoMeta"> | boolean
    courseId?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    packageId?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    blogPostId?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
    pageId?: StringNullableWithAggregatesFilter<"SeoMeta"> | string | null
  }

  export type RevisionWhereInput = {
    AND?: RevisionWhereInput | RevisionWhereInput[]
    OR?: RevisionWhereInput[]
    NOT?: RevisionWhereInput | RevisionWhereInput[]
    id?: StringFilter<"Revision"> | string
    contentType?: EnumContentTypeFilter<"Revision"> | $Enums.ContentType
    contentId?: StringFilter<"Revision"> | string
    version?: IntFilter<"Revision"> | number
    data?: JsonFilter<"Revision">
    status?: EnumRevisionStatusFilter<"Revision"> | $Enums.RevisionStatus
    previewToken?: StringNullableFilter<"Revision"> | string | null
    previewExpiresAt?: DateTimeNullableFilter<"Revision"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Revision"> | Date | string | null
    createdAt?: DateTimeFilter<"Revision"> | Date | string
    createdById?: StringFilter<"Revision"> | string
    reviewedById?: StringNullableFilter<"Revision"> | string | null
    publishedById?: StringNullableFilter<"Revision"> | string | null
    reviewNotes?: StringNullableFilter<"Revision"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    publisher?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RevisionOrderByWithRelationInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    status?: SortOrder
    previewToken?: SortOrderInput | SortOrder
    previewExpiresAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    publishedById?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    publisher?: UserOrderByWithRelationInput
  }

  export type RevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    previewToken?: string
    contentType_contentId_version?: RevisionContentTypeContentIdVersionCompoundUniqueInput
    AND?: RevisionWhereInput | RevisionWhereInput[]
    OR?: RevisionWhereInput[]
    NOT?: RevisionWhereInput | RevisionWhereInput[]
    contentType?: EnumContentTypeFilter<"Revision"> | $Enums.ContentType
    contentId?: StringFilter<"Revision"> | string
    version?: IntFilter<"Revision"> | number
    data?: JsonFilter<"Revision">
    status?: EnumRevisionStatusFilter<"Revision"> | $Enums.RevisionStatus
    previewExpiresAt?: DateTimeNullableFilter<"Revision"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Revision"> | Date | string | null
    createdAt?: DateTimeFilter<"Revision"> | Date | string
    createdById?: StringFilter<"Revision"> | string
    reviewedById?: StringNullableFilter<"Revision"> | string | null
    publishedById?: StringNullableFilter<"Revision"> | string | null
    reviewNotes?: StringNullableFilter<"Revision"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    publisher?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "previewToken" | "contentType_contentId_version">

  export type RevisionOrderByWithAggregationInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    status?: SortOrder
    previewToken?: SortOrderInput | SortOrder
    previewExpiresAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    publishedById?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    _count?: RevisionCountOrderByAggregateInput
    _avg?: RevisionAvgOrderByAggregateInput
    _max?: RevisionMaxOrderByAggregateInput
    _min?: RevisionMinOrderByAggregateInput
    _sum?: RevisionSumOrderByAggregateInput
  }

  export type RevisionScalarWhereWithAggregatesInput = {
    AND?: RevisionScalarWhereWithAggregatesInput | RevisionScalarWhereWithAggregatesInput[]
    OR?: RevisionScalarWhereWithAggregatesInput[]
    NOT?: RevisionScalarWhereWithAggregatesInput | RevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Revision"> | string
    contentType?: EnumContentTypeWithAggregatesFilter<"Revision"> | $Enums.ContentType
    contentId?: StringWithAggregatesFilter<"Revision"> | string
    version?: IntWithAggregatesFilter<"Revision"> | number
    data?: JsonWithAggregatesFilter<"Revision">
    status?: EnumRevisionStatusWithAggregatesFilter<"Revision"> | $Enums.RevisionStatus
    previewToken?: StringNullableWithAggregatesFilter<"Revision"> | string | null
    previewExpiresAt?: DateTimeNullableWithAggregatesFilter<"Revision"> | Date | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Revision"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Revision"> | Date | string
    createdById?: StringWithAggregatesFilter<"Revision"> | string
    reviewedById?: StringNullableWithAggregatesFilter<"Revision"> | string | null
    publishedById?: StringNullableWithAggregatesFilter<"Revision"> | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"Revision"> | string | null
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    data?: JsonFilter<"Settings">
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    data?: JsonFilter<"Settings">
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    data?: JsonWithAggregatesFilter<"Settings">
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type SnippetWhereInput = {
    AND?: SnippetWhereInput | SnippetWhereInput[]
    OR?: SnippetWhereInput[]
    NOT?: SnippetWhereInput | SnippetWhereInput[]
    id?: StringFilter<"Snippet"> | string
    name?: StringFilter<"Snippet"> | string
    type?: StringFilter<"Snippet"> | string
    content?: JsonFilter<"Snippet">
    createdAt?: DateTimeFilter<"Snippet"> | Date | string
    updatedAt?: DateTimeFilter<"Snippet"> | Date | string
  }

  export type SnippetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnippetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SnippetWhereInput | SnippetWhereInput[]
    OR?: SnippetWhereInput[]
    NOT?: SnippetWhereInput | SnippetWhereInput[]
    type?: StringFilter<"Snippet"> | string
    content?: JsonFilter<"Snippet">
    createdAt?: DateTimeFilter<"Snippet"> | Date | string
    updatedAt?: DateTimeFilter<"Snippet"> | Date | string
  }, "id" | "name">

  export type SnippetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SnippetCountOrderByAggregateInput
    _max?: SnippetMaxOrderByAggregateInput
    _min?: SnippetMinOrderByAggregateInput
  }

  export type SnippetScalarWhereWithAggregatesInput = {
    AND?: SnippetScalarWhereWithAggregatesInput | SnippetScalarWhereWithAggregatesInput[]
    OR?: SnippetScalarWhereWithAggregatesInput[]
    NOT?: SnippetScalarWhereWithAggregatesInput | SnippetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Snippet"> | string
    name?: StringWithAggregatesFilter<"Snippet"> | string
    type?: StringWithAggregatesFilter<"Snippet"> | string
    content?: JsonWithAggregatesFilter<"Snippet">
    createdAt?: DateTimeWithAggregatesFilter<"Snippet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Snippet"> | Date | string
  }

  export type RedirectWhereInput = {
    AND?: RedirectWhereInput | RedirectWhereInput[]
    OR?: RedirectWhereInput[]
    NOT?: RedirectWhereInput | RedirectWhereInput[]
    id?: StringFilter<"Redirect"> | string
    sourcePath?: StringFilter<"Redirect"> | string
    targetPath?: StringFilter<"Redirect"> | string
    statusCode?: IntFilter<"Redirect"> | number
    isActive?: BoolFilter<"Redirect"> | boolean
    createdAt?: DateTimeFilter<"Redirect"> | Date | string
  }

  export type RedirectOrderByWithRelationInput = {
    id?: SortOrder
    sourcePath?: SortOrder
    targetPath?: SortOrder
    statusCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RedirectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourcePath?: string
    AND?: RedirectWhereInput | RedirectWhereInput[]
    OR?: RedirectWhereInput[]
    NOT?: RedirectWhereInput | RedirectWhereInput[]
    targetPath?: StringFilter<"Redirect"> | string
    statusCode?: IntFilter<"Redirect"> | number
    isActive?: BoolFilter<"Redirect"> | boolean
    createdAt?: DateTimeFilter<"Redirect"> | Date | string
  }, "id" | "sourcePath">

  export type RedirectOrderByWithAggregationInput = {
    id?: SortOrder
    sourcePath?: SortOrder
    targetPath?: SortOrder
    statusCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: RedirectCountOrderByAggregateInput
    _avg?: RedirectAvgOrderByAggregateInput
    _max?: RedirectMaxOrderByAggregateInput
    _min?: RedirectMinOrderByAggregateInput
    _sum?: RedirectSumOrderByAggregateInput
  }

  export type RedirectScalarWhereWithAggregatesInput = {
    AND?: RedirectScalarWhereWithAggregatesInput | RedirectScalarWhereWithAggregatesInput[]
    OR?: RedirectScalarWhereWithAggregatesInput[]
    NOT?: RedirectScalarWhereWithAggregatesInput | RedirectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redirect"> | string
    sourcePath?: StringWithAggregatesFilter<"Redirect"> | string
    targetPath?: StringWithAggregatesFilter<"Redirect"> | string
    statusCode?: IntWithAggregatesFilter<"Redirect"> | number
    isActive?: BoolWithAggregatesFilter<"Redirect"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Redirect"> | Date | string
  }

  export type ContentSectionWhereInput = {
    AND?: ContentSectionWhereInput | ContentSectionWhereInput[]
    OR?: ContentSectionWhereInput[]
    NOT?: ContentSectionWhereInput | ContentSectionWhereInput[]
    id?: StringFilter<"ContentSection"> | string
    type?: StringFilter<"ContentSection"> | string
    content?: JsonFilter<"ContentSection">
    order?: IntFilter<"ContentSection"> | number
    metadata?: JsonNullableFilter<"ContentSection">
    isVisible?: BoolFilter<"ContentSection"> | boolean
    contentType?: EnumContentTypeFilter<"ContentSection"> | $Enums.ContentType
    contentId?: StringFilter<"ContentSection"> | string
    createdAt?: DateTimeFilter<"ContentSection"> | Date | string
    updatedAt?: DateTimeFilter<"ContentSection"> | Date | string
    createdById?: StringFilter<"ContentSection"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContentSectionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type ContentSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentSectionWhereInput | ContentSectionWhereInput[]
    OR?: ContentSectionWhereInput[]
    NOT?: ContentSectionWhereInput | ContentSectionWhereInput[]
    type?: StringFilter<"ContentSection"> | string
    content?: JsonFilter<"ContentSection">
    order?: IntFilter<"ContentSection"> | number
    metadata?: JsonNullableFilter<"ContentSection">
    isVisible?: BoolFilter<"ContentSection"> | boolean
    contentType?: EnumContentTypeFilter<"ContentSection"> | $Enums.ContentType
    contentId?: StringFilter<"ContentSection"> | string
    createdAt?: DateTimeFilter<"ContentSection"> | Date | string
    updatedAt?: DateTimeFilter<"ContentSection"> | Date | string
    createdById?: StringFilter<"ContentSection"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ContentSectionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: ContentSectionCountOrderByAggregateInput
    _avg?: ContentSectionAvgOrderByAggregateInput
    _max?: ContentSectionMaxOrderByAggregateInput
    _min?: ContentSectionMinOrderByAggregateInput
    _sum?: ContentSectionSumOrderByAggregateInput
  }

  export type ContentSectionScalarWhereWithAggregatesInput = {
    AND?: ContentSectionScalarWhereWithAggregatesInput | ContentSectionScalarWhereWithAggregatesInput[]
    OR?: ContentSectionScalarWhereWithAggregatesInput[]
    NOT?: ContentSectionScalarWhereWithAggregatesInput | ContentSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentSection"> | string
    type?: StringWithAggregatesFilter<"ContentSection"> | string
    content?: JsonWithAggregatesFilter<"ContentSection">
    order?: IntWithAggregatesFilter<"ContentSection"> | number
    metadata?: JsonNullableWithAggregatesFilter<"ContentSection">
    isVisible?: BoolWithAggregatesFilter<"ContentSection"> | boolean
    contentType?: EnumContentTypeWithAggregatesFilter<"ContentSection"> | $Enums.ContentType
    contentId?: StringWithAggregatesFilter<"ContentSection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContentSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentSection"> | Date | string
    createdById?: StringWithAggregatesFilter<"ContentSection"> | string
  }

  export type QuickEditItemWhereInput = {
    AND?: QuickEditItemWhereInput | QuickEditItemWhereInput[]
    OR?: QuickEditItemWhereInput[]
    NOT?: QuickEditItemWhereInput | QuickEditItemWhereInput[]
    id?: StringFilter<"QuickEditItem"> | string
    key?: StringFilter<"QuickEditItem"> | string
    type?: EnumQuickEditTypeFilter<"QuickEditItem"> | $Enums.QuickEditType
    page?: StringFilter<"QuickEditItem"> | string
    component?: StringFilter<"QuickEditItem"> | string
    element?: StringFilter<"QuickEditItem"> | string
    value?: StringFilter<"QuickEditItem"> | string
    defaultValue?: StringFilter<"QuickEditItem"> | string
    isActive?: BoolFilter<"QuickEditItem"> | boolean
    metadata?: JsonNullableFilter<"QuickEditItem">
    createdAt?: DateTimeFilter<"QuickEditItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuickEditItem"> | Date | string
    createdById?: StringFilter<"QuickEditItem"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    revisions?: QuickEditRevisionListRelationFilter
  }

  export type QuickEditItemOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    type?: SortOrder
    page?: SortOrder
    component?: SortOrder
    element?: SortOrder
    value?: SortOrder
    defaultValue?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
    revisions?: QuickEditRevisionOrderByRelationAggregateInput
  }

  export type QuickEditItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: QuickEditItemWhereInput | QuickEditItemWhereInput[]
    OR?: QuickEditItemWhereInput[]
    NOT?: QuickEditItemWhereInput | QuickEditItemWhereInput[]
    type?: EnumQuickEditTypeFilter<"QuickEditItem"> | $Enums.QuickEditType
    page?: StringFilter<"QuickEditItem"> | string
    component?: StringFilter<"QuickEditItem"> | string
    element?: StringFilter<"QuickEditItem"> | string
    value?: StringFilter<"QuickEditItem"> | string
    defaultValue?: StringFilter<"QuickEditItem"> | string
    isActive?: BoolFilter<"QuickEditItem"> | boolean
    metadata?: JsonNullableFilter<"QuickEditItem">
    createdAt?: DateTimeFilter<"QuickEditItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuickEditItem"> | Date | string
    createdById?: StringFilter<"QuickEditItem"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    revisions?: QuickEditRevisionListRelationFilter
  }, "id" | "key">

  export type QuickEditItemOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    type?: SortOrder
    page?: SortOrder
    component?: SortOrder
    element?: SortOrder
    value?: SortOrder
    defaultValue?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: QuickEditItemCountOrderByAggregateInput
    _max?: QuickEditItemMaxOrderByAggregateInput
    _min?: QuickEditItemMinOrderByAggregateInput
  }

  export type QuickEditItemScalarWhereWithAggregatesInput = {
    AND?: QuickEditItemScalarWhereWithAggregatesInput | QuickEditItemScalarWhereWithAggregatesInput[]
    OR?: QuickEditItemScalarWhereWithAggregatesInput[]
    NOT?: QuickEditItemScalarWhereWithAggregatesInput | QuickEditItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuickEditItem"> | string
    key?: StringWithAggregatesFilter<"QuickEditItem"> | string
    type?: EnumQuickEditTypeWithAggregatesFilter<"QuickEditItem"> | $Enums.QuickEditType
    page?: StringWithAggregatesFilter<"QuickEditItem"> | string
    component?: StringWithAggregatesFilter<"QuickEditItem"> | string
    element?: StringWithAggregatesFilter<"QuickEditItem"> | string
    value?: StringWithAggregatesFilter<"QuickEditItem"> | string
    defaultValue?: StringWithAggregatesFilter<"QuickEditItem"> | string
    isActive?: BoolWithAggregatesFilter<"QuickEditItem"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"QuickEditItem">
    createdAt?: DateTimeWithAggregatesFilter<"QuickEditItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuickEditItem"> | Date | string
    createdById?: StringWithAggregatesFilter<"QuickEditItem"> | string
  }

  export type QuickEditRevisionWhereInput = {
    AND?: QuickEditRevisionWhereInput | QuickEditRevisionWhereInput[]
    OR?: QuickEditRevisionWhereInput[]
    NOT?: QuickEditRevisionWhereInput | QuickEditRevisionWhereInput[]
    id?: StringFilter<"QuickEditRevision"> | string
    itemId?: StringFilter<"QuickEditRevision"> | string
    value?: StringFilter<"QuickEditRevision"> | string
    changeType?: StringFilter<"QuickEditRevision"> | string
    createdAt?: DateTimeFilter<"QuickEditRevision"> | Date | string
    createdById?: StringFilter<"QuickEditRevision"> | string
    item?: XOR<QuickEditItemScalarRelationFilter, QuickEditItemWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QuickEditRevisionOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    item?: QuickEditItemOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type QuickEditRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuickEditRevisionWhereInput | QuickEditRevisionWhereInput[]
    OR?: QuickEditRevisionWhereInput[]
    NOT?: QuickEditRevisionWhereInput | QuickEditRevisionWhereInput[]
    itemId?: StringFilter<"QuickEditRevision"> | string
    value?: StringFilter<"QuickEditRevision"> | string
    changeType?: StringFilter<"QuickEditRevision"> | string
    createdAt?: DateTimeFilter<"QuickEditRevision"> | Date | string
    createdById?: StringFilter<"QuickEditRevision"> | string
    item?: XOR<QuickEditItemScalarRelationFilter, QuickEditItemWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type QuickEditRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    _count?: QuickEditRevisionCountOrderByAggregateInput
    _max?: QuickEditRevisionMaxOrderByAggregateInput
    _min?: QuickEditRevisionMinOrderByAggregateInput
  }

  export type QuickEditRevisionScalarWhereWithAggregatesInput = {
    AND?: QuickEditRevisionScalarWhereWithAggregatesInput | QuickEditRevisionScalarWhereWithAggregatesInput[]
    OR?: QuickEditRevisionScalarWhereWithAggregatesInput[]
    NOT?: QuickEditRevisionScalarWhereWithAggregatesInput | QuickEditRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuickEditRevision"> | string
    itemId?: StringWithAggregatesFilter<"QuickEditRevision"> | string
    value?: StringWithAggregatesFilter<"QuickEditRevision"> | string
    changeType?: StringWithAggregatesFilter<"QuickEditRevision"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuickEditRevision"> | Date | string
    createdById?: StringWithAggregatesFilter<"QuickEditRevision"> | string
  }

  export type ThemeSettingWhereInput = {
    AND?: ThemeSettingWhereInput | ThemeSettingWhereInput[]
    OR?: ThemeSettingWhereInput[]
    NOT?: ThemeSettingWhereInput | ThemeSettingWhereInput[]
    id?: StringFilter<"ThemeSetting"> | string
    name?: StringFilter<"ThemeSetting"> | string
    category?: StringFilter<"ThemeSetting"> | string
    value?: StringFilter<"ThemeSetting"> | string
    cssVariable?: StringFilter<"ThemeSetting"> | string
    description?: StringNullableFilter<"ThemeSetting"> | string | null
    isActive?: BoolFilter<"ThemeSetting"> | boolean
    createdAt?: DateTimeFilter<"ThemeSetting"> | Date | string
    updatedAt?: DateTimeFilter<"ThemeSetting"> | Date | string
    createdById?: StringFilter<"ThemeSetting"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ThemeSettingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    cssVariable?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type ThemeSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ThemeSettingWhereInput | ThemeSettingWhereInput[]
    OR?: ThemeSettingWhereInput[]
    NOT?: ThemeSettingWhereInput | ThemeSettingWhereInput[]
    category?: StringFilter<"ThemeSetting"> | string
    value?: StringFilter<"ThemeSetting"> | string
    cssVariable?: StringFilter<"ThemeSetting"> | string
    description?: StringNullableFilter<"ThemeSetting"> | string | null
    isActive?: BoolFilter<"ThemeSetting"> | boolean
    createdAt?: DateTimeFilter<"ThemeSetting"> | Date | string
    updatedAt?: DateTimeFilter<"ThemeSetting"> | Date | string
    createdById?: StringFilter<"ThemeSetting"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "name">

  export type ThemeSettingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    cssVariable?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: ThemeSettingCountOrderByAggregateInput
    _max?: ThemeSettingMaxOrderByAggregateInput
    _min?: ThemeSettingMinOrderByAggregateInput
  }

  export type ThemeSettingScalarWhereWithAggregatesInput = {
    AND?: ThemeSettingScalarWhereWithAggregatesInput | ThemeSettingScalarWhereWithAggregatesInput[]
    OR?: ThemeSettingScalarWhereWithAggregatesInput[]
    NOT?: ThemeSettingScalarWhereWithAggregatesInput | ThemeSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThemeSetting"> | string
    name?: StringWithAggregatesFilter<"ThemeSetting"> | string
    category?: StringWithAggregatesFilter<"ThemeSetting"> | string
    value?: StringWithAggregatesFilter<"ThemeSetting"> | string
    cssVariable?: StringWithAggregatesFilter<"ThemeSetting"> | string
    description?: StringNullableWithAggregatesFilter<"ThemeSetting"> | string | null
    isActive?: BoolWithAggregatesFilter<"ThemeSetting"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ThemeSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ThemeSetting"> | Date | string
    createdById?: StringWithAggregatesFilter<"ThemeSetting"> | string
  }

  export type LivePreviewTokenWhereInput = {
    AND?: LivePreviewTokenWhereInput | LivePreviewTokenWhereInput[]
    OR?: LivePreviewTokenWhereInput[]
    NOT?: LivePreviewTokenWhereInput | LivePreviewTokenWhereInput[]
    id?: StringFilter<"LivePreviewToken"> | string
    token?: StringFilter<"LivePreviewToken"> | string
    page?: StringFilter<"LivePreviewToken"> | string
    changes?: JsonFilter<"LivePreviewToken">
    expiresAt?: DateTimeFilter<"LivePreviewToken"> | Date | string
    createdAt?: DateTimeFilter<"LivePreviewToken"> | Date | string
    createdById?: StringFilter<"LivePreviewToken"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LivePreviewTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    page?: SortOrder
    changes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type LivePreviewTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: LivePreviewTokenWhereInput | LivePreviewTokenWhereInput[]
    OR?: LivePreviewTokenWhereInput[]
    NOT?: LivePreviewTokenWhereInput | LivePreviewTokenWhereInput[]
    page?: StringFilter<"LivePreviewToken"> | string
    changes?: JsonFilter<"LivePreviewToken">
    expiresAt?: DateTimeFilter<"LivePreviewToken"> | Date | string
    createdAt?: DateTimeFilter<"LivePreviewToken"> | Date | string
    createdById?: StringFilter<"LivePreviewToken"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type LivePreviewTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    page?: SortOrder
    changes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    _count?: LivePreviewTokenCountOrderByAggregateInput
    _max?: LivePreviewTokenMaxOrderByAggregateInput
    _min?: LivePreviewTokenMinOrderByAggregateInput
  }

  export type LivePreviewTokenScalarWhereWithAggregatesInput = {
    AND?: LivePreviewTokenScalarWhereWithAggregatesInput | LivePreviewTokenScalarWhereWithAggregatesInput[]
    OR?: LivePreviewTokenScalarWhereWithAggregatesInput[]
    NOT?: LivePreviewTokenScalarWhereWithAggregatesInput | LivePreviewTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LivePreviewToken"> | string
    token?: StringWithAggregatesFilter<"LivePreviewToken"> | string
    page?: StringWithAggregatesFilter<"LivePreviewToken"> | string
    changes?: JsonWithAggregatesFilter<"LivePreviewToken">
    expiresAt?: DateTimeWithAggregatesFilter<"LivePreviewToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"LivePreviewToken"> | Date | string
    createdById?: StringWithAggregatesFilter<"LivePreviewToken"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    packageCourses?: PackageCourseCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    packageCourses?: PackageCourseUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLessonsInput
    course: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    courseId: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLessonsNestedInput
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    courseId: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPackagesInput
    packageCourses?: PackageCourseCreateNestedManyWithoutPackageInput
    seoMeta?: SeoMetaCreateNestedOneWithoutPackageInput
  }

  export type PackageUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutPackageInput
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutPackageInput
  }

  export type PackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPackagesNestedInput
    packageCourses?: PackageCourseUpdateManyWithoutPackageNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutPackageNestedInput
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutPackageNestedInput
  }

  export type PackageCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseCreateInput = {
    id?: string
    package: PackageCreateNestedOneWithoutPackageCoursesInput
    course: CourseCreateNestedOneWithoutPackageCoursesInput
  }

  export type PackageCourseUncheckedCreateInput = {
    id?: string
    packageId: string
    courseId: string
  }

  export type PackageCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    package?: PackageUpdateOneRequiredWithoutPackageCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutPackageCoursesNestedInput
  }

  export type PackageCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseCreateManyInput = {
    id?: string
    packageId: string
    courseId: string
  }

  export type PackageCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedBlogPostsInput
    author?: AuthorCreateNestedOneWithoutBlogPostsInput
    seoMeta?: SeoMetaCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    authorId?: string | null
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedBlogPostsNestedInput
    author?: AuthorUpdateOneWithoutBlogPostsNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    authorId?: string | null
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageCreateInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPagesInput
    seoMeta?: SeoMetaCreateNestedOneWithoutPageInput
  }

  export type PageUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPagesNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutPageNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutPageNestedInput
  }

  export type PageCreateManyInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorCreateInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    user?: UserCreateNestedOneWithoutAuthorProfileInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    userId?: string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAuthorProfileNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorCreateManyInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    userId?: string | null
  }

  export type AuthorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    caption?: string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    caption?: string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    altText?: string | null
    caption?: string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoMetaCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    course?: CourseCreateNestedOneWithoutSeoMetaInput
    package?: PackageCreateNestedOneWithoutSeoMetaInput
    blogPost?: BlogPostCreateNestedOneWithoutSeoMetaInput
    page?: PageCreateNestedOneWithoutSeoMetaInput
  }

  export type SeoMetaUncheckedCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    courseId?: string | null
    packageId?: string | null
    blogPostId?: string | null
    pageId?: string | null
  }

  export type SeoMetaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutSeoMetaNestedInput
    package?: PackageUpdateOneWithoutSeoMetaNestedInput
    blogPost?: BlogPostUpdateOneWithoutSeoMetaNestedInput
    page?: PageUpdateOneWithoutSeoMetaNestedInput
  }

  export type SeoMetaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeoMetaCreateManyInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    courseId?: string | null
    packageId?: string | null
    blogPostId?: string | null
    pageId?: string | null
  }

  export type SeoMetaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeoMetaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionCreateInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    reviewNotes?: string | null
    creator: UserCreateNestedOneWithoutCreatedRevisionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedRevisionsInput
    publisher?: UserCreateNestedOneWithoutPublishedRevisionsInput
  }

  export type RevisionUncheckedCreateInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    createdById: string
    reviewedById?: string | null
    publishedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedRevisionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedRevisionsNestedInput
    publisher?: UserUpdateOneWithoutPublishedRevisionsNestedInput
  }

  export type RevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionCreateManyInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    createdById: string
    reviewedById?: string | null
    publishedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnippetCreateInput = {
    id?: string
    name: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnippetUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnippetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnippetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnippetCreateManyInput = {
    id?: string
    name: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnippetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnippetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedirectCreateInput = {
    id?: string
    sourcePath: string
    targetPath: string
    statusCode?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type RedirectUncheckedCreateInput = {
    id?: string
    sourcePath: string
    targetPath: string
    statusCode?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type RedirectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePath?: StringFieldUpdateOperationsInput | string
    targetPath?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedirectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePath?: StringFieldUpdateOperationsInput | string
    targetPath?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedirectCreateManyInput = {
    id?: string
    sourcePath: string
    targetPath: string
    statusCode?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type RedirectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePath?: StringFieldUpdateOperationsInput | string
    targetPath?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedirectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourcePath?: StringFieldUpdateOperationsInput | string
    targetPath?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentSectionCreateInput = {
    id?: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedSectionsInput
  }

  export type ContentSectionUncheckedCreateInput = {
    id?: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type ContentSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedSectionsNestedInput
  }

  export type ContentSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ContentSectionCreateManyInput = {
    id?: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type ContentSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QuickEditItemCreateInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutQuickEditItemsInput
    revisions?: QuickEditRevisionCreateNestedManyWithoutItemInput
  }

  export type QuickEditItemUncheckedCreateInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    revisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutItemInput
  }

  export type QuickEditItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutQuickEditItemsNestedInput
    revisions?: QuickEditRevisionUpdateManyWithoutItemNestedInput
  }

  export type QuickEditItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    revisions?: QuickEditRevisionUncheckedUpdateManyWithoutItemNestedInput
  }

  export type QuickEditItemCreateManyInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type QuickEditItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickEditItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QuickEditRevisionCreateInput = {
    id?: string
    value: string
    changeType: string
    createdAt?: Date | string
    item: QuickEditItemCreateNestedOneWithoutRevisionsInput
    creator: UserCreateNestedOneWithoutQuickEditRevisionsInput
  }

  export type QuickEditRevisionUncheckedCreateInput = {
    id?: string
    itemId: string
    value: string
    changeType: string
    createdAt?: Date | string
    createdById: string
  }

  export type QuickEditRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: QuickEditItemUpdateOneRequiredWithoutRevisionsNestedInput
    creator?: UserUpdateOneRequiredWithoutQuickEditRevisionsNestedInput
  }

  export type QuickEditRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QuickEditRevisionCreateManyInput = {
    id?: string
    itemId: string
    value: string
    changeType: string
    createdAt?: Date | string
    createdById: string
  }

  export type QuickEditRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickEditRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeSettingCreateInput = {
    id?: string
    name: string
    category: string
    value: string
    cssVariable: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutThemeSettingsInput
  }

  export type ThemeSettingUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    value: string
    cssVariable: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type ThemeSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutThemeSettingsNestedInput
  }

  export type ThemeSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeSettingCreateManyInput = {
    id?: string
    name: string
    category: string
    value: string
    cssVariable: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type ThemeSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LivePreviewTokenCreateInput = {
    id?: string
    token: string
    page: string
    changes: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutLivePreviewTokensInput
  }

  export type LivePreviewTokenUncheckedCreateInput = {
    id?: string
    token: string
    page: string
    changes: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
    createdById: string
  }

  export type LivePreviewTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutLivePreviewTokensNestedInput
  }

  export type LivePreviewTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LivePreviewTokenCreateManyInput = {
    id?: string
    token: string
    page: string
    changes: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
    createdById: string
  }

  export type LivePreviewTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivePreviewTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type PackageListRelationFilter = {
    every?: PackageWhereInput
    some?: PackageWhereInput
    none?: PackageWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type ContentSectionListRelationFilter = {
    every?: ContentSectionWhereInput
    some?: ContentSectionWhereInput
    none?: ContentSectionWhereInput
  }

  export type AuthorNullableScalarRelationFilter = {
    is?: AuthorWhereInput | null
    isNot?: AuthorWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type RevisionListRelationFilter = {
    every?: RevisionWhereInput
    some?: RevisionWhereInput
    none?: RevisionWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type QuickEditItemListRelationFilter = {
    every?: QuickEditItemWhereInput
    some?: QuickEditItemWhereInput
    none?: QuickEditItemWhereInput
  }

  export type QuickEditRevisionListRelationFilter = {
    every?: QuickEditRevisionWhereInput
    some?: QuickEditRevisionWhereInput
    none?: QuickEditRevisionWhereInput
  }

  export type ThemeSettingListRelationFilter = {
    every?: ThemeSettingWhereInput
    some?: ThemeSettingWhereInput
    none?: ThemeSettingWhereInput
  }

  export type LivePreviewTokenListRelationFilter = {
    every?: LivePreviewTokenWhereInput
    some?: LivePreviewTokenWhereInput
    none?: LivePreviewTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuickEditItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuickEditRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThemeSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivePreviewTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type PackageCourseListRelationFilter = {
    every?: PackageCourseWhereInput
    some?: PackageCourseWhereInput
    none?: PackageCourseWhereInput
  }

  export type SeoMetaNullableScalarRelationFilter = {
    is?: SeoMetaWhereInput | null
    isNot?: SeoMetaWhereInput | null
  }

  export type PackageCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    coverImage?: SortOrder
    gallery?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    language?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    tags?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    coverImage?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    language?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    coverImage?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    language?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type LessonCourseIdSlugCompoundUniqueInput = {
    courseId: string
    slug: string
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    resources?: SortOrder
    isPreview?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    order?: SortOrder
    duration?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    isPreview?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    isPreview?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    order?: SortOrder
    duration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPackageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeFilter<$PrismaModel> | $Enums.PackageType
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    type?: SortOrder
    features?: SortOrder
    validityDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    price?: SortOrder
    validityDays?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    type?: SortOrder
    validityDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    type?: SortOrder
    validityDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    price?: SortOrder
    validityDays?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPackageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeWithAggregatesFilter<$PrismaModel> | $Enums.PackageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackageTypeFilter<$PrismaModel>
    _max?: NestedEnumPackageTypeFilter<$PrismaModel>
  }

  export type PackageScalarRelationFilter = {
    is?: PackageWhereInput
    isNot?: PackageWhereInput
  }

  export type PackageCoursePackageIdCourseIdCompoundUniqueInput = {
    packageId: string
    courseId: string
  }

  export type PackageCourseCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    courseId?: SortOrder
  }

  export type PackageCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    courseId?: SortOrder
  }

  export type PackageCourseMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    courseId?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    tags?: SortOrder
    series?: SortOrder
    publishDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    authorId?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    series?: SortOrder
    publishDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    authorId?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    series?: SortOrder
    publishDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    authorId?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    layout?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    layout?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    layout?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    socialLinks?: SortOrder
    profileUrl?: SortOrder
    userId?: SortOrder
  }

  export type AuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    profileUrl?: SortOrder
    userId?: SortOrder
  }

  export type AuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    profileUrl?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    caption?: SortOrder
    variants?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type PackageNullableScalarRelationFilter = {
    is?: PackageWhereInput | null
    isNot?: PackageWhereInput | null
  }

  export type BlogPostNullableScalarRelationFilter = {
    is?: BlogPostWhereInput | null
    isNot?: BlogPostWhereInput | null
  }

  export type PageNullableScalarRelationFilter = {
    is?: PageWhereInput | null
    isNot?: PageWhereInput | null
  }

  export type SeoMetaCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    canonical?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    twitterCard?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    courseId?: SortOrder
    packageId?: SortOrder
    blogPostId?: SortOrder
    pageId?: SortOrder
  }

  export type SeoMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    canonical?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    twitterCard?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    courseId?: SortOrder
    packageId?: SortOrder
    blogPostId?: SortOrder
    pageId?: SortOrder
  }

  export type SeoMetaMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    canonical?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    twitterCard?: SortOrder
    noIndex?: SortOrder
    noFollow?: SortOrder
    courseId?: SortOrder
    packageId?: SortOrder
    blogPostId?: SortOrder
    pageId?: SortOrder
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumRevisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusFilter<$PrismaModel> | $Enums.RevisionStatus
  }

  export type RevisionContentTypeContentIdVersionCompoundUniqueInput = {
    contentType: $Enums.ContentType
    contentId: string
    version: number
  }

  export type RevisionCountOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    status?: SortOrder
    previewToken?: SortOrder
    previewExpiresAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    reviewedById?: SortOrder
    publishedById?: SortOrder
    reviewNotes?: SortOrder
  }

  export type RevisionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type RevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    previewToken?: SortOrder
    previewExpiresAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    reviewedById?: SortOrder
    publishedById?: SortOrder
    reviewNotes?: SortOrder
  }

  export type RevisionMinOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    previewToken?: SortOrder
    previewExpiresAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    reviewedById?: SortOrder
    publishedById?: SortOrder
    reviewNotes?: SortOrder
  }

  export type RevisionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRevisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RevisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRevisionStatusFilter<$PrismaModel>
    _max?: NestedEnumRevisionStatusFilter<$PrismaModel>
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnippetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnippetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SnippetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedirectCountOrderByAggregateInput = {
    id?: SortOrder
    sourcePath?: SortOrder
    targetPath?: SortOrder
    statusCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RedirectAvgOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type RedirectMaxOrderByAggregateInput = {
    id?: SortOrder
    sourcePath?: SortOrder
    targetPath?: SortOrder
    statusCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RedirectMinOrderByAggregateInput = {
    id?: SortOrder
    sourcePath?: SortOrder
    targetPath?: SortOrder
    statusCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type RedirectSumOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type ContentSectionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    metadata?: SortOrder
    isVisible?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContentSectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    isVisible?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContentSectionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    isVisible?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContentSectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumQuickEditTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuickEditType | EnumQuickEditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuickEditTypeFilter<$PrismaModel> | $Enums.QuickEditType
  }

  export type QuickEditItemCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    type?: SortOrder
    page?: SortOrder
    component?: SortOrder
    element?: SortOrder
    value?: SortOrder
    defaultValue?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type QuickEditItemMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    type?: SortOrder
    page?: SortOrder
    component?: SortOrder
    element?: SortOrder
    value?: SortOrder
    defaultValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type QuickEditItemMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    type?: SortOrder
    page?: SortOrder
    component?: SortOrder
    element?: SortOrder
    value?: SortOrder
    defaultValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumQuickEditTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuickEditType | EnumQuickEditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuickEditTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuickEditType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuickEditTypeFilter<$PrismaModel>
    _max?: NestedEnumQuickEditTypeFilter<$PrismaModel>
  }

  export type QuickEditItemScalarRelationFilter = {
    is?: QuickEditItemWhereInput
    isNot?: QuickEditItemWhereInput
  }

  export type QuickEditRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type QuickEditRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type QuickEditRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type ThemeSettingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    cssVariable?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ThemeSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    cssVariable?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ThemeSettingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    value?: SortOrder
    cssVariable?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type LivePreviewTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    page?: SortOrder
    changes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type LivePreviewTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    page?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type LivePreviewTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    page?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput> | LessonCreateWithoutCreatorInput[] | LessonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCreatorInput | LessonCreateOrConnectWithoutCreatorInput[]
    createMany?: LessonCreateManyCreatorInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PackageCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PackageCreateWithoutCreatorInput, PackageUncheckedCreateWithoutCreatorInput> | PackageCreateWithoutCreatorInput[] | PackageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCreatorInput | PackageCreateOrConnectWithoutCreatorInput[]
    createMany?: PackageCreateManyCreatorInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutCreatorInput = {
    create?: XOR<BlogPostCreateWithoutCreatorInput, BlogPostUncheckedCreateWithoutCreatorInput> | BlogPostCreateWithoutCreatorInput[] | BlogPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCreatorInput | BlogPostCreateOrConnectWithoutCreatorInput[]
    createMany?: BlogPostCreateManyCreatorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type ContentSectionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContentSectionCreateWithoutCreatorInput, ContentSectionUncheckedCreateWithoutCreatorInput> | ContentSectionCreateWithoutCreatorInput[] | ContentSectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentSectionCreateOrConnectWithoutCreatorInput | ContentSectionCreateOrConnectWithoutCreatorInput[]
    createMany?: ContentSectionCreateManyCreatorInputEnvelope
    connect?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
  }

  export type AuthorCreateNestedOneWithoutUserInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    connect?: AuthorWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type RevisionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RevisionCreateWithoutCreatorInput, RevisionUncheckedCreateWithoutCreatorInput> | RevisionCreateWithoutCreatorInput[] | RevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutCreatorInput | RevisionCreateOrConnectWithoutCreatorInput[]
    createMany?: RevisionCreateManyCreatorInputEnvelope
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
  }

  export type RevisionCreateNestedManyWithoutReviewerInput = {
    create?: XOR<RevisionCreateWithoutReviewerInput, RevisionUncheckedCreateWithoutReviewerInput> | RevisionCreateWithoutReviewerInput[] | RevisionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutReviewerInput | RevisionCreateOrConnectWithoutReviewerInput[]
    createMany?: RevisionCreateManyReviewerInputEnvelope
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
  }

  export type RevisionCreateNestedManyWithoutPublisherInput = {
    create?: XOR<RevisionCreateWithoutPublisherInput, RevisionUncheckedCreateWithoutPublisherInput> | RevisionCreateWithoutPublisherInput[] | RevisionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutPublisherInput | RevisionCreateOrConnectWithoutPublisherInput[]
    createMany?: RevisionCreateManyPublisherInputEnvelope
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type QuickEditItemCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuickEditItemCreateWithoutCreatorInput, QuickEditItemUncheckedCreateWithoutCreatorInput> | QuickEditItemCreateWithoutCreatorInput[] | QuickEditItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditItemCreateOrConnectWithoutCreatorInput | QuickEditItemCreateOrConnectWithoutCreatorInput[]
    createMany?: QuickEditItemCreateManyCreatorInputEnvelope
    connect?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
  }

  export type QuickEditRevisionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuickEditRevisionCreateWithoutCreatorInput, QuickEditRevisionUncheckedCreateWithoutCreatorInput> | QuickEditRevisionCreateWithoutCreatorInput[] | QuickEditRevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutCreatorInput | QuickEditRevisionCreateOrConnectWithoutCreatorInput[]
    createMany?: QuickEditRevisionCreateManyCreatorInputEnvelope
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
  }

  export type ThemeSettingCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ThemeSettingCreateWithoutCreatorInput, ThemeSettingUncheckedCreateWithoutCreatorInput> | ThemeSettingCreateWithoutCreatorInput[] | ThemeSettingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeSettingCreateOrConnectWithoutCreatorInput | ThemeSettingCreateOrConnectWithoutCreatorInput[]
    createMany?: ThemeSettingCreateManyCreatorInputEnvelope
    connect?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
  }

  export type LivePreviewTokenCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LivePreviewTokenCreateWithoutCreatorInput, LivePreviewTokenUncheckedCreateWithoutCreatorInput> | LivePreviewTokenCreateWithoutCreatorInput[] | LivePreviewTokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LivePreviewTokenCreateOrConnectWithoutCreatorInput | LivePreviewTokenCreateOrConnectWithoutCreatorInput[]
    createMany?: LivePreviewTokenCreateManyCreatorInputEnvelope
    connect?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput> | LessonCreateWithoutCreatorInput[] | LessonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCreatorInput | LessonCreateOrConnectWithoutCreatorInput[]
    createMany?: LessonCreateManyCreatorInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PackageUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PackageCreateWithoutCreatorInput, PackageUncheckedCreateWithoutCreatorInput> | PackageCreateWithoutCreatorInput[] | PackageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCreatorInput | PackageCreateOrConnectWithoutCreatorInput[]
    createMany?: PackageCreateManyCreatorInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<BlogPostCreateWithoutCreatorInput, BlogPostUncheckedCreateWithoutCreatorInput> | BlogPostCreateWithoutCreatorInput[] | BlogPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCreatorInput | BlogPostCreateOrConnectWithoutCreatorInput[]
    createMany?: BlogPostCreateManyCreatorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type ContentSectionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContentSectionCreateWithoutCreatorInput, ContentSectionUncheckedCreateWithoutCreatorInput> | ContentSectionCreateWithoutCreatorInput[] | ContentSectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentSectionCreateOrConnectWithoutCreatorInput | ContentSectionCreateOrConnectWithoutCreatorInput[]
    createMany?: ContentSectionCreateManyCreatorInputEnvelope
    connect?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
  }

  export type AuthorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    connect?: AuthorWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type RevisionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RevisionCreateWithoutCreatorInput, RevisionUncheckedCreateWithoutCreatorInput> | RevisionCreateWithoutCreatorInput[] | RevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutCreatorInput | RevisionCreateOrConnectWithoutCreatorInput[]
    createMany?: RevisionCreateManyCreatorInputEnvelope
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
  }

  export type RevisionUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<RevisionCreateWithoutReviewerInput, RevisionUncheckedCreateWithoutReviewerInput> | RevisionCreateWithoutReviewerInput[] | RevisionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutReviewerInput | RevisionCreateOrConnectWithoutReviewerInput[]
    createMany?: RevisionCreateManyReviewerInputEnvelope
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
  }

  export type RevisionUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<RevisionCreateWithoutPublisherInput, RevisionUncheckedCreateWithoutPublisherInput> | RevisionCreateWithoutPublisherInput[] | RevisionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutPublisherInput | RevisionCreateOrConnectWithoutPublisherInput[]
    createMany?: RevisionCreateManyPublisherInputEnvelope
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuickEditItemCreateWithoutCreatorInput, QuickEditItemUncheckedCreateWithoutCreatorInput> | QuickEditItemCreateWithoutCreatorInput[] | QuickEditItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditItemCreateOrConnectWithoutCreatorInput | QuickEditItemCreateOrConnectWithoutCreatorInput[]
    createMany?: QuickEditItemCreateManyCreatorInputEnvelope
    connect?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
  }

  export type QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuickEditRevisionCreateWithoutCreatorInput, QuickEditRevisionUncheckedCreateWithoutCreatorInput> | QuickEditRevisionCreateWithoutCreatorInput[] | QuickEditRevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutCreatorInput | QuickEditRevisionCreateOrConnectWithoutCreatorInput[]
    createMany?: QuickEditRevisionCreateManyCreatorInputEnvelope
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
  }

  export type ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ThemeSettingCreateWithoutCreatorInput, ThemeSettingUncheckedCreateWithoutCreatorInput> | ThemeSettingCreateWithoutCreatorInput[] | ThemeSettingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeSettingCreateOrConnectWithoutCreatorInput | ThemeSettingCreateOrConnectWithoutCreatorInput[]
    createMany?: ThemeSettingCreateManyCreatorInputEnvelope
    connect?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
  }

  export type LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LivePreviewTokenCreateWithoutCreatorInput, LivePreviewTokenUncheckedCreateWithoutCreatorInput> | LivePreviewTokenCreateWithoutCreatorInput[] | LivePreviewTokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LivePreviewTokenCreateOrConnectWithoutCreatorInput | LivePreviewTokenCreateOrConnectWithoutCreatorInput[]
    createMany?: LivePreviewTokenCreateManyCreatorInputEnvelope
    connect?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput> | LessonCreateWithoutCreatorInput[] | LessonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCreatorInput | LessonCreateOrConnectWithoutCreatorInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCreatorInput | LessonUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LessonCreateManyCreatorInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCreatorInput | LessonUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCreatorInput | LessonUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PackageUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PackageCreateWithoutCreatorInput, PackageUncheckedCreateWithoutCreatorInput> | PackageCreateWithoutCreatorInput[] | PackageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCreatorInput | PackageCreateOrConnectWithoutCreatorInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutCreatorInput | PackageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PackageCreateManyCreatorInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutCreatorInput | PackageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutCreatorInput | PackageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<BlogPostCreateWithoutCreatorInput, BlogPostUncheckedCreateWithoutCreatorInput> | BlogPostCreateWithoutCreatorInput[] | BlogPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCreatorInput | BlogPostCreateOrConnectWithoutCreatorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCreatorInput | BlogPostUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: BlogPostCreateManyCreatorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCreatorInput | BlogPostUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCreatorInput | BlogPostUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type PageUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutCreatorInput | PageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutCreatorInput | PageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PageUpdateManyWithWhereWithoutCreatorInput | PageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type ContentSectionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContentSectionCreateWithoutCreatorInput, ContentSectionUncheckedCreateWithoutCreatorInput> | ContentSectionCreateWithoutCreatorInput[] | ContentSectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentSectionCreateOrConnectWithoutCreatorInput | ContentSectionCreateOrConnectWithoutCreatorInput[]
    upsert?: ContentSectionUpsertWithWhereUniqueWithoutCreatorInput | ContentSectionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContentSectionCreateManyCreatorInputEnvelope
    set?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    disconnect?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    delete?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    connect?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    update?: ContentSectionUpdateWithWhereUniqueWithoutCreatorInput | ContentSectionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContentSectionUpdateManyWithWhereWithoutCreatorInput | ContentSectionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContentSectionScalarWhereInput | ContentSectionScalarWhereInput[]
  }

  export type AuthorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    upsert?: AuthorUpsertWithoutUserInput
    disconnect?: AuthorWhereInput | boolean
    delete?: AuthorWhereInput | boolean
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutUserInput, AuthorUpdateWithoutUserInput>, AuthorUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type RevisionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RevisionCreateWithoutCreatorInput, RevisionUncheckedCreateWithoutCreatorInput> | RevisionCreateWithoutCreatorInput[] | RevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutCreatorInput | RevisionCreateOrConnectWithoutCreatorInput[]
    upsert?: RevisionUpsertWithWhereUniqueWithoutCreatorInput | RevisionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RevisionCreateManyCreatorInputEnvelope
    set?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    disconnect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    delete?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    update?: RevisionUpdateWithWhereUniqueWithoutCreatorInput | RevisionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RevisionUpdateManyWithWhereWithoutCreatorInput | RevisionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
  }

  export type RevisionUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<RevisionCreateWithoutReviewerInput, RevisionUncheckedCreateWithoutReviewerInput> | RevisionCreateWithoutReviewerInput[] | RevisionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutReviewerInput | RevisionCreateOrConnectWithoutReviewerInput[]
    upsert?: RevisionUpsertWithWhereUniqueWithoutReviewerInput | RevisionUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: RevisionCreateManyReviewerInputEnvelope
    set?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    disconnect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    delete?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    update?: RevisionUpdateWithWhereUniqueWithoutReviewerInput | RevisionUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: RevisionUpdateManyWithWhereWithoutReviewerInput | RevisionUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
  }

  export type RevisionUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<RevisionCreateWithoutPublisherInput, RevisionUncheckedCreateWithoutPublisherInput> | RevisionCreateWithoutPublisherInput[] | RevisionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutPublisherInput | RevisionCreateOrConnectWithoutPublisherInput[]
    upsert?: RevisionUpsertWithWhereUniqueWithoutPublisherInput | RevisionUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: RevisionCreateManyPublisherInputEnvelope
    set?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    disconnect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    delete?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    update?: RevisionUpdateWithWhereUniqueWithoutPublisherInput | RevisionUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: RevisionUpdateManyWithWhereWithoutPublisherInput | RevisionUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type QuickEditItemUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuickEditItemCreateWithoutCreatorInput, QuickEditItemUncheckedCreateWithoutCreatorInput> | QuickEditItemCreateWithoutCreatorInput[] | QuickEditItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditItemCreateOrConnectWithoutCreatorInput | QuickEditItemCreateOrConnectWithoutCreatorInput[]
    upsert?: QuickEditItemUpsertWithWhereUniqueWithoutCreatorInput | QuickEditItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuickEditItemCreateManyCreatorInputEnvelope
    set?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    disconnect?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    delete?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    connect?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    update?: QuickEditItemUpdateWithWhereUniqueWithoutCreatorInput | QuickEditItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuickEditItemUpdateManyWithWhereWithoutCreatorInput | QuickEditItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuickEditItemScalarWhereInput | QuickEditItemScalarWhereInput[]
  }

  export type QuickEditRevisionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuickEditRevisionCreateWithoutCreatorInput, QuickEditRevisionUncheckedCreateWithoutCreatorInput> | QuickEditRevisionCreateWithoutCreatorInput[] | QuickEditRevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutCreatorInput | QuickEditRevisionCreateOrConnectWithoutCreatorInput[]
    upsert?: QuickEditRevisionUpsertWithWhereUniqueWithoutCreatorInput | QuickEditRevisionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuickEditRevisionCreateManyCreatorInputEnvelope
    set?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    disconnect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    delete?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    update?: QuickEditRevisionUpdateWithWhereUniqueWithoutCreatorInput | QuickEditRevisionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuickEditRevisionUpdateManyWithWhereWithoutCreatorInput | QuickEditRevisionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuickEditRevisionScalarWhereInput | QuickEditRevisionScalarWhereInput[]
  }

  export type ThemeSettingUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ThemeSettingCreateWithoutCreatorInput, ThemeSettingUncheckedCreateWithoutCreatorInput> | ThemeSettingCreateWithoutCreatorInput[] | ThemeSettingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeSettingCreateOrConnectWithoutCreatorInput | ThemeSettingCreateOrConnectWithoutCreatorInput[]
    upsert?: ThemeSettingUpsertWithWhereUniqueWithoutCreatorInput | ThemeSettingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ThemeSettingCreateManyCreatorInputEnvelope
    set?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    disconnect?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    delete?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    connect?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    update?: ThemeSettingUpdateWithWhereUniqueWithoutCreatorInput | ThemeSettingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ThemeSettingUpdateManyWithWhereWithoutCreatorInput | ThemeSettingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ThemeSettingScalarWhereInput | ThemeSettingScalarWhereInput[]
  }

  export type LivePreviewTokenUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LivePreviewTokenCreateWithoutCreatorInput, LivePreviewTokenUncheckedCreateWithoutCreatorInput> | LivePreviewTokenCreateWithoutCreatorInput[] | LivePreviewTokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LivePreviewTokenCreateOrConnectWithoutCreatorInput | LivePreviewTokenCreateOrConnectWithoutCreatorInput[]
    upsert?: LivePreviewTokenUpsertWithWhereUniqueWithoutCreatorInput | LivePreviewTokenUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LivePreviewTokenCreateManyCreatorInputEnvelope
    set?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    disconnect?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    delete?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    connect?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    update?: LivePreviewTokenUpdateWithWhereUniqueWithoutCreatorInput | LivePreviewTokenUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LivePreviewTokenUpdateManyWithWhereWithoutCreatorInput | LivePreviewTokenUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LivePreviewTokenScalarWhereInput | LivePreviewTokenScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput> | LessonCreateWithoutCreatorInput[] | LessonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCreatorInput | LessonCreateOrConnectWithoutCreatorInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCreatorInput | LessonUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LessonCreateManyCreatorInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCreatorInput | LessonUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCreatorInput | LessonUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PackageUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PackageCreateWithoutCreatorInput, PackageUncheckedCreateWithoutCreatorInput> | PackageCreateWithoutCreatorInput[] | PackageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCreatorInput | PackageCreateOrConnectWithoutCreatorInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutCreatorInput | PackageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PackageCreateManyCreatorInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutCreatorInput | PackageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutCreatorInput | PackageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<BlogPostCreateWithoutCreatorInput, BlogPostUncheckedCreateWithoutCreatorInput> | BlogPostCreateWithoutCreatorInput[] | BlogPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCreatorInput | BlogPostCreateOrConnectWithoutCreatorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCreatorInput | BlogPostUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: BlogPostCreateManyCreatorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCreatorInput | BlogPostUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCreatorInput | BlogPostUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutCreatorInput | PageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutCreatorInput | PageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PageUpdateManyWithWhereWithoutCreatorInput | PageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContentSectionCreateWithoutCreatorInput, ContentSectionUncheckedCreateWithoutCreatorInput> | ContentSectionCreateWithoutCreatorInput[] | ContentSectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentSectionCreateOrConnectWithoutCreatorInput | ContentSectionCreateOrConnectWithoutCreatorInput[]
    upsert?: ContentSectionUpsertWithWhereUniqueWithoutCreatorInput | ContentSectionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContentSectionCreateManyCreatorInputEnvelope
    set?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    disconnect?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    delete?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    connect?: ContentSectionWhereUniqueInput | ContentSectionWhereUniqueInput[]
    update?: ContentSectionUpdateWithWhereUniqueWithoutCreatorInput | ContentSectionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContentSectionUpdateManyWithWhereWithoutCreatorInput | ContentSectionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContentSectionScalarWhereInput | ContentSectionScalarWhereInput[]
  }

  export type AuthorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    upsert?: AuthorUpsertWithoutUserInput
    disconnect?: AuthorWhereInput | boolean
    delete?: AuthorWhereInput | boolean
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutUserInput, AuthorUpdateWithoutUserInput>, AuthorUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type RevisionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RevisionCreateWithoutCreatorInput, RevisionUncheckedCreateWithoutCreatorInput> | RevisionCreateWithoutCreatorInput[] | RevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutCreatorInput | RevisionCreateOrConnectWithoutCreatorInput[]
    upsert?: RevisionUpsertWithWhereUniqueWithoutCreatorInput | RevisionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RevisionCreateManyCreatorInputEnvelope
    set?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    disconnect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    delete?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    update?: RevisionUpdateWithWhereUniqueWithoutCreatorInput | RevisionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RevisionUpdateManyWithWhereWithoutCreatorInput | RevisionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
  }

  export type RevisionUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<RevisionCreateWithoutReviewerInput, RevisionUncheckedCreateWithoutReviewerInput> | RevisionCreateWithoutReviewerInput[] | RevisionUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutReviewerInput | RevisionCreateOrConnectWithoutReviewerInput[]
    upsert?: RevisionUpsertWithWhereUniqueWithoutReviewerInput | RevisionUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: RevisionCreateManyReviewerInputEnvelope
    set?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    disconnect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    delete?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    update?: RevisionUpdateWithWhereUniqueWithoutReviewerInput | RevisionUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: RevisionUpdateManyWithWhereWithoutReviewerInput | RevisionUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
  }

  export type RevisionUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<RevisionCreateWithoutPublisherInput, RevisionUncheckedCreateWithoutPublisherInput> | RevisionCreateWithoutPublisherInput[] | RevisionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: RevisionCreateOrConnectWithoutPublisherInput | RevisionCreateOrConnectWithoutPublisherInput[]
    upsert?: RevisionUpsertWithWhereUniqueWithoutPublisherInput | RevisionUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: RevisionCreateManyPublisherInputEnvelope
    set?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    disconnect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    delete?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    connect?: RevisionWhereUniqueInput | RevisionWhereUniqueInput[]
    update?: RevisionUpdateWithWhereUniqueWithoutPublisherInput | RevisionUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: RevisionUpdateManyWithWhereWithoutPublisherInput | RevisionUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuickEditItemCreateWithoutCreatorInput, QuickEditItemUncheckedCreateWithoutCreatorInput> | QuickEditItemCreateWithoutCreatorInput[] | QuickEditItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditItemCreateOrConnectWithoutCreatorInput | QuickEditItemCreateOrConnectWithoutCreatorInput[]
    upsert?: QuickEditItemUpsertWithWhereUniqueWithoutCreatorInput | QuickEditItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuickEditItemCreateManyCreatorInputEnvelope
    set?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    disconnect?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    delete?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    connect?: QuickEditItemWhereUniqueInput | QuickEditItemWhereUniqueInput[]
    update?: QuickEditItemUpdateWithWhereUniqueWithoutCreatorInput | QuickEditItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuickEditItemUpdateManyWithWhereWithoutCreatorInput | QuickEditItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuickEditItemScalarWhereInput | QuickEditItemScalarWhereInput[]
  }

  export type QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuickEditRevisionCreateWithoutCreatorInput, QuickEditRevisionUncheckedCreateWithoutCreatorInput> | QuickEditRevisionCreateWithoutCreatorInput[] | QuickEditRevisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutCreatorInput | QuickEditRevisionCreateOrConnectWithoutCreatorInput[]
    upsert?: QuickEditRevisionUpsertWithWhereUniqueWithoutCreatorInput | QuickEditRevisionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuickEditRevisionCreateManyCreatorInputEnvelope
    set?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    disconnect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    delete?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    update?: QuickEditRevisionUpdateWithWhereUniqueWithoutCreatorInput | QuickEditRevisionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuickEditRevisionUpdateManyWithWhereWithoutCreatorInput | QuickEditRevisionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuickEditRevisionScalarWhereInput | QuickEditRevisionScalarWhereInput[]
  }

  export type ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ThemeSettingCreateWithoutCreatorInput, ThemeSettingUncheckedCreateWithoutCreatorInput> | ThemeSettingCreateWithoutCreatorInput[] | ThemeSettingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeSettingCreateOrConnectWithoutCreatorInput | ThemeSettingCreateOrConnectWithoutCreatorInput[]
    upsert?: ThemeSettingUpsertWithWhereUniqueWithoutCreatorInput | ThemeSettingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ThemeSettingCreateManyCreatorInputEnvelope
    set?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    disconnect?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    delete?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    connect?: ThemeSettingWhereUniqueInput | ThemeSettingWhereUniqueInput[]
    update?: ThemeSettingUpdateWithWhereUniqueWithoutCreatorInput | ThemeSettingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ThemeSettingUpdateManyWithWhereWithoutCreatorInput | ThemeSettingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ThemeSettingScalarWhereInput | ThemeSettingScalarWhereInput[]
  }

  export type LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LivePreviewTokenCreateWithoutCreatorInput, LivePreviewTokenUncheckedCreateWithoutCreatorInput> | LivePreviewTokenCreateWithoutCreatorInput[] | LivePreviewTokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LivePreviewTokenCreateOrConnectWithoutCreatorInput | LivePreviewTokenCreateOrConnectWithoutCreatorInput[]
    upsert?: LivePreviewTokenUpsertWithWhereUniqueWithoutCreatorInput | LivePreviewTokenUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LivePreviewTokenCreateManyCreatorInputEnvelope
    set?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    disconnect?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    delete?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    connect?: LivePreviewTokenWhereUniqueInput | LivePreviewTokenWhereUniqueInput[]
    update?: LivePreviewTokenUpdateWithWhereUniqueWithoutCreatorInput | LivePreviewTokenUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LivePreviewTokenUpdateManyWithWhereWithoutCreatorInput | LivePreviewTokenUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LivePreviewTokenScalarWhereInput | LivePreviewTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type CourseCreategalleryInput = {
    set: string[]
  }

  export type CourseCreatetagsInput = {
    set: string[]
  }

  export type CourseCreatecategoriesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedCoursesInput = {
    create?: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PackageCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<PackageCourseCreateWithoutCourseInput, PackageCourseUncheckedCreateWithoutCourseInput> | PackageCourseCreateWithoutCourseInput[] | PackageCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutCourseInput | PackageCourseCreateOrConnectWithoutCourseInput[]
    createMany?: PackageCourseCreateManyCourseInputEnvelope
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
  }

  export type SeoMetaCreateNestedOneWithoutCourseInput = {
    create?: XOR<SeoMetaCreateWithoutCourseInput, SeoMetaUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutCourseInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type LessonUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PackageCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<PackageCourseCreateWithoutCourseInput, PackageCourseUncheckedCreateWithoutCourseInput> | PackageCourseCreateWithoutCourseInput[] | PackageCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutCourseInput | PackageCourseCreateOrConnectWithoutCourseInput[]
    createMany?: PackageCourseCreateManyCourseInputEnvelope
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
  }

  export type SeoMetaUncheckedCreateNestedOneWithoutCourseInput = {
    create?: XOR<SeoMetaCreateWithoutCourseInput, SeoMetaUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutCourseInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type CourseUpdategalleryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCourseLevelFieldUpdateOperationsInput = {
    set?: $Enums.CourseLevel
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CourseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCoursesInput
    upsert?: UserUpsertWithoutCreatedCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCoursesInput, UserUpdateWithoutCreatedCoursesInput>, UserUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type LessonUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCourseInput | LessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCourseInput | LessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCourseInput | LessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PackageCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PackageCourseCreateWithoutCourseInput, PackageCourseUncheckedCreateWithoutCourseInput> | PackageCourseCreateWithoutCourseInput[] | PackageCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutCourseInput | PackageCourseCreateOrConnectWithoutCourseInput[]
    upsert?: PackageCourseUpsertWithWhereUniqueWithoutCourseInput | PackageCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PackageCourseCreateManyCourseInputEnvelope
    set?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    disconnect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    delete?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    update?: PackageCourseUpdateWithWhereUniqueWithoutCourseInput | PackageCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PackageCourseUpdateManyWithWhereWithoutCourseInput | PackageCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PackageCourseScalarWhereInput | PackageCourseScalarWhereInput[]
  }

  export type SeoMetaUpdateOneWithoutCourseNestedInput = {
    create?: XOR<SeoMetaCreateWithoutCourseInput, SeoMetaUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutCourseInput
    upsert?: SeoMetaUpsertWithoutCourseInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutCourseInput, SeoMetaUpdateWithoutCourseInput>, SeoMetaUncheckedUpdateWithoutCourseInput>
  }

  export type LessonUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCourseInput | LessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCourseInput | LessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCourseInput | LessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PackageCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PackageCourseCreateWithoutCourseInput, PackageCourseUncheckedCreateWithoutCourseInput> | PackageCourseCreateWithoutCourseInput[] | PackageCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutCourseInput | PackageCourseCreateOrConnectWithoutCourseInput[]
    upsert?: PackageCourseUpsertWithWhereUniqueWithoutCourseInput | PackageCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PackageCourseCreateManyCourseInputEnvelope
    set?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    disconnect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    delete?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    update?: PackageCourseUpdateWithWhereUniqueWithoutCourseInput | PackageCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PackageCourseUpdateManyWithWhereWithoutCourseInput | PackageCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PackageCourseScalarWhereInput | PackageCourseScalarWhereInput[]
  }

  export type SeoMetaUncheckedUpdateOneWithoutCourseNestedInput = {
    create?: XOR<SeoMetaCreateWithoutCourseInput, SeoMetaUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutCourseInput
    upsert?: SeoMetaUpsertWithoutCourseInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutCourseInput, SeoMetaUpdateWithoutCourseInput>, SeoMetaUncheckedUpdateWithoutCourseInput>
  }

  export type LessonCreateresourcesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedLessonsInput = {
    create?: XOR<UserCreateWithoutCreatedLessonsInput, UserUncheckedCreateWithoutCreatedLessonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLessonsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    connect?: CourseWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LessonUpdateresourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCreatedLessonsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLessonsInput, UserUncheckedCreateWithoutCreatedLessonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLessonsInput
    upsert?: UserUpsertWithoutCreatedLessonsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLessonsInput, UserUpdateWithoutCreatedLessonsInput>, UserUncheckedUpdateWithoutCreatedLessonsInput>
  }

  export type CourseUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    upsert?: CourseUpsertWithoutLessonsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLessonsInput, CourseUpdateWithoutLessonsInput>, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type PackageCreatefeaturesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedPackagesInput = {
    create?: XOR<UserCreateWithoutCreatedPackagesInput, UserUncheckedCreateWithoutCreatedPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPackagesInput
    connect?: UserWhereUniqueInput
  }

  export type PackageCourseCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageCourseCreateWithoutPackageInput, PackageCourseUncheckedCreateWithoutPackageInput> | PackageCourseCreateWithoutPackageInput[] | PackageCourseUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutPackageInput | PackageCourseCreateOrConnectWithoutPackageInput[]
    createMany?: PackageCourseCreateManyPackageInputEnvelope
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
  }

  export type SeoMetaCreateNestedOneWithoutPackageInput = {
    create?: XOR<SeoMetaCreateWithoutPackageInput, SeoMetaUncheckedCreateWithoutPackageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPackageInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type PackageCourseUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageCourseCreateWithoutPackageInput, PackageCourseUncheckedCreateWithoutPackageInput> | PackageCourseCreateWithoutPackageInput[] | PackageCourseUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutPackageInput | PackageCourseCreateOrConnectWithoutPackageInput[]
    createMany?: PackageCourseCreateManyPackageInputEnvelope
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
  }

  export type SeoMetaUncheckedCreateNestedOneWithoutPackageInput = {
    create?: XOR<SeoMetaCreateWithoutPackageInput, SeoMetaUncheckedCreateWithoutPackageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPackageInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPackageTypeFieldUpdateOperationsInput = {
    set?: $Enums.PackageType
  }

  export type PackageUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCreatedPackagesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPackagesInput, UserUncheckedCreateWithoutCreatedPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPackagesInput
    upsert?: UserUpsertWithoutCreatedPackagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPackagesInput, UserUpdateWithoutCreatedPackagesInput>, UserUncheckedUpdateWithoutCreatedPackagesInput>
  }

  export type PackageCourseUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageCourseCreateWithoutPackageInput, PackageCourseUncheckedCreateWithoutPackageInput> | PackageCourseCreateWithoutPackageInput[] | PackageCourseUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutPackageInput | PackageCourseCreateOrConnectWithoutPackageInput[]
    upsert?: PackageCourseUpsertWithWhereUniqueWithoutPackageInput | PackageCourseUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageCourseCreateManyPackageInputEnvelope
    set?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    disconnect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    delete?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    update?: PackageCourseUpdateWithWhereUniqueWithoutPackageInput | PackageCourseUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageCourseUpdateManyWithWhereWithoutPackageInput | PackageCourseUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageCourseScalarWhereInput | PackageCourseScalarWhereInput[]
  }

  export type SeoMetaUpdateOneWithoutPackageNestedInput = {
    create?: XOR<SeoMetaCreateWithoutPackageInput, SeoMetaUncheckedCreateWithoutPackageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPackageInput
    upsert?: SeoMetaUpsertWithoutPackageInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutPackageInput, SeoMetaUpdateWithoutPackageInput>, SeoMetaUncheckedUpdateWithoutPackageInput>
  }

  export type PackageCourseUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageCourseCreateWithoutPackageInput, PackageCourseUncheckedCreateWithoutPackageInput> | PackageCourseCreateWithoutPackageInput[] | PackageCourseUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageCourseCreateOrConnectWithoutPackageInput | PackageCourseCreateOrConnectWithoutPackageInput[]
    upsert?: PackageCourseUpsertWithWhereUniqueWithoutPackageInput | PackageCourseUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageCourseCreateManyPackageInputEnvelope
    set?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    disconnect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    delete?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    connect?: PackageCourseWhereUniqueInput | PackageCourseWhereUniqueInput[]
    update?: PackageCourseUpdateWithWhereUniqueWithoutPackageInput | PackageCourseUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageCourseUpdateManyWithWhereWithoutPackageInput | PackageCourseUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageCourseScalarWhereInput | PackageCourseScalarWhereInput[]
  }

  export type SeoMetaUncheckedUpdateOneWithoutPackageNestedInput = {
    create?: XOR<SeoMetaCreateWithoutPackageInput, SeoMetaUncheckedCreateWithoutPackageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPackageInput
    upsert?: SeoMetaUpsertWithoutPackageInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutPackageInput, SeoMetaUpdateWithoutPackageInput>, SeoMetaUncheckedUpdateWithoutPackageInput>
  }

  export type PackageCreateNestedOneWithoutPackageCoursesInput = {
    create?: XOR<PackageCreateWithoutPackageCoursesInput, PackageUncheckedCreateWithoutPackageCoursesInput>
    connectOrCreate?: PackageCreateOrConnectWithoutPackageCoursesInput
    connect?: PackageWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPackageCoursesInput = {
    create?: XOR<CourseCreateWithoutPackageCoursesInput, CourseUncheckedCreateWithoutPackageCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPackageCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type PackageUpdateOneRequiredWithoutPackageCoursesNestedInput = {
    create?: XOR<PackageCreateWithoutPackageCoursesInput, PackageUncheckedCreateWithoutPackageCoursesInput>
    connectOrCreate?: PackageCreateOrConnectWithoutPackageCoursesInput
    upsert?: PackageUpsertWithoutPackageCoursesInput
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutPackageCoursesInput, PackageUpdateWithoutPackageCoursesInput>, PackageUncheckedUpdateWithoutPackageCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutPackageCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutPackageCoursesInput, CourseUncheckedCreateWithoutPackageCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPackageCoursesInput
    upsert?: CourseUpsertWithoutPackageCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPackageCoursesInput, CourseUpdateWithoutPackageCoursesInput>, CourseUncheckedUpdateWithoutPackageCoursesInput>
  }

  export type BlogPostCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedBlogPostsInput = {
    create?: XOR<UserCreateWithoutCreatedBlogPostsInput, UserUncheckedCreateWithoutCreatedBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type AuthorCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<AuthorCreateWithoutBlogPostsInput, AuthorUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutBlogPostsInput
    connect?: AuthorWhereUniqueInput
  }

  export type SeoMetaCreateNestedOneWithoutBlogPostInput = {
    create?: XOR<SeoMetaCreateWithoutBlogPostInput, SeoMetaUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutBlogPostInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type SeoMetaUncheckedCreateNestedOneWithoutBlogPostInput = {
    create?: XOR<SeoMetaCreateWithoutBlogPostInput, SeoMetaUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutBlogPostInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type BlogPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCreatedBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBlogPostsInput, UserUncheckedCreateWithoutCreatedBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBlogPostsInput
    upsert?: UserUpsertWithoutCreatedBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBlogPostsInput, UserUpdateWithoutCreatedBlogPostsInput>, UserUncheckedUpdateWithoutCreatedBlogPostsInput>
  }

  export type AuthorUpdateOneWithoutBlogPostsNestedInput = {
    create?: XOR<AuthorCreateWithoutBlogPostsInput, AuthorUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutBlogPostsInput
    upsert?: AuthorUpsertWithoutBlogPostsInput
    disconnect?: AuthorWhereInput | boolean
    delete?: AuthorWhereInput | boolean
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutBlogPostsInput, AuthorUpdateWithoutBlogPostsInput>, AuthorUncheckedUpdateWithoutBlogPostsInput>
  }

  export type SeoMetaUpdateOneWithoutBlogPostNestedInput = {
    create?: XOR<SeoMetaCreateWithoutBlogPostInput, SeoMetaUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutBlogPostInput
    upsert?: SeoMetaUpsertWithoutBlogPostInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutBlogPostInput, SeoMetaUpdateWithoutBlogPostInput>, SeoMetaUncheckedUpdateWithoutBlogPostInput>
  }

  export type SeoMetaUncheckedUpdateOneWithoutBlogPostNestedInput = {
    create?: XOR<SeoMetaCreateWithoutBlogPostInput, SeoMetaUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutBlogPostInput
    upsert?: SeoMetaUpsertWithoutBlogPostInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutBlogPostInput, SeoMetaUpdateWithoutBlogPostInput>, SeoMetaUncheckedUpdateWithoutBlogPostInput>
  }

  export type UserCreateNestedOneWithoutCreatedPagesInput = {
    create?: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPagesInput
    connect?: UserWhereUniqueInput
  }

  export type SeoMetaCreateNestedOneWithoutPageInput = {
    create?: XOR<SeoMetaCreateWithoutPageInput, SeoMetaUncheckedCreateWithoutPageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPageInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type SeoMetaUncheckedCreateNestedOneWithoutPageInput = {
    create?: XOR<SeoMetaCreateWithoutPageInput, SeoMetaUncheckedCreateWithoutPageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPageInput
    connect?: SeoMetaWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedPagesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPagesInput
    upsert?: UserUpsertWithoutCreatedPagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPagesInput, UserUpdateWithoutCreatedPagesInput>, UserUncheckedUpdateWithoutCreatedPagesInput>
  }

  export type SeoMetaUpdateOneWithoutPageNestedInput = {
    create?: XOR<SeoMetaCreateWithoutPageInput, SeoMetaUncheckedCreateWithoutPageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPageInput
    upsert?: SeoMetaUpsertWithoutPageInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutPageInput, SeoMetaUpdateWithoutPageInput>, SeoMetaUncheckedUpdateWithoutPageInput>
  }

  export type SeoMetaUncheckedUpdateOneWithoutPageNestedInput = {
    create?: XOR<SeoMetaCreateWithoutPageInput, SeoMetaUncheckedCreateWithoutPageInput>
    connectOrCreate?: SeoMetaCreateOrConnectWithoutPageInput
    upsert?: SeoMetaUpsertWithoutPageInput
    disconnect?: SeoMetaWhereInput | boolean
    delete?: SeoMetaWhereInput | boolean
    connect?: SeoMetaWhereUniqueInput
    update?: XOR<XOR<SeoMetaUpdateToOneWithWhereWithoutPageInput, SeoMetaUpdateWithoutPageInput>, SeoMetaUncheckedUpdateWithoutPageInput>
  }

  export type UserCreateNestedOneWithoutAuthorProfileInput = {
    create?: XOR<UserCreateWithoutAuthorProfileInput, UserUncheckedCreateWithoutAuthorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAuthorProfileNestedInput = {
    create?: XOR<UserCreateWithoutAuthorProfileInput, UserUncheckedCreateWithoutAuthorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorProfileInput
    upsert?: UserUpsertWithoutAuthorProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorProfileInput, UserUpdateWithoutAuthorProfileInput>, UserUncheckedUpdateWithoutAuthorProfileInput>
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutSeoMetaInput = {
    create?: XOR<CourseCreateWithoutSeoMetaInput, CourseUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSeoMetaInput
    connect?: CourseWhereUniqueInput
  }

  export type PackageCreateNestedOneWithoutSeoMetaInput = {
    create?: XOR<PackageCreateWithoutSeoMetaInput, PackageUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: PackageCreateOrConnectWithoutSeoMetaInput
    connect?: PackageWhereUniqueInput
  }

  export type BlogPostCreateNestedOneWithoutSeoMetaInput = {
    create?: XOR<BlogPostCreateWithoutSeoMetaInput, BlogPostUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeoMetaInput
    connect?: BlogPostWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutSeoMetaInput = {
    create?: XOR<PageCreateWithoutSeoMetaInput, PageUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: PageCreateOrConnectWithoutSeoMetaInput
    connect?: PageWhereUniqueInput
  }

  export type CourseUpdateOneWithoutSeoMetaNestedInput = {
    create?: XOR<CourseCreateWithoutSeoMetaInput, CourseUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSeoMetaInput
    upsert?: CourseUpsertWithoutSeoMetaInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSeoMetaInput, CourseUpdateWithoutSeoMetaInput>, CourseUncheckedUpdateWithoutSeoMetaInput>
  }

  export type PackageUpdateOneWithoutSeoMetaNestedInput = {
    create?: XOR<PackageCreateWithoutSeoMetaInput, PackageUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: PackageCreateOrConnectWithoutSeoMetaInput
    upsert?: PackageUpsertWithoutSeoMetaInput
    disconnect?: PackageWhereInput | boolean
    delete?: PackageWhereInput | boolean
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutSeoMetaInput, PackageUpdateWithoutSeoMetaInput>, PackageUncheckedUpdateWithoutSeoMetaInput>
  }

  export type BlogPostUpdateOneWithoutSeoMetaNestedInput = {
    create?: XOR<BlogPostCreateWithoutSeoMetaInput, BlogPostUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeoMetaInput
    upsert?: BlogPostUpsertWithoutSeoMetaInput
    disconnect?: BlogPostWhereInput | boolean
    delete?: BlogPostWhereInput | boolean
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSeoMetaInput, BlogPostUpdateWithoutSeoMetaInput>, BlogPostUncheckedUpdateWithoutSeoMetaInput>
  }

  export type PageUpdateOneWithoutSeoMetaNestedInput = {
    create?: XOR<PageCreateWithoutSeoMetaInput, PageUncheckedCreateWithoutSeoMetaInput>
    connectOrCreate?: PageCreateOrConnectWithoutSeoMetaInput
    upsert?: PageUpsertWithoutSeoMetaInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutSeoMetaInput, PageUpdateWithoutSeoMetaInput>, PageUncheckedUpdateWithoutSeoMetaInput>
  }

  export type UserCreateNestedOneWithoutCreatedRevisionsInput = {
    create?: XOR<UserCreateWithoutCreatedRevisionsInput, UserUncheckedCreateWithoutCreatedRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedRevisionsInput = {
    create?: XOR<UserCreateWithoutReviewedRevisionsInput, UserUncheckedCreateWithoutReviewedRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPublishedRevisionsInput = {
    create?: XOR<UserCreateWithoutPublishedRevisionsInput, UserUncheckedCreateWithoutPublishedRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type EnumRevisionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RevisionStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRevisionsInput, UserUncheckedCreateWithoutCreatedRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRevisionsInput
    upsert?: UserUpsertWithoutCreatedRevisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRevisionsInput, UserUpdateWithoutCreatedRevisionsInput>, UserUncheckedUpdateWithoutCreatedRevisionsInput>
  }

  export type UserUpdateOneWithoutReviewedRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedRevisionsInput, UserUncheckedCreateWithoutReviewedRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedRevisionsInput
    upsert?: UserUpsertWithoutReviewedRevisionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedRevisionsInput, UserUpdateWithoutReviewedRevisionsInput>, UserUncheckedUpdateWithoutReviewedRevisionsInput>
  }

  export type UserUpdateOneWithoutPublishedRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutPublishedRevisionsInput, UserUncheckedCreateWithoutPublishedRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedRevisionsInput
    upsert?: UserUpsertWithoutPublishedRevisionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPublishedRevisionsInput, UserUpdateWithoutPublishedRevisionsInput>, UserUncheckedUpdateWithoutPublishedRevisionsInput>
  }

  export type UserCreateNestedOneWithoutCreatedSectionsInput = {
    create?: XOR<UserCreateWithoutCreatedSectionsInput, UserUncheckedCreateWithoutCreatedSectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSectionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedSectionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSectionsInput, UserUncheckedCreateWithoutCreatedSectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSectionsInput
    upsert?: UserUpsertWithoutCreatedSectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSectionsInput, UserUpdateWithoutCreatedSectionsInput>, UserUncheckedUpdateWithoutCreatedSectionsInput>
  }

  export type UserCreateNestedOneWithoutQuickEditItemsInput = {
    create?: XOR<UserCreateWithoutQuickEditItemsInput, UserUncheckedCreateWithoutQuickEditItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickEditItemsInput
    connect?: UserWhereUniqueInput
  }

  export type QuickEditRevisionCreateNestedManyWithoutItemInput = {
    create?: XOR<QuickEditRevisionCreateWithoutItemInput, QuickEditRevisionUncheckedCreateWithoutItemInput> | QuickEditRevisionCreateWithoutItemInput[] | QuickEditRevisionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutItemInput | QuickEditRevisionCreateOrConnectWithoutItemInput[]
    createMany?: QuickEditRevisionCreateManyItemInputEnvelope
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
  }

  export type QuickEditRevisionUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<QuickEditRevisionCreateWithoutItemInput, QuickEditRevisionUncheckedCreateWithoutItemInput> | QuickEditRevisionCreateWithoutItemInput[] | QuickEditRevisionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutItemInput | QuickEditRevisionCreateOrConnectWithoutItemInput[]
    createMany?: QuickEditRevisionCreateManyItemInputEnvelope
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
  }

  export type EnumQuickEditTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuickEditType
  }

  export type UserUpdateOneRequiredWithoutQuickEditItemsNestedInput = {
    create?: XOR<UserCreateWithoutQuickEditItemsInput, UserUncheckedCreateWithoutQuickEditItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickEditItemsInput
    upsert?: UserUpsertWithoutQuickEditItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuickEditItemsInput, UserUpdateWithoutQuickEditItemsInput>, UserUncheckedUpdateWithoutQuickEditItemsInput>
  }

  export type QuickEditRevisionUpdateManyWithoutItemNestedInput = {
    create?: XOR<QuickEditRevisionCreateWithoutItemInput, QuickEditRevisionUncheckedCreateWithoutItemInput> | QuickEditRevisionCreateWithoutItemInput[] | QuickEditRevisionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutItemInput | QuickEditRevisionCreateOrConnectWithoutItemInput[]
    upsert?: QuickEditRevisionUpsertWithWhereUniqueWithoutItemInput | QuickEditRevisionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: QuickEditRevisionCreateManyItemInputEnvelope
    set?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    disconnect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    delete?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    update?: QuickEditRevisionUpdateWithWhereUniqueWithoutItemInput | QuickEditRevisionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: QuickEditRevisionUpdateManyWithWhereWithoutItemInput | QuickEditRevisionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: QuickEditRevisionScalarWhereInput | QuickEditRevisionScalarWhereInput[]
  }

  export type QuickEditRevisionUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<QuickEditRevisionCreateWithoutItemInput, QuickEditRevisionUncheckedCreateWithoutItemInput> | QuickEditRevisionCreateWithoutItemInput[] | QuickEditRevisionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: QuickEditRevisionCreateOrConnectWithoutItemInput | QuickEditRevisionCreateOrConnectWithoutItemInput[]
    upsert?: QuickEditRevisionUpsertWithWhereUniqueWithoutItemInput | QuickEditRevisionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: QuickEditRevisionCreateManyItemInputEnvelope
    set?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    disconnect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    delete?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    connect?: QuickEditRevisionWhereUniqueInput | QuickEditRevisionWhereUniqueInput[]
    update?: QuickEditRevisionUpdateWithWhereUniqueWithoutItemInput | QuickEditRevisionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: QuickEditRevisionUpdateManyWithWhereWithoutItemInput | QuickEditRevisionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: QuickEditRevisionScalarWhereInput | QuickEditRevisionScalarWhereInput[]
  }

  export type QuickEditItemCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<QuickEditItemCreateWithoutRevisionsInput, QuickEditItemUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: QuickEditItemCreateOrConnectWithoutRevisionsInput
    connect?: QuickEditItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuickEditRevisionsInput = {
    create?: XOR<UserCreateWithoutQuickEditRevisionsInput, UserUncheckedCreateWithoutQuickEditRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickEditRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuickEditItemUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<QuickEditItemCreateWithoutRevisionsInput, QuickEditItemUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: QuickEditItemCreateOrConnectWithoutRevisionsInput
    upsert?: QuickEditItemUpsertWithoutRevisionsInput
    connect?: QuickEditItemWhereUniqueInput
    update?: XOR<XOR<QuickEditItemUpdateToOneWithWhereWithoutRevisionsInput, QuickEditItemUpdateWithoutRevisionsInput>, QuickEditItemUncheckedUpdateWithoutRevisionsInput>
  }

  export type UserUpdateOneRequiredWithoutQuickEditRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutQuickEditRevisionsInput, UserUncheckedCreateWithoutQuickEditRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickEditRevisionsInput
    upsert?: UserUpsertWithoutQuickEditRevisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuickEditRevisionsInput, UserUpdateWithoutQuickEditRevisionsInput>, UserUncheckedUpdateWithoutQuickEditRevisionsInput>
  }

  export type UserCreateNestedOneWithoutThemeSettingsInput = {
    create?: XOR<UserCreateWithoutThemeSettingsInput, UserUncheckedCreateWithoutThemeSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThemeSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutThemeSettingsNestedInput = {
    create?: XOR<UserCreateWithoutThemeSettingsInput, UserUncheckedCreateWithoutThemeSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThemeSettingsInput
    upsert?: UserUpsertWithoutThemeSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutThemeSettingsInput, UserUpdateWithoutThemeSettingsInput>, UserUncheckedUpdateWithoutThemeSettingsInput>
  }

  export type UserCreateNestedOneWithoutLivePreviewTokensInput = {
    create?: XOR<UserCreateWithoutLivePreviewTokensInput, UserUncheckedCreateWithoutLivePreviewTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivePreviewTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLivePreviewTokensNestedInput = {
    create?: XOR<UserCreateWithoutLivePreviewTokensInput, UserUncheckedCreateWithoutLivePreviewTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivePreviewTokensInput
    upsert?: UserUpsertWithoutLivePreviewTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLivePreviewTokensInput, UserUpdateWithoutLivePreviewTokensInput>, UserUncheckedUpdateWithoutLivePreviewTokensInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCourseLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelFilter<$PrismaModel> | $Enums.CourseLevel
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevel | EnumCourseLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevel[] | ListEnumCourseLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPackageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeFilter<$PrismaModel> | $Enums.PackageType
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPackageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeWithAggregatesFilter<$PrismaModel> | $Enums.PackageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackageTypeFilter<$PrismaModel>
    _max?: NestedEnumPackageTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumRevisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusFilter<$PrismaModel> | $Enums.RevisionStatus
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRevisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevisionStatus | EnumRevisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RevisionStatus[] | ListEnumRevisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRevisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RevisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRevisionStatusFilter<$PrismaModel>
    _max?: NestedEnumRevisionStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuickEditTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuickEditType | EnumQuickEditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuickEditTypeFilter<$PrismaModel> | $Enums.QuickEditType
  }

  export type NestedEnumQuickEditTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuickEditType | EnumQuickEditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuickEditType[] | ListEnumQuickEditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuickEditTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuickEditType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuickEditTypeFilter<$PrismaModel>
    _max?: NestedEnumQuickEditTypeFilter<$PrismaModel>
  }

  export type CourseCreateWithoutCreatorInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonCreateNestedManyWithoutCourseInput
    packageCourses?: PackageCourseCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseCreateManyCreatorInputEnvelope = {
    data: CourseCreateManyCreatorInput | CourseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    courseId: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateOrConnectWithoutCreatorInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput>
  }

  export type LessonCreateManyCreatorInputEnvelope = {
    data: LessonCreateManyCreatorInput | LessonCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PackageCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    packageCourses?: PackageCourseCreateNestedManyWithoutPackageInput
    seoMeta?: SeoMetaCreateNestedOneWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutPackageInput
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutCreatorInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutCreatorInput, PackageUncheckedCreateWithoutCreatorInput>
  }

  export type PackageCreateManyCreatorInputEnvelope = {
    data: PackageCreateManyCreatorInput | PackageCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: AuthorCreateNestedOneWithoutBlogPostsInput
    seoMeta?: SeoMetaCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutCreatorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCreatorInput, BlogPostUncheckedCreateWithoutCreatorInput>
  }

  export type BlogPostCreateManyCreatorInputEnvelope = {
    data: BlogPostCreateManyCreatorInput | BlogPostCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seoMeta?: SeoMetaCreateNestedOneWithoutPageInput
  }

  export type PageUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutPageInput
  }

  export type PageCreateOrConnectWithoutCreatorInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput>
  }

  export type PageCreateManyCreatorInputEnvelope = {
    data: PageCreateManyCreatorInput | PageCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ContentSectionCreateWithoutCreatorInput = {
    id?: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentSectionUncheckedCreateWithoutCreatorInput = {
    id?: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentSectionCreateOrConnectWithoutCreatorInput = {
    where: ContentSectionWhereUniqueInput
    create: XOR<ContentSectionCreateWithoutCreatorInput, ContentSectionUncheckedCreateWithoutCreatorInput>
  }

  export type ContentSectionCreateManyCreatorInputEnvelope = {
    data: ContentSectionCreateManyCreatorInput | ContentSectionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AuthorCreateWithoutUserInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorCreateOrConnectWithoutUserInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RevisionCreateWithoutCreatorInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    reviewNotes?: string | null
    reviewer?: UserCreateNestedOneWithoutReviewedRevisionsInput
    publisher?: UserCreateNestedOneWithoutPublishedRevisionsInput
  }

  export type RevisionUncheckedCreateWithoutCreatorInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    reviewedById?: string | null
    publishedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionCreateOrConnectWithoutCreatorInput = {
    where: RevisionWhereUniqueInput
    create: XOR<RevisionCreateWithoutCreatorInput, RevisionUncheckedCreateWithoutCreatorInput>
  }

  export type RevisionCreateManyCreatorInputEnvelope = {
    data: RevisionCreateManyCreatorInput | RevisionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RevisionCreateWithoutReviewerInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    reviewNotes?: string | null
    creator: UserCreateNestedOneWithoutCreatedRevisionsInput
    publisher?: UserCreateNestedOneWithoutPublishedRevisionsInput
  }

  export type RevisionUncheckedCreateWithoutReviewerInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    createdById: string
    publishedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionCreateOrConnectWithoutReviewerInput = {
    where: RevisionWhereUniqueInput
    create: XOR<RevisionCreateWithoutReviewerInput, RevisionUncheckedCreateWithoutReviewerInput>
  }

  export type RevisionCreateManyReviewerInputEnvelope = {
    data: RevisionCreateManyReviewerInput | RevisionCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type RevisionCreateWithoutPublisherInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    reviewNotes?: string | null
    creator: UserCreateNestedOneWithoutCreatedRevisionsInput
    reviewer?: UserCreateNestedOneWithoutReviewedRevisionsInput
  }

  export type RevisionUncheckedCreateWithoutPublisherInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    createdById: string
    reviewedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionCreateOrConnectWithoutPublisherInput = {
    where: RevisionWhereUniqueInput
    create: XOR<RevisionCreateWithoutPublisherInput, RevisionUncheckedCreateWithoutPublisherInput>
  }

  export type RevisionCreateManyPublisherInputEnvelope = {
    data: RevisionCreateManyPublisherInput | RevisionCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuickEditItemCreateWithoutCreatorInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: QuickEditRevisionCreateNestedManyWithoutItemInput
  }

  export type QuickEditItemUncheckedCreateWithoutCreatorInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutItemInput
  }

  export type QuickEditItemCreateOrConnectWithoutCreatorInput = {
    where: QuickEditItemWhereUniqueInput
    create: XOR<QuickEditItemCreateWithoutCreatorInput, QuickEditItemUncheckedCreateWithoutCreatorInput>
  }

  export type QuickEditItemCreateManyCreatorInputEnvelope = {
    data: QuickEditItemCreateManyCreatorInput | QuickEditItemCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuickEditRevisionCreateWithoutCreatorInput = {
    id?: string
    value: string
    changeType: string
    createdAt?: Date | string
    item: QuickEditItemCreateNestedOneWithoutRevisionsInput
  }

  export type QuickEditRevisionUncheckedCreateWithoutCreatorInput = {
    id?: string
    itemId: string
    value: string
    changeType: string
    createdAt?: Date | string
  }

  export type QuickEditRevisionCreateOrConnectWithoutCreatorInput = {
    where: QuickEditRevisionWhereUniqueInput
    create: XOR<QuickEditRevisionCreateWithoutCreatorInput, QuickEditRevisionUncheckedCreateWithoutCreatorInput>
  }

  export type QuickEditRevisionCreateManyCreatorInputEnvelope = {
    data: QuickEditRevisionCreateManyCreatorInput | QuickEditRevisionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ThemeSettingCreateWithoutCreatorInput = {
    id?: string
    name: string
    category: string
    value: string
    cssVariable: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThemeSettingUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    category: string
    value: string
    cssVariable: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThemeSettingCreateOrConnectWithoutCreatorInput = {
    where: ThemeSettingWhereUniqueInput
    create: XOR<ThemeSettingCreateWithoutCreatorInput, ThemeSettingUncheckedCreateWithoutCreatorInput>
  }

  export type ThemeSettingCreateManyCreatorInputEnvelope = {
    data: ThemeSettingCreateManyCreatorInput | ThemeSettingCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type LivePreviewTokenCreateWithoutCreatorInput = {
    id?: string
    token: string
    page: string
    changes: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type LivePreviewTokenUncheckedCreateWithoutCreatorInput = {
    id?: string
    token: string
    page: string
    changes: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type LivePreviewTokenCreateOrConnectWithoutCreatorInput = {
    where: LivePreviewTokenWhereUniqueInput
    create: XOR<LivePreviewTokenCreateWithoutCreatorInput, LivePreviewTokenUncheckedCreateWithoutCreatorInput>
  }

  export type LivePreviewTokenCreateManyCreatorInputEnvelope = {
    data: LivePreviewTokenCreateManyCreatorInput | LivePreviewTokenCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    subtitle?: StringNullableFilter<"Course"> | string | null
    slug?: StringFilter<"Course"> | string
    shortDescription?: StringNullableFilter<"Course"> | string | null
    longDescription?: StringNullableFilter<"Course"> | string | null
    coverImage?: StringNullableFilter<"Course"> | string | null
    gallery?: StringNullableListFilter<"Course">
    duration?: IntNullableFilter<"Course"> | number | null
    level?: EnumCourseLevelFilter<"Course"> | $Enums.CourseLevel
    language?: StringFilter<"Course"> | string
    price?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Course"> | string
    tags?: StringNullableListFilter<"Course">
    categories?: StringNullableListFilter<"Course">
    status?: EnumContentStatusFilter<"Course"> | $Enums.ContentStatus
    isFeatured?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    createdById?: StringFilter<"Course"> | string
  }

  export type LessonUpsertWithWhereUniqueWithoutCreatorInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCreatorInput, LessonUncheckedUpdateWithoutCreatorInput>
    create: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCreatorInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCreatorInput, LessonUncheckedUpdateWithoutCreatorInput>
  }

  export type LessonUpdateManyWithWhereWithoutCreatorInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutCreatorInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    slug?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    order?: IntFilter<"Lesson"> | number
    duration?: IntNullableFilter<"Lesson"> | number | null
    resources?: StringNullableListFilter<"Lesson">
    isPreview?: BoolFilter<"Lesson"> | boolean
    courseId?: StringFilter<"Lesson"> | string
    status?: EnumContentStatusFilter<"Lesson"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    createdById?: StringFilter<"Lesson"> | string
  }

  export type PackageUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PackageWhereUniqueInput
    update: XOR<PackageUpdateWithoutCreatorInput, PackageUncheckedUpdateWithoutCreatorInput>
    create: XOR<PackageCreateWithoutCreatorInput, PackageUncheckedCreateWithoutCreatorInput>
  }

  export type PackageUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PackageWhereUniqueInput
    data: XOR<PackageUpdateWithoutCreatorInput, PackageUncheckedUpdateWithoutCreatorInput>
  }

  export type PackageUpdateManyWithWhereWithoutCreatorInput = {
    where: PackageScalarWhereInput
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PackageScalarWhereInput = {
    AND?: PackageScalarWhereInput | PackageScalarWhereInput[]
    OR?: PackageScalarWhereInput[]
    NOT?: PackageScalarWhereInput | PackageScalarWhereInput[]
    id?: StringFilter<"Package"> | string
    title?: StringFilter<"Package"> | string
    slug?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFilter<"Package"> | $Enums.PackageType
    features?: StringNullableListFilter<"Package">
    validityDays?: IntNullableFilter<"Package"> | number | null
    status?: EnumContentStatusFilter<"Package"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    createdById?: StringFilter<"Package"> | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutCreatorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutCreatorInput, BlogPostUncheckedUpdateWithoutCreatorInput>
    create: XOR<BlogPostCreateWithoutCreatorInput, BlogPostUncheckedCreateWithoutCreatorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutCreatorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutCreatorInput, BlogPostUncheckedUpdateWithoutCreatorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutCreatorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutCreatorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    content?: StringFilter<"BlogPost"> | string
    featuredImage?: StringNullableFilter<"BlogPost"> | string | null
    tags?: StringNullableListFilter<"BlogPost">
    series?: StringNullableFilter<"BlogPost"> | string | null
    publishDate?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    status?: EnumContentStatusFilter<"BlogPost"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    createdById?: StringFilter<"BlogPost"> | string
    authorId?: StringNullableFilter<"BlogPost"> | string | null
  }

  export type PageUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutCreatorInput, PageUncheckedUpdateWithoutCreatorInput>
    create: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput>
  }

  export type PageUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutCreatorInput, PageUncheckedUpdateWithoutCreatorInput>
  }

  export type PageUpdateManyWithWhereWithoutCreatorInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    layout?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    status?: EnumContentStatusFilter<"Page"> | $Enums.ContentStatus
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    createdById?: StringFilter<"Page"> | string
  }

  export type ContentSectionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ContentSectionWhereUniqueInput
    update: XOR<ContentSectionUpdateWithoutCreatorInput, ContentSectionUncheckedUpdateWithoutCreatorInput>
    create: XOR<ContentSectionCreateWithoutCreatorInput, ContentSectionUncheckedCreateWithoutCreatorInput>
  }

  export type ContentSectionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ContentSectionWhereUniqueInput
    data: XOR<ContentSectionUpdateWithoutCreatorInput, ContentSectionUncheckedUpdateWithoutCreatorInput>
  }

  export type ContentSectionUpdateManyWithWhereWithoutCreatorInput = {
    where: ContentSectionScalarWhereInput
    data: XOR<ContentSectionUpdateManyMutationInput, ContentSectionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ContentSectionScalarWhereInput = {
    AND?: ContentSectionScalarWhereInput | ContentSectionScalarWhereInput[]
    OR?: ContentSectionScalarWhereInput[]
    NOT?: ContentSectionScalarWhereInput | ContentSectionScalarWhereInput[]
    id?: StringFilter<"ContentSection"> | string
    type?: StringFilter<"ContentSection"> | string
    content?: JsonFilter<"ContentSection">
    order?: IntFilter<"ContentSection"> | number
    metadata?: JsonNullableFilter<"ContentSection">
    isVisible?: BoolFilter<"ContentSection"> | boolean
    contentType?: EnumContentTypeFilter<"ContentSection"> | $Enums.ContentType
    contentId?: StringFilter<"ContentSection"> | string
    createdAt?: DateTimeFilter<"ContentSection"> | Date | string
    updatedAt?: DateTimeFilter<"ContentSection"> | Date | string
    createdById?: StringFilter<"ContentSection"> | string
  }

  export type AuthorUpsertWithoutUserInput = {
    update: XOR<AuthorUpdateWithoutUserInput, AuthorUncheckedUpdateWithoutUserInput>
    create: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutUserInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutUserInput, AuthorUncheckedUpdateWithoutUserInput>
  }

  export type AuthorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type RevisionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RevisionWhereUniqueInput
    update: XOR<RevisionUpdateWithoutCreatorInput, RevisionUncheckedUpdateWithoutCreatorInput>
    create: XOR<RevisionCreateWithoutCreatorInput, RevisionUncheckedCreateWithoutCreatorInput>
  }

  export type RevisionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RevisionWhereUniqueInput
    data: XOR<RevisionUpdateWithoutCreatorInput, RevisionUncheckedUpdateWithoutCreatorInput>
  }

  export type RevisionUpdateManyWithWhereWithoutCreatorInput = {
    where: RevisionScalarWhereInput
    data: XOR<RevisionUpdateManyMutationInput, RevisionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type RevisionScalarWhereInput = {
    AND?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
    OR?: RevisionScalarWhereInput[]
    NOT?: RevisionScalarWhereInput | RevisionScalarWhereInput[]
    id?: StringFilter<"Revision"> | string
    contentType?: EnumContentTypeFilter<"Revision"> | $Enums.ContentType
    contentId?: StringFilter<"Revision"> | string
    version?: IntFilter<"Revision"> | number
    data?: JsonFilter<"Revision">
    status?: EnumRevisionStatusFilter<"Revision"> | $Enums.RevisionStatus
    previewToken?: StringNullableFilter<"Revision"> | string | null
    previewExpiresAt?: DateTimeNullableFilter<"Revision"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"Revision"> | Date | string | null
    createdAt?: DateTimeFilter<"Revision"> | Date | string
    createdById?: StringFilter<"Revision"> | string
    reviewedById?: StringNullableFilter<"Revision"> | string | null
    publishedById?: StringNullableFilter<"Revision"> | string | null
    reviewNotes?: StringNullableFilter<"Revision"> | string | null
  }

  export type RevisionUpsertWithWhereUniqueWithoutReviewerInput = {
    where: RevisionWhereUniqueInput
    update: XOR<RevisionUpdateWithoutReviewerInput, RevisionUncheckedUpdateWithoutReviewerInput>
    create: XOR<RevisionCreateWithoutReviewerInput, RevisionUncheckedCreateWithoutReviewerInput>
  }

  export type RevisionUpdateWithWhereUniqueWithoutReviewerInput = {
    where: RevisionWhereUniqueInput
    data: XOR<RevisionUpdateWithoutReviewerInput, RevisionUncheckedUpdateWithoutReviewerInput>
  }

  export type RevisionUpdateManyWithWhereWithoutReviewerInput = {
    where: RevisionScalarWhereInput
    data: XOR<RevisionUpdateManyMutationInput, RevisionUncheckedUpdateManyWithoutReviewerInput>
  }

  export type RevisionUpsertWithWhereUniqueWithoutPublisherInput = {
    where: RevisionWhereUniqueInput
    update: XOR<RevisionUpdateWithoutPublisherInput, RevisionUncheckedUpdateWithoutPublisherInput>
    create: XOR<RevisionCreateWithoutPublisherInput, RevisionUncheckedCreateWithoutPublisherInput>
  }

  export type RevisionUpdateWithWhereUniqueWithoutPublisherInput = {
    where: RevisionWhereUniqueInput
    data: XOR<RevisionUpdateWithoutPublisherInput, RevisionUncheckedUpdateWithoutPublisherInput>
  }

  export type RevisionUpdateManyWithWhereWithoutPublisherInput = {
    where: RevisionScalarWhereInput
    data: XOR<RevisionUpdateManyMutationInput, RevisionUncheckedUpdateManyWithoutPublisherInput>
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type QuickEditItemUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QuickEditItemWhereUniqueInput
    update: XOR<QuickEditItemUpdateWithoutCreatorInput, QuickEditItemUncheckedUpdateWithoutCreatorInput>
    create: XOR<QuickEditItemCreateWithoutCreatorInput, QuickEditItemUncheckedCreateWithoutCreatorInput>
  }

  export type QuickEditItemUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QuickEditItemWhereUniqueInput
    data: XOR<QuickEditItemUpdateWithoutCreatorInput, QuickEditItemUncheckedUpdateWithoutCreatorInput>
  }

  export type QuickEditItemUpdateManyWithWhereWithoutCreatorInput = {
    where: QuickEditItemScalarWhereInput
    data: XOR<QuickEditItemUpdateManyMutationInput, QuickEditItemUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QuickEditItemScalarWhereInput = {
    AND?: QuickEditItemScalarWhereInput | QuickEditItemScalarWhereInput[]
    OR?: QuickEditItemScalarWhereInput[]
    NOT?: QuickEditItemScalarWhereInput | QuickEditItemScalarWhereInput[]
    id?: StringFilter<"QuickEditItem"> | string
    key?: StringFilter<"QuickEditItem"> | string
    type?: EnumQuickEditTypeFilter<"QuickEditItem"> | $Enums.QuickEditType
    page?: StringFilter<"QuickEditItem"> | string
    component?: StringFilter<"QuickEditItem"> | string
    element?: StringFilter<"QuickEditItem"> | string
    value?: StringFilter<"QuickEditItem"> | string
    defaultValue?: StringFilter<"QuickEditItem"> | string
    isActive?: BoolFilter<"QuickEditItem"> | boolean
    metadata?: JsonNullableFilter<"QuickEditItem">
    createdAt?: DateTimeFilter<"QuickEditItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuickEditItem"> | Date | string
    createdById?: StringFilter<"QuickEditItem"> | string
  }

  export type QuickEditRevisionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QuickEditRevisionWhereUniqueInput
    update: XOR<QuickEditRevisionUpdateWithoutCreatorInput, QuickEditRevisionUncheckedUpdateWithoutCreatorInput>
    create: XOR<QuickEditRevisionCreateWithoutCreatorInput, QuickEditRevisionUncheckedCreateWithoutCreatorInput>
  }

  export type QuickEditRevisionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QuickEditRevisionWhereUniqueInput
    data: XOR<QuickEditRevisionUpdateWithoutCreatorInput, QuickEditRevisionUncheckedUpdateWithoutCreatorInput>
  }

  export type QuickEditRevisionUpdateManyWithWhereWithoutCreatorInput = {
    where: QuickEditRevisionScalarWhereInput
    data: XOR<QuickEditRevisionUpdateManyMutationInput, QuickEditRevisionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QuickEditRevisionScalarWhereInput = {
    AND?: QuickEditRevisionScalarWhereInput | QuickEditRevisionScalarWhereInput[]
    OR?: QuickEditRevisionScalarWhereInput[]
    NOT?: QuickEditRevisionScalarWhereInput | QuickEditRevisionScalarWhereInput[]
    id?: StringFilter<"QuickEditRevision"> | string
    itemId?: StringFilter<"QuickEditRevision"> | string
    value?: StringFilter<"QuickEditRevision"> | string
    changeType?: StringFilter<"QuickEditRevision"> | string
    createdAt?: DateTimeFilter<"QuickEditRevision"> | Date | string
    createdById?: StringFilter<"QuickEditRevision"> | string
  }

  export type ThemeSettingUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ThemeSettingWhereUniqueInput
    update: XOR<ThemeSettingUpdateWithoutCreatorInput, ThemeSettingUncheckedUpdateWithoutCreatorInput>
    create: XOR<ThemeSettingCreateWithoutCreatorInput, ThemeSettingUncheckedCreateWithoutCreatorInput>
  }

  export type ThemeSettingUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ThemeSettingWhereUniqueInput
    data: XOR<ThemeSettingUpdateWithoutCreatorInput, ThemeSettingUncheckedUpdateWithoutCreatorInput>
  }

  export type ThemeSettingUpdateManyWithWhereWithoutCreatorInput = {
    where: ThemeSettingScalarWhereInput
    data: XOR<ThemeSettingUpdateManyMutationInput, ThemeSettingUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ThemeSettingScalarWhereInput = {
    AND?: ThemeSettingScalarWhereInput | ThemeSettingScalarWhereInput[]
    OR?: ThemeSettingScalarWhereInput[]
    NOT?: ThemeSettingScalarWhereInput | ThemeSettingScalarWhereInput[]
    id?: StringFilter<"ThemeSetting"> | string
    name?: StringFilter<"ThemeSetting"> | string
    category?: StringFilter<"ThemeSetting"> | string
    value?: StringFilter<"ThemeSetting"> | string
    cssVariable?: StringFilter<"ThemeSetting"> | string
    description?: StringNullableFilter<"ThemeSetting"> | string | null
    isActive?: BoolFilter<"ThemeSetting"> | boolean
    createdAt?: DateTimeFilter<"ThemeSetting"> | Date | string
    updatedAt?: DateTimeFilter<"ThemeSetting"> | Date | string
    createdById?: StringFilter<"ThemeSetting"> | string
  }

  export type LivePreviewTokenUpsertWithWhereUniqueWithoutCreatorInput = {
    where: LivePreviewTokenWhereUniqueInput
    update: XOR<LivePreviewTokenUpdateWithoutCreatorInput, LivePreviewTokenUncheckedUpdateWithoutCreatorInput>
    create: XOR<LivePreviewTokenCreateWithoutCreatorInput, LivePreviewTokenUncheckedCreateWithoutCreatorInput>
  }

  export type LivePreviewTokenUpdateWithWhereUniqueWithoutCreatorInput = {
    where: LivePreviewTokenWhereUniqueInput
    data: XOR<LivePreviewTokenUpdateWithoutCreatorInput, LivePreviewTokenUncheckedUpdateWithoutCreatorInput>
  }

  export type LivePreviewTokenUpdateManyWithWhereWithoutCreatorInput = {
    where: LivePreviewTokenScalarWhereInput
    data: XOR<LivePreviewTokenUpdateManyMutationInput, LivePreviewTokenUncheckedUpdateManyWithoutCreatorInput>
  }

  export type LivePreviewTokenScalarWhereInput = {
    AND?: LivePreviewTokenScalarWhereInput | LivePreviewTokenScalarWhereInput[]
    OR?: LivePreviewTokenScalarWhereInput[]
    NOT?: LivePreviewTokenScalarWhereInput | LivePreviewTokenScalarWhereInput[]
    id?: StringFilter<"LivePreviewToken"> | string
    token?: StringFilter<"LivePreviewToken"> | string
    page?: StringFilter<"LivePreviewToken"> | string
    changes?: JsonFilter<"LivePreviewToken">
    expiresAt?: DateTimeFilter<"LivePreviewToken"> | Date | string
    createdAt?: DateTimeFilter<"LivePreviewToken"> | Date | string
    createdById?: StringFilter<"LivePreviewToken"> | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutCreatedCoursesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedCoursesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
  }

  export type LessonCreateWithoutCourseInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLessonsInput
  }

  export type LessonUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type LessonCreateOrConnectWithoutCourseInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonCreateManyCourseInputEnvelope = {
    data: LessonCreateManyCourseInput | LessonCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type PackageCourseCreateWithoutCourseInput = {
    id?: string
    package: PackageCreateNestedOneWithoutPackageCoursesInput
  }

  export type PackageCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    packageId: string
  }

  export type PackageCourseCreateOrConnectWithoutCourseInput = {
    where: PackageCourseWhereUniqueInput
    create: XOR<PackageCourseCreateWithoutCourseInput, PackageCourseUncheckedCreateWithoutCourseInput>
  }

  export type PackageCourseCreateManyCourseInputEnvelope = {
    data: PackageCourseCreateManyCourseInput | PackageCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type SeoMetaCreateWithoutCourseInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    package?: PackageCreateNestedOneWithoutSeoMetaInput
    blogPost?: BlogPostCreateNestedOneWithoutSeoMetaInput
    page?: PageCreateNestedOneWithoutSeoMetaInput
  }

  export type SeoMetaUncheckedCreateWithoutCourseInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    packageId?: string | null
    blogPostId?: string | null
    pageId?: string | null
  }

  export type SeoMetaCreateOrConnectWithoutCourseInput = {
    where: SeoMetaWhereUniqueInput
    create: XOR<SeoMetaCreateWithoutCourseInput, SeoMetaUncheckedCreateWithoutCourseInput>
  }

  export type UserUpsertWithoutCreatedCoursesInput = {
    update: XOR<UserUpdateWithoutCreatedCoursesInput, UserUncheckedUpdateWithoutCreatedCoursesInput>
    create: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCoursesInput, UserUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type UserUpdateWithoutCreatedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
  }

  export type LessonUpdateManyWithWhereWithoutCourseInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutCourseInput>
  }

  export type PackageCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: PackageCourseWhereUniqueInput
    update: XOR<PackageCourseUpdateWithoutCourseInput, PackageCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<PackageCourseCreateWithoutCourseInput, PackageCourseUncheckedCreateWithoutCourseInput>
  }

  export type PackageCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: PackageCourseWhereUniqueInput
    data: XOR<PackageCourseUpdateWithoutCourseInput, PackageCourseUncheckedUpdateWithoutCourseInput>
  }

  export type PackageCourseUpdateManyWithWhereWithoutCourseInput = {
    where: PackageCourseScalarWhereInput
    data: XOR<PackageCourseUpdateManyMutationInput, PackageCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type PackageCourseScalarWhereInput = {
    AND?: PackageCourseScalarWhereInput | PackageCourseScalarWhereInput[]
    OR?: PackageCourseScalarWhereInput[]
    NOT?: PackageCourseScalarWhereInput | PackageCourseScalarWhereInput[]
    id?: StringFilter<"PackageCourse"> | string
    packageId?: StringFilter<"PackageCourse"> | string
    courseId?: StringFilter<"PackageCourse"> | string
  }

  export type SeoMetaUpsertWithoutCourseInput = {
    update: XOR<SeoMetaUpdateWithoutCourseInput, SeoMetaUncheckedUpdateWithoutCourseInput>
    create: XOR<SeoMetaCreateWithoutCourseInput, SeoMetaUncheckedCreateWithoutCourseInput>
    where?: SeoMetaWhereInput
  }

  export type SeoMetaUpdateToOneWithWhereWithoutCourseInput = {
    where?: SeoMetaWhereInput
    data: XOR<SeoMetaUpdateWithoutCourseInput, SeoMetaUncheckedUpdateWithoutCourseInput>
  }

  export type SeoMetaUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    package?: PackageUpdateOneWithoutSeoMetaNestedInput
    blogPost?: BlogPostUpdateOneWithoutSeoMetaNestedInput
    page?: PageUpdateOneWithoutSeoMetaNestedInput
  }

  export type SeoMetaUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutCreatedLessonsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedLessonsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedLessonsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLessonsInput, UserUncheckedCreateWithoutCreatedLessonsInput>
  }

  export type CourseCreateWithoutLessonsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    packageCourses?: PackageCourseCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLessonsInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLessonsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
  }

  export type UserUpsertWithoutCreatedLessonsInput = {
    update: XOR<UserUpdateWithoutCreatedLessonsInput, UserUncheckedUpdateWithoutCreatedLessonsInput>
    create: XOR<UserCreateWithoutCreatedLessonsInput, UserUncheckedCreateWithoutCreatedLessonsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLessonsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLessonsInput, UserUncheckedUpdateWithoutCreatedLessonsInput>
  }

  export type UserUpdateWithoutCreatedLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CourseUpsertWithoutLessonsInput = {
    update: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLessonsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    packageCourses?: PackageCourseUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type UserCreateWithoutCreatedPackagesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedPackagesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedPackagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPackagesInput, UserUncheckedCreateWithoutCreatedPackagesInput>
  }

  export type PackageCourseCreateWithoutPackageInput = {
    id?: string
    course: CourseCreateNestedOneWithoutPackageCoursesInput
  }

  export type PackageCourseUncheckedCreateWithoutPackageInput = {
    id?: string
    courseId: string
  }

  export type PackageCourseCreateOrConnectWithoutPackageInput = {
    where: PackageCourseWhereUniqueInput
    create: XOR<PackageCourseCreateWithoutPackageInput, PackageCourseUncheckedCreateWithoutPackageInput>
  }

  export type PackageCourseCreateManyPackageInputEnvelope = {
    data: PackageCourseCreateManyPackageInput | PackageCourseCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type SeoMetaCreateWithoutPackageInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    course?: CourseCreateNestedOneWithoutSeoMetaInput
    blogPost?: BlogPostCreateNestedOneWithoutSeoMetaInput
    page?: PageCreateNestedOneWithoutSeoMetaInput
  }

  export type SeoMetaUncheckedCreateWithoutPackageInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    courseId?: string | null
    blogPostId?: string | null
    pageId?: string | null
  }

  export type SeoMetaCreateOrConnectWithoutPackageInput = {
    where: SeoMetaWhereUniqueInput
    create: XOR<SeoMetaCreateWithoutPackageInput, SeoMetaUncheckedCreateWithoutPackageInput>
  }

  export type UserUpsertWithoutCreatedPackagesInput = {
    update: XOR<UserUpdateWithoutCreatedPackagesInput, UserUncheckedUpdateWithoutCreatedPackagesInput>
    create: XOR<UserCreateWithoutCreatedPackagesInput, UserUncheckedCreateWithoutCreatedPackagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPackagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPackagesInput, UserUncheckedUpdateWithoutCreatedPackagesInput>
  }

  export type UserUpdateWithoutCreatedPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PackageCourseUpsertWithWhereUniqueWithoutPackageInput = {
    where: PackageCourseWhereUniqueInput
    update: XOR<PackageCourseUpdateWithoutPackageInput, PackageCourseUncheckedUpdateWithoutPackageInput>
    create: XOR<PackageCourseCreateWithoutPackageInput, PackageCourseUncheckedCreateWithoutPackageInput>
  }

  export type PackageCourseUpdateWithWhereUniqueWithoutPackageInput = {
    where: PackageCourseWhereUniqueInput
    data: XOR<PackageCourseUpdateWithoutPackageInput, PackageCourseUncheckedUpdateWithoutPackageInput>
  }

  export type PackageCourseUpdateManyWithWhereWithoutPackageInput = {
    where: PackageCourseScalarWhereInput
    data: XOR<PackageCourseUpdateManyMutationInput, PackageCourseUncheckedUpdateManyWithoutPackageInput>
  }

  export type SeoMetaUpsertWithoutPackageInput = {
    update: XOR<SeoMetaUpdateWithoutPackageInput, SeoMetaUncheckedUpdateWithoutPackageInput>
    create: XOR<SeoMetaCreateWithoutPackageInput, SeoMetaUncheckedCreateWithoutPackageInput>
    where?: SeoMetaWhereInput
  }

  export type SeoMetaUpdateToOneWithWhereWithoutPackageInput = {
    where?: SeoMetaWhereInput
    data: XOR<SeoMetaUpdateWithoutPackageInput, SeoMetaUncheckedUpdateWithoutPackageInput>
  }

  export type SeoMetaUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutSeoMetaNestedInput
    blogPost?: BlogPostUpdateOneWithoutSeoMetaNestedInput
    page?: PageUpdateOneWithoutSeoMetaNestedInput
  }

  export type SeoMetaUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageCreateWithoutPackageCoursesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPackagesInput
    seoMeta?: SeoMetaCreateNestedOneWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutPackageCoursesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutPackageCoursesInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutPackageCoursesInput, PackageUncheckedCreateWithoutPackageCoursesInput>
  }

  export type CourseCreateWithoutPackageCoursesInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPackageCoursesInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPackageCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPackageCoursesInput, CourseUncheckedCreateWithoutPackageCoursesInput>
  }

  export type PackageUpsertWithoutPackageCoursesInput = {
    update: XOR<PackageUpdateWithoutPackageCoursesInput, PackageUncheckedUpdateWithoutPackageCoursesInput>
    create: XOR<PackageCreateWithoutPackageCoursesInput, PackageUncheckedCreateWithoutPackageCoursesInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutPackageCoursesInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutPackageCoursesInput, PackageUncheckedUpdateWithoutPackageCoursesInput>
  }

  export type PackageUpdateWithoutPackageCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPackagesNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutPackageCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutPackageNestedInput
  }

  export type CourseUpsertWithoutPackageCoursesInput = {
    update: XOR<CourseUpdateWithoutPackageCoursesInput, CourseUncheckedUpdateWithoutPackageCoursesInput>
    create: XOR<CourseCreateWithoutPackageCoursesInput, CourseUncheckedCreateWithoutPackageCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPackageCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPackageCoursesInput, CourseUncheckedUpdateWithoutPackageCoursesInput>
  }

  export type CourseUpdateWithoutPackageCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPackageCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type UserCreateWithoutCreatedBlogPostsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedBlogPostsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBlogPostsInput, UserUncheckedCreateWithoutCreatedBlogPostsInput>
  }

  export type AuthorCreateWithoutBlogPostsInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    user?: UserCreateNestedOneWithoutAuthorProfileInput
  }

  export type AuthorUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    name: string
    bio?: string | null
    avatar?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: string | null
    userId?: string | null
  }

  export type AuthorCreateOrConnectWithoutBlogPostsInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutBlogPostsInput, AuthorUncheckedCreateWithoutBlogPostsInput>
  }

  export type SeoMetaCreateWithoutBlogPostInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    course?: CourseCreateNestedOneWithoutSeoMetaInput
    package?: PackageCreateNestedOneWithoutSeoMetaInput
    page?: PageCreateNestedOneWithoutSeoMetaInput
  }

  export type SeoMetaUncheckedCreateWithoutBlogPostInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    courseId?: string | null
    packageId?: string | null
    pageId?: string | null
  }

  export type SeoMetaCreateOrConnectWithoutBlogPostInput = {
    where: SeoMetaWhereUniqueInput
    create: XOR<SeoMetaCreateWithoutBlogPostInput, SeoMetaUncheckedCreateWithoutBlogPostInput>
  }

  export type UserUpsertWithoutCreatedBlogPostsInput = {
    update: XOR<UserUpdateWithoutCreatedBlogPostsInput, UserUncheckedUpdateWithoutCreatedBlogPostsInput>
    create: XOR<UserCreateWithoutCreatedBlogPostsInput, UserUncheckedCreateWithoutCreatedBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBlogPostsInput, UserUncheckedUpdateWithoutCreatedBlogPostsInput>
  }

  export type UserUpdateWithoutCreatedBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AuthorUpsertWithoutBlogPostsInput = {
    update: XOR<AuthorUpdateWithoutBlogPostsInput, AuthorUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<AuthorCreateWithoutBlogPostsInput, AuthorUncheckedCreateWithoutBlogPostsInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutBlogPostsInput, AuthorUncheckedUpdateWithoutBlogPostsInput>
  }

  export type AuthorUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAuthorProfileNestedInput
  }

  export type AuthorUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeoMetaUpsertWithoutBlogPostInput = {
    update: XOR<SeoMetaUpdateWithoutBlogPostInput, SeoMetaUncheckedUpdateWithoutBlogPostInput>
    create: XOR<SeoMetaCreateWithoutBlogPostInput, SeoMetaUncheckedCreateWithoutBlogPostInput>
    where?: SeoMetaWhereInput
  }

  export type SeoMetaUpdateToOneWithWhereWithoutBlogPostInput = {
    where?: SeoMetaWhereInput
    data: XOR<SeoMetaUpdateWithoutBlogPostInput, SeoMetaUncheckedUpdateWithoutBlogPostInput>
  }

  export type SeoMetaUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutSeoMetaNestedInput
    package?: PackageUpdateOneWithoutSeoMetaNestedInput
    page?: PageUpdateOneWithoutSeoMetaNestedInput
  }

  export type SeoMetaUncheckedUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutCreatedPagesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedPagesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedPagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
  }

  export type SeoMetaCreateWithoutPageInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    course?: CourseCreateNestedOneWithoutSeoMetaInput
    package?: PackageCreateNestedOneWithoutSeoMetaInput
    blogPost?: BlogPostCreateNestedOneWithoutSeoMetaInput
  }

  export type SeoMetaUncheckedCreateWithoutPageInput = {
    id?: string
    title?: string | null
    description?: string | null
    keywords?: string | null
    canonical?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    twitterCard?: string | null
    noIndex?: boolean
    noFollow?: boolean
    courseId?: string | null
    packageId?: string | null
    blogPostId?: string | null
  }

  export type SeoMetaCreateOrConnectWithoutPageInput = {
    where: SeoMetaWhereUniqueInput
    create: XOR<SeoMetaCreateWithoutPageInput, SeoMetaUncheckedCreateWithoutPageInput>
  }

  export type UserUpsertWithoutCreatedPagesInput = {
    update: XOR<UserUpdateWithoutCreatedPagesInput, UserUncheckedUpdateWithoutCreatedPagesInput>
    create: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPagesInput, UserUncheckedUpdateWithoutCreatedPagesInput>
  }

  export type UserUpdateWithoutCreatedPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SeoMetaUpsertWithoutPageInput = {
    update: XOR<SeoMetaUpdateWithoutPageInput, SeoMetaUncheckedUpdateWithoutPageInput>
    create: XOR<SeoMetaCreateWithoutPageInput, SeoMetaUncheckedCreateWithoutPageInput>
    where?: SeoMetaWhereInput
  }

  export type SeoMetaUpdateToOneWithWhereWithoutPageInput = {
    where?: SeoMetaWhereInput
    data: XOR<SeoMetaUpdateWithoutPageInput, SeoMetaUncheckedUpdateWithoutPageInput>
  }

  export type SeoMetaUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutSeoMetaNestedInput
    package?: PackageUpdateOneWithoutSeoMetaNestedInput
    blogPost?: BlogPostUpdateOneWithoutSeoMetaNestedInput
  }

  export type SeoMetaUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    noFollow?: BoolFieldUpdateOperationsInput | boolean
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutAuthorProfileInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuthorProfileInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuthorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorProfileInput, UserUncheckedCreateWithoutAuthorProfileInput>
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedBlogPostsInput
    seoMeta?: SeoMetaCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    seoMeta?: SeoMetaUncheckedCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAuthorProfileInput = {
    update: XOR<UserUpdateWithoutAuthorProfileInput, UserUncheckedUpdateWithoutAuthorProfileInput>
    create: XOR<UserCreateWithoutAuthorProfileInput, UserUncheckedCreateWithoutAuthorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorProfileInput, UserUncheckedUpdateWithoutAuthorProfileInput>
  }

  export type UserUpdateWithoutAuthorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CourseCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    packageCourses?: PackageCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSeoMetaInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSeoMetaInput, CourseUncheckedCreateWithoutSeoMetaInput>
  }

  export type PackageCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPackagesInput
    packageCourses?: PackageCourseCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    packageCourses?: PackageCourseUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutSeoMetaInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutSeoMetaInput, PackageUncheckedCreateWithoutSeoMetaInput>
  }

  export type BlogPostCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedBlogPostsInput
    author?: AuthorCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    authorId?: string | null
  }

  export type BlogPostCreateOrConnectWithoutSeoMetaInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSeoMetaInput, BlogPostUncheckedCreateWithoutSeoMetaInput>
  }

  export type PageCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPagesInput
  }

  export type PageUncheckedCreateWithoutSeoMetaInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PageCreateOrConnectWithoutSeoMetaInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutSeoMetaInput, PageUncheckedCreateWithoutSeoMetaInput>
  }

  export type CourseUpsertWithoutSeoMetaInput = {
    update: XOR<CourseUpdateWithoutSeoMetaInput, CourseUncheckedUpdateWithoutSeoMetaInput>
    create: XOR<CourseCreateWithoutSeoMetaInput, CourseUncheckedCreateWithoutSeoMetaInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSeoMetaInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSeoMetaInput, CourseUncheckedUpdateWithoutSeoMetaInput>
  }

  export type CourseUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    packageCourses?: PackageCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type PackageUpsertWithoutSeoMetaInput = {
    update: XOR<PackageUpdateWithoutSeoMetaInput, PackageUncheckedUpdateWithoutSeoMetaInput>
    create: XOR<PackageCreateWithoutSeoMetaInput, PackageUncheckedCreateWithoutSeoMetaInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutSeoMetaInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutSeoMetaInput, PackageUncheckedUpdateWithoutSeoMetaInput>
  }

  export type PackageUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPackagesNestedInput
    packageCourses?: PackageCourseUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type BlogPostUpsertWithoutSeoMetaInput = {
    update: XOR<BlogPostUpdateWithoutSeoMetaInput, BlogPostUncheckedUpdateWithoutSeoMetaInput>
    create: XOR<BlogPostCreateWithoutSeoMetaInput, BlogPostUncheckedCreateWithoutSeoMetaInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutSeoMetaInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutSeoMetaInput, BlogPostUncheckedUpdateWithoutSeoMetaInput>
  }

  export type BlogPostUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedBlogPostsNestedInput
    author?: AuthorUpdateOneWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageUpsertWithoutSeoMetaInput = {
    update: XOR<PageUpdateWithoutSeoMetaInput, PageUncheckedUpdateWithoutSeoMetaInput>
    create: XOR<PageCreateWithoutSeoMetaInput, PageUncheckedCreateWithoutSeoMetaInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutSeoMetaInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutSeoMetaInput, PageUncheckedUpdateWithoutSeoMetaInput>
  }

  export type PageUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPagesNestedInput
  }

  export type PageUncheckedUpdateWithoutSeoMetaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutCreatedRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRevisionsInput, UserUncheckedCreateWithoutCreatedRevisionsInput>
  }

  export type UserCreateWithoutReviewedRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReviewedRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReviewedRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedRevisionsInput, UserUncheckedCreateWithoutReviewedRevisionsInput>
  }

  export type UserCreateWithoutPublishedRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPublishedRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPublishedRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublishedRevisionsInput, UserUncheckedCreateWithoutPublishedRevisionsInput>
  }

  export type UserUpsertWithoutCreatedRevisionsInput = {
    update: XOR<UserUpdateWithoutCreatedRevisionsInput, UserUncheckedUpdateWithoutCreatedRevisionsInput>
    create: XOR<UserCreateWithoutCreatedRevisionsInput, UserUncheckedCreateWithoutCreatedRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRevisionsInput, UserUncheckedUpdateWithoutCreatedRevisionsInput>
  }

  export type UserUpdateWithoutCreatedRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutReviewedRevisionsInput = {
    update: XOR<UserUpdateWithoutReviewedRevisionsInput, UserUncheckedUpdateWithoutReviewedRevisionsInput>
    create: XOR<UserCreateWithoutReviewedRevisionsInput, UserUncheckedCreateWithoutReviewedRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedRevisionsInput, UserUncheckedUpdateWithoutReviewedRevisionsInput>
  }

  export type UserUpdateWithoutReviewedRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutPublishedRevisionsInput = {
    update: XOR<UserUpdateWithoutPublishedRevisionsInput, UserUncheckedUpdateWithoutPublishedRevisionsInput>
    create: XOR<UserCreateWithoutPublishedRevisionsInput, UserUncheckedCreateWithoutPublishedRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPublishedRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPublishedRevisionsInput, UserUncheckedUpdateWithoutPublishedRevisionsInput>
  }

  export type UserUpdateWithoutPublishedRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPublishedRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutCreatedSectionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedSectionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedSectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSectionsInput, UserUncheckedCreateWithoutCreatedSectionsInput>
  }

  export type UserUpsertWithoutCreatedSectionsInput = {
    update: XOR<UserUpdateWithoutCreatedSectionsInput, UserUncheckedUpdateWithoutCreatedSectionsInput>
    create: XOR<UserCreateWithoutCreatedSectionsInput, UserUncheckedCreateWithoutCreatedSectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSectionsInput, UserUncheckedUpdateWithoutCreatedSectionsInput>
  }

  export type UserUpdateWithoutCreatedSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutQuickEditItemsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutQuickEditItemsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutQuickEditItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuickEditItemsInput, UserUncheckedCreateWithoutQuickEditItemsInput>
  }

  export type QuickEditRevisionCreateWithoutItemInput = {
    id?: string
    value: string
    changeType: string
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutQuickEditRevisionsInput
  }

  export type QuickEditRevisionUncheckedCreateWithoutItemInput = {
    id?: string
    value: string
    changeType: string
    createdAt?: Date | string
    createdById: string
  }

  export type QuickEditRevisionCreateOrConnectWithoutItemInput = {
    where: QuickEditRevisionWhereUniqueInput
    create: XOR<QuickEditRevisionCreateWithoutItemInput, QuickEditRevisionUncheckedCreateWithoutItemInput>
  }

  export type QuickEditRevisionCreateManyItemInputEnvelope = {
    data: QuickEditRevisionCreateManyItemInput | QuickEditRevisionCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuickEditItemsInput = {
    update: XOR<UserUpdateWithoutQuickEditItemsInput, UserUncheckedUpdateWithoutQuickEditItemsInput>
    create: XOR<UserCreateWithoutQuickEditItemsInput, UserUncheckedCreateWithoutQuickEditItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuickEditItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuickEditItemsInput, UserUncheckedUpdateWithoutQuickEditItemsInput>
  }

  export type UserUpdateWithoutQuickEditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutQuickEditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type QuickEditRevisionUpsertWithWhereUniqueWithoutItemInput = {
    where: QuickEditRevisionWhereUniqueInput
    update: XOR<QuickEditRevisionUpdateWithoutItemInput, QuickEditRevisionUncheckedUpdateWithoutItemInput>
    create: XOR<QuickEditRevisionCreateWithoutItemInput, QuickEditRevisionUncheckedCreateWithoutItemInput>
  }

  export type QuickEditRevisionUpdateWithWhereUniqueWithoutItemInput = {
    where: QuickEditRevisionWhereUniqueInput
    data: XOR<QuickEditRevisionUpdateWithoutItemInput, QuickEditRevisionUncheckedUpdateWithoutItemInput>
  }

  export type QuickEditRevisionUpdateManyWithWhereWithoutItemInput = {
    where: QuickEditRevisionScalarWhereInput
    data: XOR<QuickEditRevisionUpdateManyMutationInput, QuickEditRevisionUncheckedUpdateManyWithoutItemInput>
  }

  export type QuickEditItemCreateWithoutRevisionsInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutQuickEditItemsInput
  }

  export type QuickEditItemUncheckedCreateWithoutRevisionsInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type QuickEditItemCreateOrConnectWithoutRevisionsInput = {
    where: QuickEditItemWhereUniqueInput
    create: XOR<QuickEditItemCreateWithoutRevisionsInput, QuickEditItemUncheckedCreateWithoutRevisionsInput>
  }

  export type UserCreateWithoutQuickEditRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutQuickEditRevisionsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutQuickEditRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuickEditRevisionsInput, UserUncheckedCreateWithoutQuickEditRevisionsInput>
  }

  export type QuickEditItemUpsertWithoutRevisionsInput = {
    update: XOR<QuickEditItemUpdateWithoutRevisionsInput, QuickEditItemUncheckedUpdateWithoutRevisionsInput>
    create: XOR<QuickEditItemCreateWithoutRevisionsInput, QuickEditItemUncheckedCreateWithoutRevisionsInput>
    where?: QuickEditItemWhereInput
  }

  export type QuickEditItemUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: QuickEditItemWhereInput
    data: XOR<QuickEditItemUpdateWithoutRevisionsInput, QuickEditItemUncheckedUpdateWithoutRevisionsInput>
  }

  export type QuickEditItemUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutQuickEditItemsNestedInput
  }

  export type QuickEditItemUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutQuickEditRevisionsInput = {
    update: XOR<UserUpdateWithoutQuickEditRevisionsInput, UserUncheckedUpdateWithoutQuickEditRevisionsInput>
    create: XOR<UserCreateWithoutQuickEditRevisionsInput, UserUncheckedCreateWithoutQuickEditRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuickEditRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuickEditRevisionsInput, UserUncheckedUpdateWithoutQuickEditRevisionsInput>
  }

  export type UserUpdateWithoutQuickEditRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutQuickEditRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutThemeSettingsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutThemeSettingsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutThemeSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThemeSettingsInput, UserUncheckedCreateWithoutThemeSettingsInput>
  }

  export type UserUpsertWithoutThemeSettingsInput = {
    update: XOR<UserUpdateWithoutThemeSettingsInput, UserUncheckedUpdateWithoutThemeSettingsInput>
    create: XOR<UserCreateWithoutThemeSettingsInput, UserUncheckedCreateWithoutThemeSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutThemeSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutThemeSettingsInput, UserUncheckedUpdateWithoutThemeSettingsInput>
  }

  export type UserUpdateWithoutThemeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutThemeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutLivePreviewTokensInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutLivePreviewTokensInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutLivePreviewTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLivePreviewTokensInput, UserUncheckedCreateWithoutLivePreviewTokensInput>
  }

  export type UserUpsertWithoutLivePreviewTokensInput = {
    update: XOR<UserUpdateWithoutLivePreviewTokensInput, UserUncheckedUpdateWithoutLivePreviewTokensInput>
    create: XOR<UserCreateWithoutLivePreviewTokensInput, UserUncheckedCreateWithoutLivePreviewTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLivePreviewTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLivePreviewTokensInput, UserUncheckedUpdateWithoutLivePreviewTokensInput>
  }

  export type UserUpdateWithoutLivePreviewTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutLivePreviewTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorCreateNestedOneWithoutUserInput
    createdRevisions?: RevisionCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdLessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    createdPackages?: PackageUncheckedCreateNestedManyWithoutCreatorInput
    createdBlogPosts?: BlogPostUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdSections?: ContentSectionUncheckedCreateNestedManyWithoutCreatorInput
    authorProfile?: AuthorUncheckedCreateNestedOneWithoutUserInput
    createdRevisions?: RevisionUncheckedCreateNestedManyWithoutCreatorInput
    reviewedRevisions?: RevisionUncheckedCreateNestedManyWithoutReviewerInput
    publishedRevisions?: RevisionUncheckedCreateNestedManyWithoutPublisherInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quickEditItems?: QuickEditItemUncheckedCreateNestedManyWithoutCreatorInput
    quickEditRevisions?: QuickEditRevisionUncheckedCreateNestedManyWithoutCreatorInput
    themeSettings?: ThemeSettingUncheckedCreateNestedManyWithoutCreatorInput
    livePreviewTokens?: LivePreviewTokenUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUpdateOneWithoutUserNestedInput
    createdRevisions?: RevisionUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdLessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    createdPackages?: PackageUncheckedUpdateManyWithoutCreatorNestedInput
    createdBlogPosts?: BlogPostUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdSections?: ContentSectionUncheckedUpdateManyWithoutCreatorNestedInput
    authorProfile?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    createdRevisions?: RevisionUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedRevisions?: RevisionUncheckedUpdateManyWithoutReviewerNestedInput
    publishedRevisions?: RevisionUncheckedUpdateManyWithoutPublisherNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quickEditItems?: QuickEditItemUncheckedUpdateManyWithoutCreatorNestedInput
    quickEditRevisions?: QuickEditRevisionUncheckedUpdateManyWithoutCreatorNestedInput
    themeSettings?: ThemeSettingUncheckedUpdateManyWithoutCreatorNestedInput
    livePreviewTokens?: LivePreviewTokenUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CourseCreateManyCreatorInput = {
    id?: string
    title: string
    subtitle?: string | null
    slug: string
    shortDescription?: string | null
    longDescription?: string | null
    coverImage?: string | null
    gallery?: CourseCreategalleryInput | string[]
    duration?: number | null
    level?: $Enums.CourseLevel
    language?: string
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    tags?: CourseCreatetagsInput | string[]
    categories?: CourseCreatecategoriesInput | string[]
    status?: $Enums.ContentStatus
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateManyCreatorInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    courseId: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageCreateManyCreatorInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    type?: $Enums.PackageType
    features?: PackageCreatefeaturesInput | string[]
    validityDays?: number | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyCreatorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
  }

  export type PageCreateManyCreatorInput = {
    id?: string
    title: string
    slug: string
    layout?: string
    content: string
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentSectionCreateManyCreatorInput = {
    id?: string
    type: string
    content: JsonNullValueInput | InputJsonValue
    order: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: boolean
    contentType: $Enums.ContentType
    contentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type RevisionCreateManyCreatorInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    reviewedById?: string | null
    publishedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionCreateManyReviewerInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    createdById: string
    publishedById?: string | null
    reviewNotes?: string | null
  }

  export type RevisionCreateManyPublisherInput = {
    id?: string
    contentType: $Enums.ContentType
    contentId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    status?: $Enums.RevisionStatus
    previewToken?: string | null
    previewExpiresAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    createdById: string
    reviewedById?: string | null
    reviewNotes?: string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type QuickEditItemCreateManyCreatorInput = {
    id?: string
    key: string
    type: $Enums.QuickEditType
    page: string
    component: string
    element: string
    value: string
    defaultValue: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickEditRevisionCreateManyCreatorInput = {
    id?: string
    itemId: string
    value: string
    changeType: string
    createdAt?: Date | string
  }

  export type ThemeSettingCreateManyCreatorInput = {
    id?: string
    name: string
    category: string
    value: string
    cssVariable: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivePreviewTokenCreateManyCreatorInput = {
    id?: string
    token: string
    page: string
    changes: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CourseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    packageCourses?: PackageCourseUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutCourseNestedInput
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: CourseUpdategalleryInput | string[]
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    level?: EnumCourseLevelFieldUpdateOperationsInput | $Enums.CourseLevel
    language?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    tags?: CourseUpdatetagsInput | string[]
    categories?: CourseUpdatecategoriesInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packageCourses?: PackageCourseUpdateManyWithoutPackageNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packageCourses?: PackageCourseUncheckedUpdateManyWithoutPackageNestedInput
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    features?: PackageUpdatefeaturesInput | string[]
    validityDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutBlogPostsNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoMeta?: SeoMetaUpdateOneWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentSectionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentSectionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentSectionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevisionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewer?: UserUpdateOneWithoutReviewedRevisionsNestedInput
    publisher?: UserUpdateOneWithoutPublishedRevisionsNestedInput
  }

  export type RevisionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedRevisionsNestedInput
    publisher?: UserUpdateOneWithoutPublishedRevisionsNestedInput
  }

  export type RevisionUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedRevisionsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedRevisionsNestedInput
  }

  export type RevisionUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevisionUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    contentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: EnumRevisionStatusFieldUpdateOperationsInput | $Enums.RevisionStatus
    previewToken?: NullableStringFieldUpdateOperationsInput | string | null
    previewExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickEditItemUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: QuickEditRevisionUpdateManyWithoutItemNestedInput
  }

  export type QuickEditItemUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: QuickEditRevisionUncheckedUpdateManyWithoutItemNestedInput
  }

  export type QuickEditItemUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: EnumQuickEditTypeFieldUpdateOperationsInput | $Enums.QuickEditType
    page?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    element?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    defaultValue?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickEditRevisionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: QuickEditItemUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type QuickEditRevisionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickEditRevisionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeSettingUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeSettingUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeSettingUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cssVariable?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivePreviewTokenUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivePreviewTokenUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivePreviewTokenUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyCourseInput = {
    id?: string
    title: string
    slug: string
    content: string
    order: number
    duration?: number | null
    resources?: LessonCreateresourcesInput | string[]
    isPreview?: boolean
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PackageCourseCreateManyCourseInput = {
    id?: string
    packageId: string
  }

  export type LessonUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LessonUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    resources?: LessonUpdateresourcesInput | string[]
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    package?: PackageUpdateOneRequiredWithoutPackageCoursesNestedInput
  }

  export type PackageCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseCreateManyPackageInput = {
    id?: string
    courseId: string
  }

  export type PackageCourseUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutPackageCoursesNestedInput
  }

  export type PackageCourseUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCourseUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    content: string
    featuredImage?: string | null
    tags?: BlogPostCreatetagsInput | string[]
    series?: string | null
    publishDate?: Date | string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedBlogPostsNestedInput
    seoMeta?: SeoMetaUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    seoMeta?: SeoMetaUncheckedUpdateOneWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BlogPostUpdatetagsInput | string[]
    series?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QuickEditRevisionCreateManyItemInput = {
    id?: string
    value: string
    changeType: string
    createdAt?: Date | string
    createdById: string
  }

  export type QuickEditRevisionUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutQuickEditRevisionsNestedInput
  }

  export type QuickEditRevisionUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QuickEditRevisionUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}